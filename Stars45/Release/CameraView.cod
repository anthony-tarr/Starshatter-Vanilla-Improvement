; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Matrix Games\Dev\nGenEx\CameraView.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?WorldPlaneToView@CameraView@@MAEXAAUPlane@@@Z	; CameraView::WorldPlaneToView
PUBLIC	?SetInfinite@CameraView@@UAEHH@Z		; CameraView::SetInfinite
PUBLIC	?FindDepth@CameraView@@UAEXPAVGraphic@@@Z	; CameraView::FindDepth
PUBLIC	?Render@CameraView@@UAEXPAVGraphic@@K@Z		; CameraView::Render
PUBLIC	?RenderLensFlare@CameraView@@UAEXXZ		; CameraView::RenderLensFlare
PUBLIC	?RenderSprites@CameraView@@UAEXXZ		; CameraView::RenderSprites
PUBLIC	?RenderBackground@CameraView@@UAEXXZ		; CameraView::RenderBackground
PUBLIC	?RenderForeground@CameraView@@UAEXXZ		; CameraView::RenderForeground
PUBLIC	?RenderSceneObjects@CameraView@@UAEX_N@Z	; CameraView::RenderSceneObjects
PUBLIC	?RenderScene@CameraView@@UAEXXZ			; CameraView::RenderScene
PUBLIC	?MarkVisibleLights@CameraView@@UAEXPAVGraphic@@K@Z ; CameraView::MarkVisibleLights
PUBLIC	?MarkVisibleObjects@CameraView@@UAEXXZ		; CameraView::MarkVisibleObjects
PUBLIC	?UnTranslateScene@CameraView@@UAEXXZ		; CameraView::UnTranslateScene
PUBLIC	?TranslateScene@CameraView@@UAEXXZ		; CameraView::TranslateScene
PUBLIC	?GetProjectionType@CameraView@@UBEKXZ		; CameraView::GetProjectionType
PUBLIC	?SetProjectionType@CameraView@@UAEXK@Z		; CameraView::SetProjectionType
PUBLIC	?GetFieldOfView@CameraView@@UBENXZ		; CameraView::GetFieldOfView
PUBLIC	?SetFieldOfView@CameraView@@UAEXN@Z		; CameraView::SetFieldOfView
PUBLIC	?SetDepthScale@CameraView@@UAEXM@Z		; CameraView::SetDepthScale
PUBLIC	?LensFlare@CameraView@@UAEXHN@Z			; CameraView::LensFlare
PUBLIC	?LensFlareElements@CameraView@@UAEXPAVBitmap@@000@Z ; CameraView::LensFlareElements
PUBLIC	?UseScene@CameraView@@UAEXPAVScene@@@Z		; CameraView::UseScene
PUBLIC	?UseCamera@CameraView@@UAEXPAVCamera@@@Z	; CameraView::UseCamera
PUBLIC	?OnWindowMove@CameraView@@UAEXXZ		; CameraView::OnWindowMove
PUBLIC	?Refresh@CameraView@@UAEXXZ			; CameraView::Refresh
PUBLIC	??_R4CameraView@@6B@				; CameraView::`RTTI Complete Object Locator'
PUBLIC	??_R3CameraView@@8				; CameraView::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CameraView@@8				; CameraView::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CameraView@@8			; CameraView::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCameraView@@@8				; CameraView `RTTI Type Descriptor'
PUBLIC	??_R4View@@6B@					; View::`RTTI Complete Object Locator'
PUBLIC	??_R3View@@8					; View::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2View@@8					; View::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@View@@8				; View::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVView@@@8				; View `RTTI Type Descriptor'
PUBLIC	??0View@@QAE@PAVWindow@@@Z			; View::View
PUBLIC	??0?$List@VGraphic@@@@QAE@XZ			; List<Graphic>::List<Graphic>
PUBLIC	?Refresh@View@@UAEXXZ				; View::Refresh
PUBLIC	?OnWindowMove@View@@UAEXXZ			; View::OnWindowMove
PUBLIC	??_GView@@UAEPAXI@Z				; View::`scalar deleting destructor'
PUBLIC	??1View@@UAE@XZ					; View::~View
PUBLIC	??1?$List@VGraphic@@@@QAE@XZ			; List<Graphic>::~List<Graphic>
PUBLIC	?OnShow@View@@UAEXXZ				; View::OnShow
PUBLIC	?OnHide@View@@UAEXXZ				; View::OnHide
PUBLIC	?SetWindow@View@@UAEXPAVWindow@@@Z		; View::SetWindow
PUBLIC	?GetWindow@View@@UAEPAVWindow@@XZ		; View::GetWindow
PUBLIC	??_GCameraView@@UAEPAXI@Z			; CameraView::`scalar deleting destructor'
PUBLIC	?SetOrthogonal@Projector@@QAEX_N@Z		; Projector::SetOrthogonal
PUBLIC	??0Rect@@QAE@XZ					; Rect::Rect
PUBLIC	?GetRect@Window@@QBEABURect@@XZ			; Window::GetRect
PUBLIC	?Height@Window@@QBEHXZ				; Window::Height
PUBLIC	?GetInstance@Video@@SAPAV1@XZ			; Video::GetInstance
PUBLIC	??GPoint@@QBE?AU0@XZ				; Point::operator-
PUBLIC	?attach@?$ListIter@VGraphic@@@@QAEXAAV?$List@VGraphic@@@@@Z ; ListIter<Graphic>::attach
PUBLIC	?resize@?$List@VGraphic@@@@AAEXH@Z		; List<Graphic>::resize
PUBLIC	?append@?$List@VGraphic@@@@QAEXPBVGraphic@@@Z	; List<Graphic>::append
PUBLIC	?clear@?$List@VGraphic@@@@QAEXXZ		; List<Graphic>::clear
PUBLIC	?Graphics@Scene@@QAEAAV?$List@VGraphic@@@@XZ	; Scene::Graphics
PUBLIC	?SetActive@Light@@QAEX_N@Z			; Light::SetActive
PUBLIC	?Radius@Graphic@@QBEMXZ				; Graphic::Radius
PUBLIC	?Background@Scene@@QAEAAV?$List@VGraphic@@@@XZ	; Scene::Background
PUBLIC	?Foreground@Scene@@QAEAAV?$List@VGraphic@@@@XZ	; Scene::Foreground
PUBLIC	?Sprites@Scene@@QAEAAV?$List@VGraphic@@@@XZ	; Scene::Sprites
PUBLIC	?TYPENAME@Graphic@@SAPBDXZ			; Graphic::TYPENAME
PUBLIC	?check@?$List@VGraphic@@@@ABE_NAAH@Z		; List<Graphic>::check
PUBLIC	??A?$List@VGraphic@@@@QBEPAVGraphic@@H@Z	; List<Graphic>::operator[]
PUBLIC	?last@?$List@VGraphic@@@@QBEPAVGraphic@@XZ	; List<Graphic>::last
PUBLIC	?size@?$List@VGraphic@@@@QBEHXZ			; List<Graphic>::size
PUBLIC	?isEmpty@?$List@VGraphic@@@@QBE_NXZ		; List<Graphic>::isEmpty
PUBLIC	?swap@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z	; List<Graphic>::swap
PUBLIC	?qsort@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z ; List<Graphic>::qsort
PUBLIC	?sort@?$List@VGraphic@@@@QAEXXZ			; List<Graphic>::sort
PUBLIC	??0Color@@QAE@ABV0@@Z				; Color::Color
PUBLIC	?Ambient@Scene@@QAE?AVColor@@XZ			; Scene::Ambient
PUBLIC	?GetShadows@Solid@@QAEAAV?$List@VShadow@@@@XZ	; Solid::GetShadows
PUBLIC	??0?$ListIter@VGraphic@@@@QAE@AAV?$List@VGraphic@@@@@Z ; ListIter<Graphic>::ListIter<Graphic>
PUBLIC	?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ	; ListIter<Graphic>::next
PUBLIC	??E?$ListIter@VGraphic@@@@QAEHXZ		; ListIter<Graphic>::operator++
PUBLIC	?reset@?$ListIter@VGraphic@@@@QAEXXZ		; ListIter<Graphic>::reset
PUBLIC	?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ	; ListIter<Graphic>::value
PUBLIC	??0?$ListIter@VShadow@@@@QAE@AAV?$List@VShadow@@@@@Z ; ListIter<Shadow>::ListIter<Shadow>
PUBLIC	?next@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ	; ListIter<Shadow>::next
PUBLIC	??E?$ListIter@VShadow@@@@QAEHXZ			; ListIter<Shadow>::operator++
PUBLIC	?value@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ	; ListIter<Shadow>::value
PUBLIC	?IsVisible@Graphic@@QBE_NXZ			; Graphic::IsVisible
PUBLIC	??0Vec3@@QAE@XZ					; Vec3::Vec3
PUBLIC	??GVec3@@QBE?AU0@ABU0@@Z			; Vec3::operator-
PUBLIC	??4Vec3@@QAEAAU0@ABU0@@Z			; Vec3::operator=
PUBLIC	?Width@Window@@QBEHXZ				; Window::Width
PUBLIC	?Lights@Scene@@QAEAAV?$List@VLight@@@@XZ	; Scene::Lights
PUBLIC	?Location@Light@@QBE?AUPoint@@XZ		; Light::Location
PUBLIC	?Type@Light@@QBEKXZ				; Light::Type
PUBLIC	?Intensity@Light@@QBEMXZ			; Light::Intensity
PUBLIC	?IsActive@Light@@QBE_NXZ			; Light::IsActive
PUBLIC	?CastsShadow@Light@@QBE_NXZ			; Light::CastsShadow
PUBLIC	??0?$ListIter@VLight@@@@QAE@AAV?$List@VLight@@@@@Z ; ListIter<Light>::ListIter<Light>
PUBLIC	?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ	; ListIter<Light>::next
PUBLIC	??E?$ListIter@VLight@@@@QAEHXZ			; ListIter<Light>::operator++
PUBLIC	?value@?$ListIter@VLight@@@@QAEPAVLight@@XZ	; ListIter<Light>::value
PUBLIC	??DVec3@@QBEMABU0@@Z				; Vec3::operator*
PUBLIC	??DPoint@@QBENABU0@@Z				; Point::operator*
PUBLIC	??_C@_07PEMABHH@Graphic?$AA@			; `string'
PUBLIC	??_7View@@6B@					; View::`vftable'
PUBLIC	??_7CameraView@@6B@				; CameraView::`vftable'
EXTRN	??0Projector@@QAE@PAVWindow@@PAVCamera@@@Z:PROC	; Projector::Projector
EXTRN	??_EView@@UAEPAXI@Z:PROC			; View::`vector deleting destructor'
EXTRN	??1Projector@@UAE@XZ:PROC			; Projector::~Projector
EXTRN	??_ECameraView@@UAEPAXI@Z:PROC			; CameraView::`vector deleting destructor'
EXTRN	?video_instance@Video@@1PAV1@A:DWORD		; Video::video_instance
EXTRN	??MGraphic@@QBEHABV0@@Z:PROC			; Graphic::operator<
EXTRN	??NGraphic@@QBEHABV0@@Z:PROC			; Graphic::operator<=
EXTRN	?Render@Shadow@@QAEXPAVVideo@@@Z:PROC		; Shadow::Render
EXTRN	?DrawBitmap@Window@@QAEXHHHHPAVBitmap@@H@Z:PROC	; Window::DrawBitmap
EXTRN	?IsVisible@Projector@@QBEHABUVec3@@M@Z:PROC	; Projector::IsVisible
EXTRN	_atexit:PROC
EXTRN	??0Scene@@QAE@XZ:PROC				; Scene::Scene
EXTRN	??1Scene@@UAE@XZ:PROC				; Scene::~Scene
;	COMDAT ??_7CameraView@@6B@
CONST	SEGMENT
??_7CameraView@@6B@ DD FLAT:??_R4CameraView@@6B@	; CameraView::`vftable'
	DD	FLAT:??_ECameraView@@UAEPAXI@Z
	DD	FLAT:?Refresh@CameraView@@UAEXXZ
	DD	FLAT:?OnWindowMove@CameraView@@UAEXXZ
	DD	FLAT:?OnShow@View@@UAEXXZ
	DD	FLAT:?OnHide@View@@UAEXXZ
	DD	FLAT:?SetWindow@View@@UAEXPAVWindow@@@Z
	DD	FLAT:?GetWindow@View@@UAEPAVWindow@@XZ
	DD	FLAT:?UseCamera@CameraView@@UAEXPAVCamera@@@Z
	DD	FLAT:?UseScene@CameraView@@UAEXPAVScene@@@Z
	DD	FLAT:?LensFlareElements@CameraView@@UAEXPAVBitmap@@000@Z
	DD	FLAT:?LensFlare@CameraView@@UAEXHN@Z
	DD	FLAT:?SetDepthScale@CameraView@@UAEXM@Z
	DD	FLAT:?SetFieldOfView@CameraView@@UAEXN@Z
	DD	FLAT:?GetFieldOfView@CameraView@@UBENXZ
	DD	FLAT:?SetProjectionType@CameraView@@UAEXK@Z
	DD	FLAT:?GetProjectionType@CameraView@@UBEKXZ
	DD	FLAT:?TranslateScene@CameraView@@UAEXXZ
	DD	FLAT:?UnTranslateScene@CameraView@@UAEXXZ
	DD	FLAT:?MarkVisibleObjects@CameraView@@UAEXXZ
	DD	FLAT:?MarkVisibleLights@CameraView@@UAEXPAVGraphic@@K@Z
	DD	FLAT:?RenderScene@CameraView@@UAEXXZ
	DD	FLAT:?RenderSceneObjects@CameraView@@UAEX_N@Z
	DD	FLAT:?RenderForeground@CameraView@@UAEXXZ
	DD	FLAT:?RenderBackground@CameraView@@UAEXXZ
	DD	FLAT:?RenderSprites@CameraView@@UAEXXZ
	DD	FLAT:?RenderLensFlare@CameraView@@UAEXXZ
	DD	FLAT:?Render@CameraView@@UAEXPAVGraphic@@K@Z
	DD	FLAT:?FindDepth@CameraView@@UAEXPAVGraphic@@@Z
	DD	FLAT:?SetInfinite@CameraView@@UAEHH@Z
	DD	FLAT:?WorldPlaneToView@CameraView@@MAEXAAUPlane@@@Z
CONST	ENDS
;	COMDAT ??_R4CameraView@@6B@
rdata$r	SEGMENT
??_R4CameraView@@6B@ DD 00H				; CameraView::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCameraView@@@8
	DD	FLAT:??_R3CameraView@@8
rdata$r	ENDS
;	COMDAT ??_R3CameraView@@8
rdata$r	SEGMENT
??_R3CameraView@@8 DD 00H				; CameraView::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CameraView@@8
rdata$r	ENDS
;	COMDAT ??_R2CameraView@@8
rdata$r	SEGMENT
??_R2CameraView@@8 DD FLAT:??_R1A@?0A@EA@CameraView@@8	; CameraView::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@View@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CameraView@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CameraView@@8 DD FLAT:??_R0?AVCameraView@@@8 ; CameraView::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CameraView@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCameraView@@@8
_DATA	SEGMENT
??_R0?AVCameraView@@@8 DD FLAT:??_7type_info@@6B@	; CameraView `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCameraView@@', 00H
_DATA	ENDS
;	COMDAT ??_7View@@6B@
CONST	SEGMENT
??_7View@@6B@ DD FLAT:??_R4View@@6B@			; View::`vftable'
	DD	FLAT:??_EView@@UAEPAXI@Z
	DD	FLAT:?Refresh@View@@UAEXXZ
	DD	FLAT:?OnWindowMove@View@@UAEXXZ
	DD	FLAT:?OnShow@View@@UAEXXZ
	DD	FLAT:?OnHide@View@@UAEXXZ
	DD	FLAT:?SetWindow@View@@UAEXPAVWindow@@@Z
	DD	FLAT:?GetWindow@View@@UAEPAVWindow@@XZ
CONST	ENDS
;	COMDAT ??_R4View@@6B@
rdata$r	SEGMENT
??_R4View@@6B@ DD 00H					; View::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVView@@@8
	DD	FLAT:??_R3View@@8
rdata$r	ENDS
;	COMDAT ??_R3View@@8
rdata$r	SEGMENT
??_R3View@@8 DD	00H					; View::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2View@@8
rdata$r	ENDS
;	COMDAT ??_R2View@@8
rdata$r	SEGMENT
??_R2View@@8 DD	FLAT:??_R1A@?0A@EA@View@@8		; View::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@View@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@View@@8 DD FLAT:??_R0?AVView@@@8		; View::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3View@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVView@@@8
_DATA	SEGMENT
??_R0?AVView@@@8 DD FLAT:??_7type_info@@6B@		; View `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVView@@', 00H
_DATA	ENDS
;	COMDAT ?elem_size@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4PAMA
_DATA	SEGMENT
?elem_size@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4PAMA DD 03e99999ar ; 0.3 ; `CameraView::RenderLensFlare'::`25'::elem_size
	DD	03e4ccccdr			; 0.2
	DD	03ecccccdr			; 0.4
	DD	03e99999ar			; 0.3
	DD	03ecccccdr			; 0.4
	DD	03e4ccccdr			; 0.2
	DD	03f19999ar			; 0.6
	DD	03dcccccdr			; 0.1
	DD	03dcccccdr			; 0.1
	DD	03fcccccdr			; 1.6
	DD	03f800000r			; 1
	DD	03e4ccccdr			; 0.2
_DATA	ENDS
;	COMDAT ?elem_dist@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4PAMA
_DATA	SEGMENT
?elem_dist@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4PAMA DD 0be4ccccdr ; -0.2 ; `CameraView::RenderLensFlare'::`25'::elem_dist
	DD	03f000000r			; 0.5
	DD	03f0ccccdr			; 0.55
	DD	03f1eb852r			; 0.62
	DD	03f9d70a4r			; 1.23
	DD	03faa3d71r			; 1.33
	DD	03faccccdr			; 1.35
	DD	03f4ccccdr			; 0.8
	DD	03f666666r			; 0.9
	DD	03fb33333r			; 1.4
	DD	03fd9999ar			; 1.7
	DD	03fe66666r			; 1.8
_DATA	ENDS
;	COMDAT ?elem_indx@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4PAHA
_DATA	SEGMENT
?elem_indx@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4PAHA DD 00H ; `CameraView::RenderLensFlare'::`25'::elem_indx
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
_DATA	ENDS
;	COMDAT ?nelem@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4HA
_DATA	SEGMENT
?nelem@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4HA DD 0cH ; `CameraView::RenderLensFlare'::`25'::nelem
_DATA	ENDS
;	COMDAT ??_C@_07PEMABHH@Graphic?$AA@
CONST	SEGMENT
??_C@_07PEMABHH@Graphic?$AA@ DB 'Graphic', 00H		; `string'
	ORG $+1344
_PI	DQ	0400921fb54442d18r		; 3.14159
; Function compile flags: /Ogtp
; File c:\matrix games\dev\foundationex\list.inl
;	COMDAT ?swap@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_a$ = 12						; size = 4
?swap@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z PROC	; List<Graphic>::swap, COMDAT
; _i$ = eax
; _j$ = ecx

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp]

; 305  :    if (i >= 0 && i < items && j >= 0 && j < items && i != j) {

  00006	85 c0		 test	 eax, eax
  00008	78 25		 js	 SHORT $LN1@swap
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0000e	8b 36		 mov	 esi, DWORD PTR [esi]
  00010	3b c6		 cmp	 eax, esi
  00012	7d 1a		 jge	 SHORT $LN4@swap
  00014	85 c9		 test	 ecx, ecx
  00016	78 16		 js	 SHORT $LN4@swap
  00018	3b ce		 cmp	 ecx, esi
  0001a	7d 12		 jge	 SHORT $LN4@swap
  0001c	3b c1		 cmp	 eax, ecx
  0001e	74 0e		 je	 SHORT $LN4@swap

; 306  :       T* t = a[i];

  00020	8b 34 82	 mov	 esi, DWORD PTR [edx+eax*4]
  00023	57		 push	 edi

; 307  :       a[i] = a[j];

  00024	8b 3c 8a	 mov	 edi, DWORD PTR [edx+ecx*4]
  00027	89 3c 82	 mov	 DWORD PTR [edx+eax*4], edi

; 308  :       a[j] = t;

  0002a	89 34 8a	 mov	 DWORD PTR [edx+ecx*4], esi
  0002d	5f		 pop	 edi
$LN4@swap:
  0002e	5e		 pop	 esi
$LN1@swap:

; 309  :    }
; 310  : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?swap@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z ENDP	; List<Graphic>::swap
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize@?$List@VGraphic@@@@AAEXH@Z
_TEXT	SEGMENT
_newsize$ = 8						; size = 4
?resize@?$List@VGraphic@@@@AAEXH@Z PROC			; List<Graphic>::resize, COMDAT
; _this$ = ecx

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  :    if (newsize > extent) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _newsize$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0000c	7e 62		 jle	 SHORT $LN7@resize@7

; 126  :       extent = 16 * (newsize/16 + 1);

  0000e	99		 cdq
  0000f	83 e2 0f	 and	 edx, 15			; 0000000fH
  00012	03 c2		 add	 eax, edx
  00014	c1 f8 04	 sar	 eax, 4
  00017	40		 inc	 eax
  00018	c1 e0 04	 shl	 eax, 4

; 127  : 
; 128  : #ifdef MEM_DEBUG
; 129  :       T** v = new(__FILE__,__LINE__) PTR[extent];
; 130  : #else
; 131  :       T** v = new PTR[extent];

  0001b	33 c9		 xor	 ecx, ecx
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00020	ba 04 00 00 00	 mov	 edx, 4
  00025	f7 e2		 mul	 edx
  00027	0f 90 c1	 seto	 cl
  0002a	57		 push	 edi
  0002b	f7 d9		 neg	 ecx
  0002d	0b c8		 or	 ecx, eax
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00035	8b f8		 mov	 edi, eax

; 132  : #endif
; 133  : 	  int i;
; 134  :       for (i = 0; i < items; i++)

  00037	33 c0		 xor	 eax, eax
  00039	83 c4 04	 add	 esp, 4
  0003c	39 06		 cmp	 DWORD PTR [esi], eax
  0003e	7e 0e		 jle	 SHORT $LN4@resize@7
$LL6@resize@7:

; 135  :          v[i] = array[i];

  00040	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00043	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00046	89 14 87	 mov	 DWORD PTR [edi+eax*4], edx
  00049	40		 inc	 eax
  0004a	3b 06		 cmp	 eax, DWORD PTR [esi]
  0004c	7c f2		 jl	 SHORT $LL6@resize@7
$LN4@resize@7:

; 136  : 
; 137  :       for (; i < extent; i++)

  0004e	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00051	7d 0d		 jge	 SHORT $LN1@resize@7
$LL3@resize@7:

; 138  :          v[i] = 0;

  00053	c7 04 87 00 00
	00 00		 mov	 DWORD PTR [edi+eax*4], 0
  0005a	40		 inc	 eax
  0005b	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0005e	7c f3		 jl	 SHORT $LL3@resize@7
$LN1@resize@7:

; 139  : 
; 140  :       delete [] array;   

  00060	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00069	83 c4 04	 add	 esp, 4

; 141  :       array = v;

  0006c	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0006f	5f		 pop	 edi
$LN7@resize@7:
  00070	5e		 pop	 esi

; 142  :    }
; 143  : }

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?resize@?$List@VGraphic@@@@AAEXH@Z ENDP			; List<Graphic>::resize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?qsort@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z
_TEXT	SEGMENT
tv202 = -12						; size = 4
tv206 = -8						; size = 4
_this$ = -4						; size = 4
_pivot$ = 8						; size = 4
_a$ = 8							; size = 4
_lo0$ = 12						; size = 4
_hi0$ = 16						; size = 4
?qsort@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z PROC	; List<Graphic>::qsort, COMDAT
; _this$ = ecx

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 315  :    int lo = lo0;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _lo0$[ebp]
  00009	53		 push	 ebx
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 316  :    int hi = hi0;

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _hi0$[ebp]
  00010	57		 push	 edi
  00011	8b d8		 mov	 ebx, eax
  00013	8b f9		 mov	 edi, ecx

; 317  : 
; 318  :    // zero or one element list, nothing to do:
; 319  :    if (lo >= hi) {

  00015	3b c1		 cmp	 eax, ecx
  00017	0f 8d 0d 01 00
	00		 jge	 $LN8@qsort
  0001d	56		 push	 esi
  0001e	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  00021	eb 05		 jmp	 SHORT $LN14@qsort
$LL26@qsort:
  00023	8b 45 0c	 mov	 eax, DWORD PTR _lo0$[ebp]
  00026	8b cf		 mov	 ecx, edi
$LN14@qsort:

; 320  :       return;
; 321  :    }
; 322  : 
; 323  :    // two element list, swap if needed:
; 324  :    else if (lo == hi-1) {

  00028	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  0002b	3b c2		 cmp	 eax, edx
  0002d	0f 84 d6 00 00
	00		 je	 $LN21@qsort

; 327  :       }
; 328  :       return;
; 329  :    }
; 330  : 
; 331  :    // pick a pivot, and move it out of the way:
; 332  :    int mid   = (lo+hi)/2;

  00033	03 c1		 add	 eax, ecx
  00035	99		 cdq
  00036	2b c2		 sub	 eax, edx
  00038	d1 f8		 sar	 eax, 1

; 333  :    T*  pivot = a[mid];

  0003a	8b 14 86	 mov	 edx, DWORD PTR [esi+eax*4]
  0003d	89 55 08	 mov	 DWORD PTR _pivot$[ebp], edx

; 334  :    a[mid]    = a[hi];

  00040	8b 14 8e	 mov	 edx, DWORD PTR [esi+ecx*4]
  00043	89 14 86	 mov	 DWORD PTR [esi+eax*4], edx

; 335  :    a[hi]     = pivot;

  00046	8b 45 08	 mov	 eax, DWORD PTR _pivot$[ebp]
  00049	8d 14 8e	 lea	 edx, DWORD PTR [esi+ecx*4]
  0004c	89 02		 mov	 DWORD PTR [edx], eax

; 336  : 
; 337  :    while (lo < hi) {

  0004e	8b 45 0c	 mov	 eax, DWORD PTR _lo0$[ebp]
  00051	3b c1		 cmp	 eax, ecx
  00053	0f 8d 7c 00 00
	00		 jge	 $LN25@qsort
  00059	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]
  0005c	89 4d f8	 mov	 DWORD PTR tv206[ebp], ecx
  0005f	89 55 f4	 mov	 DWORD PTR tv202[ebp], edx
$LL7@qsort:

; 338  :       while ((*a[lo] <= *pivot) && lo < hi) lo++;

  00062	8b 55 08	 mov	 edx, DWORD PTR _pivot$[ebp]
  00065	8b 45 f8	 mov	 eax, DWORD PTR tv206[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 ??NGraphic@@QBEHABV0@@Z	; Graphic::operator<=
  00070	85 c0		 test	 eax, eax
  00072	74 1a		 je	 SHORT $LN19@qsort
$LL5@qsort:
  00074	3b df		 cmp	 ebx, edi
  00076	7d 16		 jge	 SHORT $LN19@qsort
  00078	8b 4d 08	 mov	 ecx, DWORD PTR _pivot$[ebp]
  0007b	43		 inc	 ebx
  0007c	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]
  0007f	51		 push	 ecx
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	89 45 f8	 mov	 DWORD PTR tv206[ebp], eax
  00085	e8 00 00 00 00	 call	 ??NGraphic@@QBEHABV0@@Z	; Graphic::operator<=
  0008a	85 c0		 test	 eax, eax
  0008c	75 e6		 jne	 SHORT $LL5@qsort
$LN19@qsort:

; 339  :       while ((*pivot <= *a[hi]) && lo < hi) hi--;

  0008e	8b 55 f4	 mov	 edx, DWORD PTR tv202[ebp]
  00091	8b 02		 mov	 eax, DWORD PTR [edx]
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _pivot$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ??NGraphic@@QBEHABV0@@Z	; Graphic::operator<=
  0009c	85 c0		 test	 eax, eax
  0009e	74 1b		 je	 SHORT $LN2@qsort
$LL3@qsort:
  000a0	3b df		 cmp	 ebx, edi
  000a2	7d 2b		 jge	 SHORT $LN27@qsort
  000a4	4f		 dec	 edi
  000a5	8b 0c be	 mov	 ecx, DWORD PTR [esi+edi*4]
  000a8	8d 04 be	 lea	 eax, DWORD PTR [esi+edi*4]
  000ab	51		 push	 ecx
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _pivot$[ebp]
  000af	89 45 f4	 mov	 DWORD PTR tv202[ebp], eax
  000b2	e8 00 00 00 00	 call	 ??NGraphic@@QBEHABV0@@Z	; Graphic::operator<=
  000b7	85 c0		 test	 eax, eax
  000b9	75 e5		 jne	 SHORT $LL3@qsort
$LN2@qsort:

; 340  : 
; 341  :       if (lo < hi) {

  000bb	3b df		 cmp	 ebx, edi
  000bd	7d 10		 jge	 SHORT $LN27@qsort

; 342  :          swap(a, lo, hi);

  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	56		 push	 esi
  000c3	52		 push	 edx
  000c4	8b cf		 mov	 ecx, edi
  000c6	8b c3		 mov	 eax, ebx
  000c8	e8 00 00 00 00	 call	 ?swap@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z ; List<Graphic>::swap
  000cd	eb 93		 jmp	 SHORT $LL7@qsort
$LN27@qsort:

; 336  : 
; 337  :    while (lo < hi) {

  000cf	8b 4d 10	 mov	 ecx, DWORD PTR _hi0$[ebp]
  000d2	8b 45 0c	 mov	 eax, DWORD PTR _lo0$[ebp]
$LN25@qsort:

; 343  :       }
; 344  :    }
; 345  : 
; 346  :    // Put the pivot into its final location:
; 347  :    a[hi0] = a[hi];

  000d5	8b 14 be	 mov	 edx, DWORD PTR [esi+edi*4]
  000d8	8d 0c 8e	 lea	 ecx, DWORD PTR [esi+ecx*4]
  000db	89 11		 mov	 DWORD PTR [ecx], edx

; 348  :    a[hi] = pivot;

  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _pivot$[ebp]

; 349  : 
; 350  : 	qsort(a, lo0, lo-1);

  000e0	4b		 dec	 ebx
  000e1	53		 push	 ebx
  000e2	50		 push	 eax
  000e3	89 0c be	 mov	 DWORD PTR [esi+edi*4], ecx
  000e6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	56		 push	 esi
  000ea	e8 00 00 00 00	 call	 ?qsort@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z ; List<Graphic>::qsort

; 351  : 	qsort(a, hi+1, hi0);

  000ef	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  000f2	8b 7d 10	 mov	 edi, DWORD PTR _hi0$[ebp]
  000f5	89 5d 0c	 mov	 DWORD PTR _lo0$[ebp], ebx
  000f8	3b df		 cmp	 ebx, edi
  000fa	0f 8c 23 ff ff
	ff		 jl	 $LL26@qsort
  00100	5e		 pop	 esi
  00101	5f		 pop	 edi
  00102	5b		 pop	 ebx

; 352  : }

  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c2 0c 00	 ret	 12			; 0000000cH
$LN21@qsort:

; 325  :       if (*a[hi] < *a[lo]) {

  00109	8b 14 86	 mov	 edx, DWORD PTR [esi+eax*4]
  0010c	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  0010f	52		 push	 edx
  00110	e8 00 00 00 00	 call	 ??MGraphic@@QBEHABV0@@Z	; Graphic::operator<
  00115	85 c0		 test	 eax, eax
  00117	74 10		 je	 SHORT $LN28@qsort

; 326  :          swap(a, lo, hi);

  00119	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011c	8b 4d 10	 mov	 ecx, DWORD PTR _hi0$[ebp]
  0011f	56		 push	 esi
  00120	50		 push	 eax
  00121	8b 45 0c	 mov	 eax, DWORD PTR _lo0$[ebp]
  00124	e8 00 00 00 00	 call	 ?swap@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z ; List<Graphic>::swap
$LN28@qsort:
  00129	5e		 pop	 esi
$LN8@qsort:
  0012a	5f		 pop	 edi
  0012b	5b		 pop	 ebx

; 352  : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 0c 00	 ret	 12			; 0000000cH
?qsort@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z ENDP	; List<Graphic>::qsort
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ
_TEXT	SEGMENT
?value@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ PROC	; ListIter<Shadow>::value, COMDAT
; _this$ = eax

; 382  :    if (list && step >= 0 && step < list->items)

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	85 c9		 test	 ecx, ecx
  00004	74 12		 je	 SHORT $LN1@value@5
  00006	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00009	85 c0		 test	 eax, eax
  0000b	78 0b		 js	 SHORT $LN1@value@5
  0000d	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000f	7d 07		 jge	 SHORT $LN1@value@5

; 383  :       return list->array[step];

  00011	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00014	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 386  : }

  00017	c3		 ret	 0
$LN1@value@5:

; 384  : 
; 385  :    return 0;

  00018	33 c0		 xor	 eax, eax

; 386  : }

  0001a	c3		 ret	 0
?value@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ ENDP	; ListIter<Shadow>::value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?next@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ
_TEXT	SEGMENT
?next@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ PROC	; ListIter<Shadow>::next, COMDAT
; _this$ = edx

; 404  :    if (list && step >= -1 && step < list->items-1)

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 1c		 je	 SHORT $LN1@next@5
  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	7c 14		 jl	 SHORT $LN1@next@5
  0000e	56		 push	 esi
  0000f	8b 31		 mov	 esi, DWORD PTR [ecx]
  00011	4e		 dec	 esi
  00012	3b c6		 cmp	 eax, esi
  00014	5e		 pop	 esi
  00015	7d 0b		 jge	 SHORT $LN1@next@5

; 405  :       return list->array[++step];

  00017	40		 inc	 eax
  00018	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 408  : }

  00021	c3		 ret	 0
$LN1@next@5:

; 406  : 
; 407  :    return 0;

  00022	33 c0		 xor	 eax, eax

; 408  : }

  00024	c3		 ret	 0
?next@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ ENDP	; ListIter<Shadow>::next
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$ListIter@VLight@@@@QAEPAVLight@@XZ
_TEXT	SEGMENT
?value@?$ListIter@VLight@@@@QAEPAVLight@@XZ PROC	; ListIter<Light>::value, COMDAT
; _this$ = ecx

; 382  :    if (list && step >= 0 && step < list->items)

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	85 d2		 test	 edx, edx
  00004	74 12		 je	 SHORT $LN1@value@6
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	85 c0		 test	 eax, eax
  0000b	78 0b		 js	 SHORT $LN1@value@6
  0000d	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000f	7d 07		 jge	 SHORT $LN1@value@6

; 383  :       return list->array[step];

  00011	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00014	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 386  : }

  00017	c3		 ret	 0
$LN1@value@6:

; 384  : 
; 385  :    return 0;

  00018	33 c0		 xor	 eax, eax

; 386  : }

  0001a	c3		 ret	 0
?value@?$ListIter@VLight@@@@QAEPAVLight@@XZ ENDP	; ListIter<Light>::value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ
_TEXT	SEGMENT
?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ PROC		; ListIter<Light>::next, COMDAT
; _this$ = ecx

; 404  :    if (list && step >= -1 && step < list->items-1)

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	85 d2		 test	 edx, edx
  00004	74 1c		 je	 SHORT $LN1@next@6
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	7c 14		 jl	 SHORT $LN1@next@6
  0000e	56		 push	 esi
  0000f	8b 32		 mov	 esi, DWORD PTR [edx]
  00011	4e		 dec	 esi
  00012	3b c6		 cmp	 eax, esi
  00014	5e		 pop	 esi
  00015	7d 0b		 jge	 SHORT $LN1@next@6

; 405  :       return list->array[++step];

  00017	40		 inc	 eax
  00018	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001b	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 408  : }

  00021	c3		 ret	 0
$LN1@next@6:

; 406  : 
; 407  :    return 0;

  00022	33 c0		 xor	 eax, eax

; 408  : }

  00024	c3		 ret	 0
?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ ENDP		; ListIter<Light>::next
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?attach@?$ListIter@VGraphic@@@@QAEXAAV?$List@VGraphic@@@@@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
?attach@?$ListIter@VGraphic@@@@QAEXAAV?$List@VGraphic@@@@@Z PROC ; ListIter<Graphic>::attach, COMDAT
; _this$ = ecx

; 423  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 424  :    list = &l;

  00003	8b 45 08	 mov	 eax, DWORD PTR _l$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 425  :    step = -1;

  00008	c7 41 04 ff ff
	ff ff		 mov	 DWORD PTR [ecx+4], -1

; 426  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?attach@?$ListIter@VGraphic@@@@QAEXAAV?$List@VGraphic@@@@@Z ENDP ; ListIter<Graphic>::attach
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ
_TEXT	SEGMENT
?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ PROC	; ListIter<Graphic>::value, COMDAT
; _this$ = ecx

; 382  :    if (list && step >= 0 && step < list->items)

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	85 d2		 test	 edx, edx
  00004	74 12		 je	 SHORT $LN1@value@7
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	85 c0		 test	 eax, eax
  0000b	78 0b		 js	 SHORT $LN1@value@7
  0000d	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000f	7d 07		 jge	 SHORT $LN1@value@7

; 383  :       return list->array[step];

  00011	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00014	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 386  : }

  00017	c3		 ret	 0
$LN1@value@7:

; 384  : 
; 385  :    return 0;

  00018	33 c0		 xor	 eax, eax

; 386  : }

  0001a	c3		 ret	 0
?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ENDP	; ListIter<Graphic>::value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ
_TEXT	SEGMENT
?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ PROC	; ListIter<Graphic>::next, COMDAT
; _this$ = ecx

; 404  :    if (list && step >= -1 && step < list->items-1)

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	85 d2		 test	 edx, edx
  00004	74 1c		 je	 SHORT $LN1@next@7
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	7c 14		 jl	 SHORT $LN1@next@7
  0000e	56		 push	 esi
  0000f	8b 32		 mov	 esi, DWORD PTR [edx]
  00011	4e		 dec	 esi
  00012	3b c6		 cmp	 eax, esi
  00014	5e		 pop	 esi
  00015	7d 0b		 jge	 SHORT $LN1@next@7

; 405  :       return list->array[++step];

  00017	40		 inc	 eax
  00018	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001b	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 408  : }

  00021	c3		 ret	 0
$LN1@next@7:

; 406  : 
; 407  :    return 0;

  00022	33 c0		 xor	 eax, eax

; 408  : }

  00024	c3		 ret	 0
?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ENDP	; ListIter<Graphic>::next
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?sort@?$List@VGraphic@@@@QAEXXZ
_TEXT	SEGMENT
?sort@?$List@VGraphic@@@@QAEXXZ PROC			; List<Graphic>::sort, COMDAT
; _this$ = ecx

; 357  :    if (items < 2)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 f8 02	 cmp	 eax, 2
  00005	7c 0d		 jl	 SHORT $LN2@sort

; 358  :       return;
; 359  : 
; 360  :    qsort(array, 0, items-1);

  00007	48		 dec	 eax
  00008	50		 push	 eax
  00009	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000c	6a 00		 push	 0
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?qsort@?$List@VGraphic@@@@AAEXPAPAVGraphic@@HH@Z ; List<Graphic>::qsort
$LN2@sort:

; 361  : }

  00014	c3		 ret	 0
?sort@?$List@VGraphic@@@@QAEXXZ ENDP			; List<Graphic>::sort
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?clear@?$List@VGraphic@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$List@VGraphic@@@@QAEXXZ PROC			; List<Graphic>::clear, COMDAT
; _this$ = esi

; 38   :    delete [] array;

  00000	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 39   :    items       = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	83 c4 04	 add	 esp, 4
  0000e	89 06		 mov	 DWORD PTR [esi], eax

; 40   :    extent  = 0;

  00010	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 41   :    array       = 0;

  00013	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 42   : }

  00016	c3		 ret	 0
?clear@?$List@VGraphic@@@@QAEXXZ ENDP			; List<Graphic>::clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?append@?$List@VGraphic@@@@QAEXPBVGraphic@@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?append@?$List@VGraphic@@@@QAEXPBVGraphic@@@Z PROC	; List<Graphic>::append, COMDAT
; _this$ = ecx

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 150  :    if (item) {

  00005	8b 7d 08	 mov	 edi, DWORD PTR _item$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	74 18		 je	 SHORT $LN2@append@7

; 151  :       if (items+1 > extent) resize(items+1);

  0000e	8b 06		 mov	 eax, DWORD PTR [esi]
  00010	40		 inc	 eax
  00011	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00014	7e 06		 jle	 SHORT $LN1@append@7
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?resize@?$List@VGraphic@@@@AAEXH@Z ; List<Graphic>::resize
$LN1@append@7:

; 152  :       array[items++] = (T*)item;

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00021	89 3c 81	 mov	 DWORD PTR [ecx+eax*4], edi
  00024	ff 06		 inc	 DWORD PTR [esi]
$LN2@append@7:
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 153  :    }
; 154  : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?append@?$List@VGraphic@@@@QAEXPBVGraphic@@@Z ENDP	; List<Graphic>::append
; Function compile flags: /Ogtp
; File c:\matrix games\dev\foundationex\list.h
_TEXT	ENDS
;	COMDAT ??E?$ListIter@VShadow@@@@QAEHXZ
_TEXT	SEGMENT
??E?$ListIter@VShadow@@@@QAEHXZ PROC			; ListIter<Shadow>::operator++, COMDAT
; _this$ = edx

; 84   :    int operator++() { return next() != 0; }

  00000	e8 00 00 00 00	 call	 ?next@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ ; ListIter<Shadow>::next
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	f7 d8		 neg	 eax
  0000b	c3		 ret	 0
??E?$ListIter@VShadow@@@@QAEHXZ ENDP			; ListIter<Shadow>::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$ListIter@VShadow@@@@QAE@AAV?$List@VShadow@@@@@Z
_TEXT	SEGMENT
??0?$ListIter@VShadow@@@@QAE@AAV?$List@VShadow@@@@@Z PROC ; ListIter<Shadow>::ListIter<Shadow>, COMDAT
; _this$ = eax
; _l$ = ecx

; 82   :    ListIter(List<T>& l)             : list(&l),     step(-1)      { }

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00009	c3		 ret	 0
??0?$ListIter@VShadow@@@@QAE@AAV?$List@VShadow@@@@@Z ENDP ; ListIter<Shadow>::ListIter<Shadow>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$ListIter@VLight@@@@QAEHXZ
_TEXT	SEGMENT
??E?$ListIter@VLight@@@@QAEHXZ PROC			; ListIter<Light>::operator++, COMDAT
; _this$ = ecx

; 84   :    int operator++() { return next() != 0; }

  00000	e8 00 00 00 00	 call	 ?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::next
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	f7 d8		 neg	 eax
  0000b	c3		 ret	 0
??E?$ListIter@VLight@@@@QAEHXZ ENDP			; ListIter<Light>::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$ListIter@VLight@@@@QAE@AAV?$List@VLight@@@@@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??0?$ListIter@VLight@@@@QAE@AAV?$List@VLight@@@@@Z PROC	; ListIter<Light>::ListIter<Light>, COMDAT
; _this$ = ecx

; 82   :    ListIter(List<T>& l)             : list(&l),     step(-1)      { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0?$ListIter@VLight@@@@QAE@AAV?$List@VLight@@@@@Z ENDP	; ListIter<Light>::ListIter<Light>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?reset@?$ListIter@VGraphic@@@@QAEXXZ
_TEXT	SEGMENT
?reset@?$ListIter@VGraphic@@@@QAEXXZ PROC		; ListIter<Graphic>::reset, COMDAT
; _this$ = eax

; 89   :    void     reset() { step = -1;          }

  00000	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00007	c3		 ret	 0
?reset@?$ListIter@VGraphic@@@@QAEXXZ ENDP		; ListIter<Graphic>::reset
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$ListIter@VGraphic@@@@QAEHXZ
_TEXT	SEGMENT
??E?$ListIter@VGraphic@@@@QAEHXZ PROC			; ListIter<Graphic>::operator++, COMDAT
; _this$ = ecx

; 84   :    int operator++() { return next() != 0; }

  00000	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	f7 d8		 neg	 eax
  0000b	c3		 ret	 0
??E?$ListIter@VGraphic@@@@QAEHXZ ENDP			; ListIter<Graphic>::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$ListIter@VGraphic@@@@QAE@AAV?$List@VGraphic@@@@@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??0?$ListIter@VGraphic@@@@QAE@AAV?$List@VGraphic@@@@@Z PROC ; ListIter<Graphic>::ListIter<Graphic>, COMDAT
; _this$ = ecx

; 82   :    ListIter(List<T>& l)             : list(&l),     step(-1)      { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0?$ListIter@VGraphic@@@@QAE@AAV?$List@VGraphic@@@@@Z ENDP ; ListIter<Graphic>::ListIter<Graphic>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?isEmpty@?$List@VGraphic@@@@QBE_NXZ
_TEXT	SEGMENT
?isEmpty@?$List@VGraphic@@@@QBE_NXZ PROC		; List<Graphic>::isEmpty, COMDAT
; _this$ = ecx

; 51   :    bool     isEmpty() const      { return !items; }

  00000	33 c0		 xor	 eax, eax
  00002	39 01		 cmp	 DWORD PTR [ecx], eax
  00004	0f 94 c0	 sete	 al
  00007	c3		 ret	 0
?isEmpty@?$List@VGraphic@@@@QBE_NXZ ENDP		; List<Graphic>::isEmpty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$List@VGraphic@@@@QBEHXZ
_TEXT	SEGMENT
?size@?$List@VGraphic@@@@QBEHXZ PROC			; List<Graphic>::size, COMDAT
; _this$ = eax

; 50   :    int      size()    const      { return items;  }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	c3		 ret	 0
?size@?$List@VGraphic@@@@QBEHXZ ENDP			; List<Graphic>::size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$List@VGraphic@@@@QAE@XZ
_TEXT	SEGMENT
??1?$List@VGraphic@@@@QAE@XZ PROC			; List<Graphic>::~List<Graphic>, COMDAT
; _this$ = ecx

; 30   :    ~List()  { delete [] array; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
??1?$List@VGraphic@@@@QAE@XZ ENDP			; List<Graphic>::~List<Graphic>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$List@VGraphic@@@@QAE@XZ
_TEXT	SEGMENT
??0?$List@VGraphic@@@@QAE@XZ PROC			; List<Graphic>::List<Graphic>, COMDAT
; _this$ = ecx

; 28   :    List()   : items(0), extent(0), array(0) { }

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	c3		 ret	 0
??0?$List@VGraphic@@@@QAE@XZ ENDP			; List<Graphic>::List<Graphic>
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\cameraview.cpp
_TEXT	ENDS
;	COMDAT ?SetDepthScale@CameraView@@UAEXM@Z
_TEXT	SEGMENT
_scale$ = 8						; size = 4
?SetDepthScale@CameraView@@UAEXM@Z PROC			; CameraView::SetDepthScale, COMDAT
; _this$ = ecx

; 803  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 804  : 	projector.SetDepthScale(scale);

  00003	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  00006	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _scale$[ebp]
  0000b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0000e	83 c1 58	 add	 ecx, 88			; 00000058H
  00011	51		 push	 ecx
  00012	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00017	ff d2		 call	 edx

; 805  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?SetDepthScale@CameraView@@UAEXM@Z ENDP			; CameraView::SetDepthScale
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetInfinite@CameraView@@UAEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetInfinite@CameraView@@UAEHH@Z PROC			; CameraView::SetInfinite, COMDAT
; _this$ = ecx

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 155  : 	int old = infinite;
; 156  : 	infinite = i;

  00003	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]

; 157  : 	projector.SetInfinite(i);

  00006	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00009	56		 push	 esi
  0000a	8b b1 50 01 00
	00		 mov	 esi, DWORD PTR [ecx+336]
  00010	89 81 50 01 00
	00		 mov	 DWORD PTR [ecx+336], eax
  00016	83 c1 58	 add	 ecx, 88			; 00000058H
  00019	50		 push	 eax
  0001a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001d	ff d0		 call	 eax

; 158  : 	return old;

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi

; 159  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetInfinite@CameraView@@UAEHH@Z ENDP			; CameraView::SetInfinite
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?LensFlareElements@CameraView@@UAEXPAVBitmap@@000@Z
_TEXT	SEGMENT
_halo$ = 8						; size = 4
_e1$ = 12						; size = 4
_e2$ = 16						; size = 4
_e3$ = 20						; size = 4
?LensFlareElements@CameraView@@UAEXPAVBitmap@@000@Z PROC ; CameraView::LensFlareElements, COMDAT
; _this$ = ecx

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  : 	if (halo)

  00003	8b 45 08	 mov	 eax, DWORD PTR _halo$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 06		 je	 SHORT $LN4@LensFlareE

; 138  : 	halo_bitmap = halo;

  0000a	89 81 70 01 00
	00		 mov	 DWORD PTR [ecx+368], eax
$LN4@LensFlareE:

; 139  : 
; 140  : 	if (e1)

  00010	8b 45 0c	 mov	 eax, DWORD PTR _e1$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	74 06		 je	 SHORT $LN3@LensFlareE

; 141  : 	elem_bitmap[0] = e1;

  00017	89 81 74 01 00
	00		 mov	 DWORD PTR [ecx+372], eax
$LN3@LensFlareE:

; 142  : 
; 143  : 	if (e2)

  0001d	8b 45 10	 mov	 eax, DWORD PTR _e2$[ebp]
  00020	85 c0		 test	 eax, eax
  00022	74 06		 je	 SHORT $LN2@LensFlareE

; 144  : 	elem_bitmap[1] = e2;

  00024	89 81 78 01 00
	00		 mov	 DWORD PTR [ecx+376], eax
$LN2@LensFlareE:

; 145  : 
; 146  : 	if (e3)

  0002a	8b 45 14	 mov	 eax, DWORD PTR _e3$[ebp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 06		 je	 SHORT $LN1@LensFlareE

; 147  : 	elem_bitmap[2] = e3;

  00031	89 81 7c 01 00
	00		 mov	 DWORD PTR [ecx+380], eax
$LN1@LensFlareE:

; 148  : }

  00037	5d		 pop	 ebp
  00038	c2 10 00	 ret	 16			; 00000010H
?LensFlareElements@CameraView@@UAEXPAVBitmap@@000@Z ENDP ; CameraView::LensFlareElements
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?LensFlare@CameraView@@UAEXHN@Z
_TEXT	SEGMENT
_on$ = 8						; size = 4
_dim$ = 12						; size = 8
?LensFlare@CameraView@@UAEXHN@Z PROC			; CameraView::LensFlare, COMDAT
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 130  : 	lens_flare_enable = on;

  00003	8b 45 08	 mov	 eax, DWORD PTR _on$[ebp]

; 131  : 	lens_flare_dim    = dim;

  00006	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _dim$[ebp]
  0000b	89 81 60 01 00
	00		 mov	 DWORD PTR [ecx+352], eax
  00011	f2 0f 11 81 68
	01 00 00	 movsd	 QWORD PTR [ecx+360], xmm0

; 132  : }

  00019	5d		 pop	 ebp
  0001a	c2 0c 00	 ret	 12			; 0000000cH
?LensFlare@CameraView@@UAEXHN@Z ENDP			; CameraView::LensFlare
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetProjectionType@CameraView@@UBEKXZ
_TEXT	SEGMENT
?GetProjectionType@CameraView@@UBEKXZ PROC		; CameraView::GetProjectionType, COMDAT
; _this$ = ecx

; 109  : 	return projection_type;

  00000	8b 81 5c 01 00
	00		 mov	 eax, DWORD PTR [ecx+348]

; 110  : }

  00006	c3		 ret	 0
?GetProjectionType@CameraView@@UBEKXZ ENDP		; CameraView::GetProjectionType
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetFieldOfView@CameraView@@UBENXZ
_TEXT	SEGMENT
?GetFieldOfView@CameraView@@UBENXZ PROC			; CameraView::GetFieldOfView, COMDAT
; _this$ = ecx

; 96   : 	return projector.GetFieldOfView();

  00000	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  00003	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00006	83 c1 58	 add	 ecx, 88			; 00000058H
  00009	ff e2		 jmp	 edx
?GetFieldOfView@CameraView@@UBENXZ ENDP			; CameraView::GetFieldOfView
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetFieldOfView@CameraView@@UAEXN@Z
_TEXT	SEGMENT
_fov$ = 8						; size = 8
?SetFieldOfView@CameraView@@UAEXN@Z PROC		; CameraView::SetFieldOfView, COMDAT
; _this$ = ecx

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   : 	projector.SetFieldOfView(fov);

  00003	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  00006	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _fov$[ebp]
  0000b	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0000e	83 c1 58	 add	 ecx, 88			; 00000058H
  00011	83 ec 08	 sub	 esp, 8
  00014	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00019	ff d2		 call	 edx

; 91   : }

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?SetFieldOfView@CameraView@@UAEXN@Z ENDP		; CameraView::SetFieldOfView
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?UseScene@CameraView@@UAEXPAVScene@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?UseScene@CameraView@@UAEXPAVScene@@@Z PROC		; CameraView::UseScene, COMDAT
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   : 	if (s)

  00003	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN2@UseScene

; 82   : 	scene = s;

  0000a	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 85   : }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
$LN2@UseScene:

; 83   : 	else
; 84   : 	scene = &emergency_scene;

  00011	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], OFFSET _emergency_scene

; 85   : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?UseScene@CameraView@@UAEXPAVScene@@@Z ENDP		; CameraView::UseScene
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?UseCamera@CameraView@@UAEXPAVCamera@@@Z
_TEXT	SEGMENT
_cam$ = 8						; size = 4
?UseCamera@CameraView@@UAEXPAVCamera@@@Z PROC		; CameraView::UseCamera, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 70   : 	if (cam)

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _cam$[ebp]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 16		 je	 SHORT $LN2@UseCamera

; 71   : 	camera = cam;
; 72   : 	else
; 73   : 	camera = &emergency_cam;
; 74   : 
; 75   : 	projector.UseCamera(camera);

  0000c	8b 50 58	 mov	 edx, DWORD PTR [eax+88]
  0000f	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00015	8d 48 58	 lea	 ecx, DWORD PTR [eax+88]
  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001b	50		 push	 eax
  0001c	ff d2		 call	 edx

; 76   : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN2@UseCamera:

; 71   : 	camera = cam;
; 72   : 	else
; 73   : 	camera = &emergency_cam;
; 74   : 
; 75   : 	projector.UseCamera(camera);

  00022	8b 50 58	 mov	 edx, DWORD PTR [eax+88]
  00025	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00028	8d 48 58	 lea	 ecx, DWORD PTR [eax+88]
  0002b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _emergency_cam
  00032	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00035	50		 push	 eax
  00036	ff d2		 call	 edx

; 76   : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?UseCamera@CameraView@@UAEXPAVCamera@@@Z ENDP		; CameraView::UseCamera
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\solid.h
_TEXT	ENDS
;	COMDAT ?GetShadows@Solid@@QAEAAV?$List@VShadow@@@@XZ
_TEXT	SEGMENT
?GetShadows@Solid@@QAEAAV?$List@VShadow@@@@XZ PROC	; Solid::GetShadows, COMDAT
; _this$ = eax

; 74   : 	List<Shadow>&  GetShadows()         { return shadows;       }

  00000	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  00005	c3		 ret	 0
?GetShadows@Solid@@QAEAAV?$List@VShadow@@@@XZ ENDP	; Solid::GetShadows
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\graphic.h
_TEXT	ENDS
;	COMDAT ?Radius@Graphic@@QBEMXZ
_TEXT	SEGMENT
?Radius@Graphic@@QBEMXZ PROC				; Graphic::Radius, COMDAT
; _this$ = ecx

; 69   : 	float             Radius()       const { return radius;  }

  00000	d9 41 2c	 fld	 DWORD PTR [ecx+44]
  00003	c3		 ret	 0
?Radius@Graphic@@QBEMXZ ENDP				; Graphic::Radius
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?IsVisible@Graphic@@QBE_NXZ
_TEXT	SEGMENT
?IsVisible@Graphic@@QBE_NXZ PROC			; Graphic::IsVisible, COMDAT
; _this$ = eax

; 67   : 	bool              IsVisible()    const { return visible; }

  00000	8a 40 34	 mov	 al, BYTE PTR [eax+52]
  00003	c3		 ret	 0
?IsVisible@Graphic@@QBE_NXZ ENDP			; Graphic::IsVisible
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?TYPENAME@Graphic@@SAPBDXZ
_TEXT	SEGMENT
?TYPENAME@Graphic@@SAPBDXZ PROC				; Graphic::TYPENAME, COMDAT

; 38   : 	static const char* TYPENAME() { return "Graphic"; }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07PEMABHH@Graphic?$AA@
  00005	c3		 ret	 0
?TYPENAME@Graphic@@SAPBDXZ ENDP				; Graphic::TYPENAME
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\light.h
_TEXT	ENDS
;	COMDAT ?CastsShadow@Light@@QBE_NXZ
_TEXT	SEGMENT
?CastsShadow@Light@@QBE_NXZ PROC			; Light::CastsShadow, COMDAT
; _this$ = ecx

; 63   : 	bool              CastsShadow()     const { return shadow;  }

  00000	8a 41 39	 mov	 al, BYTE PTR [ecx+57]
  00003	c3		 ret	 0
?CastsShadow@Light@@QBE_NXZ ENDP			; Light::CastsShadow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetActive@Light@@QAEX_N@Z
_TEXT	SEGMENT
?SetActive@Light@@QAEX_N@Z PROC				; Light::SetActive, COMDAT
; _this$ = eax
; _a$ = ecx

; 62   : 	void              SetActive(bool a)       { active = a;     }

  00000	88 48 38	 mov	 BYTE PTR [eax+56], cl
  00003	c3		 ret	 0
?SetActive@Light@@QAEX_N@Z ENDP				; Light::SetActive
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?IsActive@Light@@QBE_NXZ
_TEXT	SEGMENT
?IsActive@Light@@QBE_NXZ PROC				; Light::IsActive, COMDAT
; _this$ = ecx

; 61   : 	bool              IsActive()        const { return active;  }

  00000	8a 41 38	 mov	 al, BYTE PTR [ecx+56]
  00003	c3		 ret	 0
?IsActive@Light@@QBE_NXZ ENDP				; Light::IsActive
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Intensity@Light@@QBEMXZ
_TEXT	SEGMENT
?Intensity@Light@@QBEMXZ PROC				; Light::Intensity, COMDAT
; _this$ = ecx

; 57   : 	float             Intensity()       const { return light;   }

  00000	d9 41 2c	 fld	 DWORD PTR [ecx+44]
  00003	c3		 ret	 0
?Intensity@Light@@QBEMXZ ENDP				; Light::Intensity
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Type@Light@@QBEKXZ
_TEXT	SEGMENT
?Type@Light@@QBEKXZ PROC				; Light::Type, COMDAT
; _this$ = ecx

; 55   : 	DWORD             Type()            const { return type;    }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?Type@Light@@QBEKXZ ENDP				; Light::Type
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\scene.h
_TEXT	ENDS
;	COMDAT ?Lights@Scene@@QAEAAV?$List@VLight@@@@XZ
_TEXT	SEGMENT
?Lights@Scene@@QAEAAV?$List@VLight@@@@XZ PROC		; Scene::Lights, COMDAT
; _this$ = eax

; 54   : 	List<Light>&      Lights()                   { return lights;     }

  00000	83 c0 34	 add	 eax, 52			; 00000034H
  00003	c3		 ret	 0
?Lights@Scene@@QAEAAV?$List@VLight@@@@XZ ENDP		; Scene::Lights
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Sprites@Scene@@QAEAAV?$List@VGraphic@@@@XZ
_TEXT	SEGMENT
?Sprites@Scene@@QAEAAV?$List@VGraphic@@@@XZ PROC	; Scene::Sprites, COMDAT
; _this$ = eax

; 53   : 	List<Graphic>&    Sprites()                  { return sprites;    }

  00000	83 c0 28	 add	 eax, 40			; 00000028H
  00003	c3		 ret	 0
?Sprites@Scene@@QAEAAV?$List@VGraphic@@@@XZ ENDP	; Scene::Sprites
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Graphics@Scene@@QAEAAV?$List@VGraphic@@@@XZ
_TEXT	SEGMENT
?Graphics@Scene@@QAEAAV?$List@VGraphic@@@@XZ PROC	; Scene::Graphics, COMDAT
; _this$ = eax

; 52   : 	List<Graphic>&    Graphics()                 { return graphics;   }

  00000	83 c0 1c	 add	 eax, 28			; 0000001cH
  00003	c3		 ret	 0
?Graphics@Scene@@QAEAAV?$List@VGraphic@@@@XZ ENDP	; Scene::Graphics
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Foreground@Scene@@QAEAAV?$List@VGraphic@@@@XZ
_TEXT	SEGMENT
?Foreground@Scene@@QAEAAV?$List@VGraphic@@@@XZ PROC	; Scene::Foreground, COMDAT
; _this$ = eax

; 51   : 	List<Graphic>&    Foreground()               { return foreground; }

  00000	83 c0 10	 add	 eax, 16			; 00000010H
  00003	c3		 ret	 0
?Foreground@Scene@@QAEAAV?$List@VGraphic@@@@XZ ENDP	; Scene::Foreground
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Background@Scene@@QAEAAV?$List@VGraphic@@@@XZ
_TEXT	SEGMENT
?Background@Scene@@QAEAAV?$List@VGraphic@@@@XZ PROC	; Scene::Background, COMDAT
; _this$ = eax

; 50   : 	List<Graphic>&    Background()               { return background; }

  00000	83 c0 04	 add	 eax, 4
  00003	c3		 ret	 0
?Background@Scene@@QAEAAV?$List@VGraphic@@@@XZ ENDP	; Scene::Background
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\video.h
_TEXT	ENDS
;	COMDAT ?GetInstance@Video@@SAPAV1@XZ
_TEXT	SEGMENT
?GetInstance@Video@@SAPAV1@XZ PROC			; Video::GetInstance, COMDAT

; 207  : 	static Video*        GetInstance()           { return video_instance; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?video_instance@Video@@1PAV1@A ; Video::video_instance
  00005	c3		 ret	 0
?GetInstance@Video@@SAPAV1@XZ ENDP			; Video::GetInstance
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\projector.h
_TEXT	ENDS
;	COMDAT ?SetOrthogonal@Projector@@QAEX_N@Z
_TEXT	SEGMENT
?SetOrthogonal@Projector@@QAEX_N@Z PROC			; Projector::SetOrthogonal, COMDAT
; _this$ = eax
; _o$ = ecx

; 52   : 	void           SetOrthogonal(bool o)   { orthogonal = o;    }

  00000	88 48 60	 mov	 BYTE PTR [eax+96], cl
  00003	c3		 ret	 0
?SetOrthogonal@Projector@@QAEX_N@Z ENDP			; Projector::SetOrthogonal
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\color.h
_TEXT	ENDS
;	COMDAT ??0Color@@QAE@ABV0@@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
??0Color@@QAE@ABV0@@Z PROC				; Color::Color, COMDAT
; _this$ = ecx

; 77   : 	Color(const Color& c) : rgba(c.rgba) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0Color@@QAE@ABV0@@Z ENDP				; Color::Color
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\window.h
_TEXT	ENDS
;	COMDAT ?Height@Window@@QBEHXZ
_TEXT	SEGMENT
?Height@Window@@QBEHXZ PROC				; Window::Height, COMDAT
; _this$ = ecx

; 50   : 	int               Height()             const { return rect.h;  }

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?Height@Window@@QBEHXZ ENDP				; Window::Height
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Width@Window@@QBEHXZ
_TEXT	SEGMENT
?Width@Window@@QBEHXZ PROC				; Window::Width, COMDAT
; _this$ = ecx

; 49   : 	int               Width()              const { return rect.w;  }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?Width@Window@@QBEHXZ ENDP				; Window::Width
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetRect@Window@@QBEABURect@@XZ
_TEXT	SEGMENT
?GetRect@Window@@QBEABURect@@XZ PROC			; Window::GetRect, COMDAT
; _this$ = ecx

; 46   : 	const Rect&       GetRect()            const { return rect;    }

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetRect@Window@@QBEABURect@@XZ ENDP			; Window::GetRect
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\geometry.h
_TEXT	ENDS
;	COMDAT ??DPoint@@QBENABU0@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??DPoint@@QBENABU0@@Z PROC				; Point::operator*, COMDAT
; _this$ = ecx

; 208  : 	double operator*(const Point& p) const { return (x*p.x + y*p.y + z*p.z);    }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	dd 40 08	 fld	 QWORD PTR [eax+8]
  00009	dc 49 08	 fmul	 QWORD PTR [ecx+8]
  0000c	dd 00		 fld	 QWORD PTR [eax]
  0000e	dc 09		 fmul	 QWORD PTR [ecx]
  00010	de c1		 faddp	 ST(1), ST(0)
  00012	dd 40 10	 fld	 QWORD PTR [eax+16]
  00015	dc 49 10	 fmul	 QWORD PTR [ecx+16]
  00018	de c1		 faddp	 ST(1), ST(0)
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??DPoint@@QBENABU0@@Z ENDP				; Point::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??4Vec3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??4Vec3@@QAEAAU0@ABU0@@Z PROC				; Vec3::operator=, COMDAT
; _this$ = ecx

; 166  : 	Vec3&  operator= (const Vec3& p)  { x =p.x; y =p.y; z =p.z; return *this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00008	d9 01		 fld	 DWORD PTR [ecx]
  0000a	d9 18		 fstp	 DWORD PTR [eax]
  0000c	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000f	d9 58 04	 fstp	 DWORD PTR [eax+4]
  00012	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00015	d9 58 08	 fstp	 DWORD PTR [eax+8]
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??4Vec3@@QAEAAU0@ABU0@@Z ENDP				; Vec3::operator=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??DVec3@@QBEMABU0@@Z
_TEXT	SEGMENT
tv156 = 8						; size = 4
_p$ = 8							; size = 4
??DVec3@@QBEMABU0@@Z PROC				; Vec3::operator*, COMDAT
; _this$ = ecx

; 163  : 	float  operator* (const Vec3& p)  const { return (x*p.x + y*p.y + z*p.z);    }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00006	d9 40 04	 fld	 DWORD PTR [eax+4]
  00009	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0000c	d9 00		 fld	 DWORD PTR [eax]
  0000e	d8 09		 fmul	 DWORD PTR [ecx]
  00010	de c1		 faddp	 ST(1), ST(0)
  00012	d9 40 08	 fld	 DWORD PTR [eax+8]
  00015	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00018	de c1		 faddp	 ST(1), ST(0)
  0001a	d9 5d 08	 fstp	 DWORD PTR tv156[ebp]
  0001d	d9 45 08	 fld	 DWORD PTR tv156[ebp]
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??DVec3@@QBEMABU0@@Z ENDP				; Vec3::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0Vec3@@QAE@XZ
_TEXT	SEGMENT
??0Vec3@@QAE@XZ PROC					; Vec3::Vec3, COMDAT
; _this$ = ecx

; 150  : 	Vec3() { }

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0Vec3@@QAE@XZ ENDP					; Vec3::Vec3
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0Rect@@QAE@XZ
_TEXT	SEGMENT
??0Rect@@QAE@XZ PROC					; Rect::Rect, COMDAT
; _this$ = ecx

; 39   : 	Rect()                                 : x(0),  y(0),  w(0),  h(0)  { }

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0000f	c3		 ret	 0
??0Rect@@QAE@XZ ENDP					; Rect::Rect
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\view.h
_TEXT	ENDS
;	COMDAT ?GetWindow@View@@UAEPAVWindow@@XZ
_TEXT	SEGMENT
?GetWindow@View@@UAEPAVWindow@@XZ PROC			; View::GetWindow, COMDAT
; _this$ = ecx

; 45   : 	virtual Window*   GetWindow()             { return window; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetWindow@View@@UAEPAVWindow@@XZ ENDP			; View::GetWindow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetWindow@View@@UAEXPAVWindow@@@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
?SetWindow@View@@UAEXPAVWindow@@@Z PROC			; View::SetWindow, COMDAT
; _this$ = ecx

; 44   : 	virtual void      SetWindow(Window* w)    { window = w; OnWindowMove(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _w$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0000e	ff d0		 call	 eax
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?SetWindow@View@@UAEXPAVWindow@@@Z ENDP			; View::SetWindow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?OnHide@View@@UAEXXZ
_TEXT	SEGMENT
?OnHide@View@@UAEXXZ PROC				; View::OnHide, COMDAT
; _this$ = ecx

; 42   : 	virtual void      OnHide()                { }

  00000	c3		 ret	 0
?OnHide@View@@UAEXXZ ENDP				; View::OnHide
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?OnShow@View@@UAEXXZ
_TEXT	SEGMENT
?OnShow@View@@UAEXXZ PROC				; View::OnShow, COMDAT
; _this$ = ecx

; 41   : 	virtual void      OnShow()                { }

  00000	c3		 ret	 0
?OnShow@View@@UAEXXZ ENDP				; View::OnShow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?OnWindowMove@View@@UAEXXZ
_TEXT	SEGMENT
?OnWindowMove@View@@UAEXXZ PROC				; View::OnWindowMove, COMDAT
; _this$ = ecx

; 40   : 	virtual void      OnWindowMove()          { }

  00000	c3		 ret	 0
?OnWindowMove@View@@UAEXXZ ENDP				; View::OnWindowMove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Refresh@View@@UAEXXZ
_TEXT	SEGMENT
?Refresh@View@@UAEXXZ PROC				; View::Refresh, COMDAT
; _this$ = ecx

; 39   : 	virtual void      Refresh()               { }

  00000	c3		 ret	 0
?Refresh@View@@UAEXXZ ENDP				; View::Refresh
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1View@@UAE@XZ
_TEXT	SEGMENT
??1View@@UAE@XZ PROC					; View::~View, COMDAT
; _this$ = ecx

; 34   : 	virtual ~View()                           { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7View@@6B@
  00006	c3		 ret	 0
??1View@@UAE@XZ ENDP					; View::~View
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0View@@QAE@PAVWindow@@@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
??0View@@QAE@PAVWindow@@@Z PROC				; View::View, COMDAT
; _this$ = ecx

; 33   : 	View(Window* c) : window(c)               { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7View@@6B@
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0View@@QAE@PAVWindow@@@Z ENDP				; View::View
; Function compile flags: /Ogtp
; File c:\matrix games\dev\foundationex\list.inl
;	COMDAT ?check@?$List@VGraphic@@@@ABE_NAAH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?check@?$List@VGraphic@@@@ABE_NAAH@Z PROC		; List<Graphic>::check, COMDAT
; _this$ = ecx

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 65   :    if (index < 0) {

  00005	8b 7d 08	 mov	 edi, DWORD PTR _index$[ebp]
  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	8b f1		 mov	 esi, ecx
  0000c	85 c0		 test	 eax, eax
  0000e	79 1c		 jns	 SHORT $LN3@check@6

; 66   :       Print("Bounds error in List(%08x) T=%s index=%d min=0\n", (int)this, T::TYPENAME(), index);

  00010	50		 push	 eax
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_07PEMABHH@Graphic?$AA@
  00016	56		 push	 esi
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HIKLCBIP@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  0001c	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 67   :       index = 0;

  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0002a	eb 26		 jmp	 SHORT $LN12@check@6
$LN3@check@6:

; 68   :    }
; 69   : 
; 70   :    else if (index >= items) {

  0002c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002e	3b c1		 cmp	 eax, ecx
  00030	7c 1b		 jl	 SHORT $LN1@check@6

; 71   :       Print("Bounds error in List(%08x) T=%s index=%d max=%d\n", (int)this, T::TYPENAME(), index, items-1);

  00032	49		 dec	 ecx
  00033	51		 push	 ecx
  00034	50		 push	 eax
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_07PEMABHH@Graphic?$AA@
  0003a	56		 push	 esi
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@EEHODDHM@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00040	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 72   :       index = items-1;

  00045	8b 06		 mov	 eax, DWORD PTR [esi]
  00047	83 c4 14	 add	 esp, 20			; 00000014H
  0004a	48		 dec	 eax
  0004b	89 07		 mov	 DWORD PTR [edi], eax
$LN1@check@6:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  0004d	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00050	7c 11		 jl	 SHORT $LN6@check@6
$LN12@check@6:
  00052	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00054	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00056	7d 0b		 jge	 SHORT $LN6@check@6
  00058	5f		 pop	 edi
  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	5e		 pop	 esi

; 76   : }

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN6@check@6:
  00063	5f		 pop	 edi

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00064	33 c0		 xor	 eax, eax
  00066	5e		 pop	 esi

; 76   : }

  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?check@?$List@VGraphic@@@@ABE_NAAH@Z ENDP		; List<Graphic>::check
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$List@VGraphic@@@@QBEPAVGraphic@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
??A?$List@VGraphic@@@@QBEPAVGraphic@@H@Z PROC		; List<Graphic>::operator[], COMDAT
; _this$ = esi

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   :    if (check(index))

  00003	8d 45 08	 lea	 eax, DWORD PTR _index$[ebp]
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?check@?$List@VGraphic@@@@ABE_NAAH@Z ; List<Graphic>::check
  0000e	84 c0		 test	 al, al
  00010	74 0d		 je	 SHORT $LN1@operator@2

; 96   :       return array[index];

  00012	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00015	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  00018	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]

; 98   : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
$LN1@operator@2:

; 97   :    return 0;

  0001f	33 c0		 xor	 eax, eax

; 98   : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??A?$List@VGraphic@@@@QBEPAVGraphic@@H@Z ENDP		; List<Graphic>::operator[]
; Function compile flags: /Ogtp
; File c:\matrix games\dev\foundationex\list.h
_TEXT	ENDS
;	COMDAT ?last@?$List@VGraphic@@@@QBEPAVGraphic@@XZ
_TEXT	SEGMENT
?last@?$List@VGraphic@@@@QBEPAVGraphic@@XZ PROC		; List<Graphic>::last, COMDAT
; _this$ = eax

; 43   :    T*       last()    const      { return operator[](items-1); }

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	48		 dec	 eax
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??A?$List@VGraphic@@@@QBEPAVGraphic@@H@Z ; List<Graphic>::operator[]
  0000c	5e		 pop	 esi
  0000d	c3		 ret	 0
?last@?$List@VGraphic@@@@QBEPAVGraphic@@XZ ENDP		; List<Graphic>::last
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\cameraview.cpp
_TEXT	ENDS
;	COMDAT ?Render@CameraView@@UAEXPAVGraphic@@K@Z
_TEXT	SEGMENT
_g$ = 8							; size = 4
_flags$ = 12						; size = 4
?Render@CameraView@@UAEXPAVGraphic@@K@Z PROC		; CameraView::Render, COMDAT
; _this$ = ecx

; 677  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 678  : 	if (g && g->IsVisible() && !g->Hidden()) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _g$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	74 52		 je	 SHORT $LN2@Render
  0000e	80 7e 34 00	 cmp	 BYTE PTR [esi+52], 0
  00012	74 4c		 je	 SHORT $LN2@Render
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  00019	8b ce		 mov	 ecx, esi
  0001b	ff d2		 call	 edx
  0001d	85 c0		 test	 eax, eax
  0001f	75 3f		 jne	 SHORT $LN2@Render

; 679  : 		if (g->IsSolid()) {

  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  00026	53		 push	 ebx
  00027	8b ce		 mov	 ecx, esi
  00029	ff d2		 call	 edx
  0002b	8b 5d 0c	 mov	 ebx, DWORD PTR _flags$[ebp]
  0002e	84 c0		 test	 al, al
  00030	74 1f		 je	 SHORT $LN1@Render

; 680  : 			MarkVisibleLights(g, flags);

  00032	8b 07		 mov	 eax, DWORD PTR [edi]
  00034	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]
  00037	53		 push	 ebx
  00038	56		 push	 esi
  00039	8b cf		 mov	 ecx, edi
  0003b	ff d2		 call	 edx

; 681  : 			video->SetLights(scene->Lights());

  0003d	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00040	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [eax+164]
  0004b	83 c2 34	 add	 edx, 52			; 00000034H
  0004e	52		 push	 edx
  0004f	ff d0		 call	 eax
$LN1@Render:

; 682  : 		}
; 683  : 
; 684  : 		g->Render(video, flags);

  00051	8b 16		 mov	 edx, DWORD PTR [esi]
  00053	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00056	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00059	53		 push	 ebx
  0005a	50		 push	 eax
  0005b	8b ce		 mov	 ecx, esi
  0005d	ff d2		 call	 edx
  0005f	5b		 pop	 ebx
$LN2@Render:
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 685  : 	}
; 686  : }

  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
?Render@CameraView@@UAEXPAVGraphic@@K@Z ENDP		; CameraView::Render
_TEXT	ENDS
PUBLIC	__real@4a989680
;	COMDAT __real@4a989680
; File c:\matrix games\dev\foundationex\list.h
CONST	SEGMENT
__real@4a989680 DD 04a989680r			; 5e+006
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\cameraview.cpp
CONST	ENDS
;	COMDAT ?RenderScene@CameraView@@UAEXXZ
_TEXT	SEGMENT
_iter$ = -8						; size = 8
?RenderScene@CameraView@@UAEXXZ PROC			; CameraView::RenderScene, COMDAT
; _this$ = ecx

; 535  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b d9		 mov	 ebx, ecx

; 536  : 	if (graphics.isEmpty()) return;

  0000d	83 bb 80 01 00
	00 00		 cmp	 DWORD PTR [ebx+384], 0
  00014	8d b3 80 01 00
	00		 lea	 esi, DWORD PTR [ebx+384]
  0001a	57		 push	 edi
  0001b	0f 84 e6 00 00
	00		 je	 $LN8@RenderScen

; 537  : 
; 538  : 	int   i         = 0;
; 539  : 	int   ngraphics = graphics.size();
; 540  : 
; 541  : 	// compute depth:
; 542  : 	ListIter<Graphic> iter = graphics;
; 543  : 	while (++iter) {

  00021	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  00025	89 74 24 10	 mov	 DWORD PTR _iter$[esp+24], esi
  00029	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+28], -1
  00031	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00036	85 c0		 test	 eax, eax
  00038	0f 84 82 00 00
	00		 je	 $LN5@RenderScen
  0003e	8b ff		 npad	 2
$LL6@RenderScen:

; 544  : 		Graphic* g = iter.value();

  00040	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  00044	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  00049	8b f8		 mov	 edi, eax

; 545  : 		if (g && !g->Hidden()) {

  0004b	85 ff		 test	 edi, edi
  0004d	74 64		 je	 SHORT $LN2@RenderScen
  0004f	8b 07		 mov	 eax, DWORD PTR [edi]
  00051	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  00054	8b cf		 mov	 ecx, edi
  00056	ff d2		 call	 edx
  00058	85 c0		 test	 eax, eax
  0005a	75 57		 jne	 SHORT $LN2@RenderScen

; 546  : 			FindDepth(g);

  0005c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0005e	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  00061	57		 push	 edi
  00062	8b cb		 mov	 ecx, ebx
  00064	ff d2		 call	 edx

; 547  : 
; 548  : 			if (g->IsSolid()) {

  00066	8b 07		 mov	 eax, DWORD PTR [edi]
  00068	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  0006b	8b cf		 mov	 ecx, edi
  0006d	ff d2		 call	 edx
  0006f	84 c0		 test	 al, al
  00071	74 40		 je	 SHORT $LN2@RenderScen

; 549  : 				Solid* solid = (Solid*) g;
; 550  : 
; 551  : 				solid->SelectDetail(&projector);

  00073	8b 07		 mov	 eax, DWORD PTR [edi]
  00075	8b 90 88 00 00
	00		 mov	 edx, DWORD PTR [eax+136]
  0007b	8d 4b 58	 lea	 ecx, DWORD PTR [ebx+88]
  0007e	51		 push	 ecx
  0007f	8b cf		 mov	 ecx, edi
  00081	ff d2		 call	 edx

; 552  : 
; 553  : 				if (video->IsShadowEnabled()) {

  00083	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00086	8b 01		 mov	 eax, DWORD PTR [ecx]
  00088	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  0008b	ff d2		 call	 edx
  0008d	84 c0		 test	 al, al
  0008f	74 22		 je	 SHORT $LN2@RenderScen

; 554  : 					MarkVisibleLights(solid, Graphic::RENDER_ADD_LIGHT);

  00091	8b 03		 mov	 eax, DWORD PTR [ebx]
  00093	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]
  00096	68 00 20 00 00	 push	 8192			; 00002000H
  0009b	57		 push	 edi
  0009c	8b cb		 mov	 ecx, ebx
  0009e	ff d2		 call	 edx

; 555  : 					solid->UpdateShadows(scene->Lights());

  000a0	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  000a3	8b 07		 mov	 eax, DWORD PTR [edi]
  000a5	8b 90 9c 00 00
	00		 mov	 edx, DWORD PTR [eax+156]
  000ab	83 c1 34	 add	 ecx, 52			; 00000034H
  000ae	51		 push	 ecx
  000af	8b cf		 mov	 ecx, edi
  000b1	ff d2		 call	 edx
$LN2@RenderScen:

; 537  : 
; 538  : 	int   i         = 0;
; 539  : 	int   ngraphics = graphics.size();
; 540  : 
; 541  : 	// compute depth:
; 542  : 	ListIter<Graphic> iter = graphics;
; 543  : 	while (++iter) {

  000b3	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  000b7	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  000bc	85 c0		 test	 eax, eax
  000be	75 80		 jne	 SHORT $LL6@RenderScen
$LN5@RenderScen:

; 556  : 				}
; 557  : 			}
; 558  : 		}
; 559  : 	}
; 560  : 
; 561  : 	// sort the list:
; 562  : 	graphics.sort();

  000c0	8b ce		 mov	 ecx, esi
  000c2	e8 00 00 00 00	 call	 ?sort@?$List@VGraphic@@@@QAEXXZ ; List<Graphic>::sort

; 563  : 
; 564  : 	Graphic* g = graphics.last();

  000c7	8b 06		 mov	 eax, DWORD PTR [esi]
  000c9	48		 dec	 eax
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ??A?$List@VGraphic@@@@QBEPAVGraphic@@H@Z ; List<Graphic>::operator[]

; 565  : 	if (g->Depth() > 5e6) {

  000d0	8b 10		 mov	 edx, DWORD PTR [eax]
  000d2	8b c8		 mov	 ecx, eax
  000d4	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000d7	ff d0		 call	 eax
  000d9	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4a989680
  000df	d9 c9		 fxch	 ST(1)
  000e1	df f1		 fcomip	 ST(1)
  000e3	dd d8		 fstp	 ST(0)
  000e5	76 15		 jbe	 SHORT $LN1@RenderScen

; 566  : 		RenderSceneObjects(true);

  000e7	8b 13		 mov	 edx, DWORD PTR [ebx]
  000e9	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  000ec	6a 01		 push	 1
  000ee	8b cb		 mov	 ecx, ebx
  000f0	ff d0		 call	 eax

; 567  : 		video->ClearDepthBuffer();

  000f2	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  000f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f7	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000fa	ff d0		 call	 eax
$LN1@RenderScen:

; 568  : 	}
; 569  : 
; 570  : 	RenderSceneObjects(false);

  000fc	8b 13		 mov	 edx, DWORD PTR [ebx]
  000fe	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00101	6a 00		 push	 0
  00103	8b cb		 mov	 ecx, ebx
  00105	ff d0		 call	 eax
$LN8@RenderScen:

; 571  : }

  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
?RenderScene@CameraView@@UAEXXZ ENDP			; CameraView::RenderScene
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?RenderSprites@CameraView@@UAEXXZ
_TEXT	SEGMENT
_iter$ = -8						; size = 8
?RenderSprites@CameraView@@UAEXXZ PROC			; CameraView::RenderSprites, COMDAT
; _this$ = ecx

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 494  : 	if (scene->Sprites().isEmpty()) return;

  0000c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000f	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00013	57		 push	 edi
  00014	0f 84 28 01 00
	00		 je	 $LN1@RenderSpri

; 495  : 
; 496  : 	video->SetRenderState(Video::FILL_MODE,         Video::FILL_SOLID);

  0001a	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00025	6a 03		 push	 3
  00027	6a 00		 push	 0
  00029	ff d0		 call	 eax

; 497  : 	video->SetRenderState(Video::Z_ENABLE,          TRUE);

  0002b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00036	6a 01		 push	 1
  00038	6a 03		 push	 3
  0003a	ff d0		 call	 eax

; 498  : 	video->SetRenderState(Video::Z_WRITE_ENABLE,    FALSE);

  0003c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0003f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00041	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00047	6a 00		 push	 0
  00049	6a 04		 push	 4
  0004b	ff d0		 call	 eax

; 499  : 	video->SetRenderState(Video::STENCIL_ENABLE,    FALSE);

  0004d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00050	8b 11		 mov	 edx, DWORD PTR [ecx]
  00052	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00058	6a 00		 push	 0
  0005a	6a 0c		 push	 12			; 0000000cH
  0005c	ff d0		 call	 eax

; 500  : 	video->SetRenderState(Video::LIGHTING_ENABLE,   TRUE);

  0005e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00069	6a 01		 push	 1
  0006b	6a 02		 push	 2
  0006d	ff d0		 call	 eax

; 501  : 
; 502  : 	// compute depth:
; 503  : 	ListIter<Graphic> iter = scene->Sprites();

  0006f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00072	83 c1 28	 add	 ecx, 40			; 00000028H
  00075	89 4c 24 08	 mov	 DWORD PTR _iter$[esp+16], ecx

; 504  : 	while (++iter) {

  00079	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  0007d	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+20], -1
  00085	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0008a	85 c0		 test	 eax, eax
  0008c	74 3b		 je	 SHORT $LN6@RenderSpri
  0008e	8b ff		 npad	 2
$LL7@RenderSpri:

; 505  : 		Graphic* g = iter.value();

  00090	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  00094	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  00099	8b f8		 mov	 edi, eax

; 506  : 		if (g && g->IsVisible() && !g->Hidden()) {

  0009b	85 ff		 test	 edi, edi
  0009d	74 1d		 je	 SHORT $LN5@RenderSpri
  0009f	80 7f 34 00	 cmp	 BYTE PTR [edi+52], 0
  000a3	74 17		 je	 SHORT $LN5@RenderSpri
  000a5	8b 17		 mov	 edx, DWORD PTR [edi]
  000a7	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000aa	8b cf		 mov	 ecx, edi
  000ac	ff d0		 call	 eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 0a		 jne	 SHORT $LN5@RenderSpri

; 507  : 			FindDepth(g);

  000b2	8b 16		 mov	 edx, DWORD PTR [esi]
  000b4	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  000b7	57		 push	 edi
  000b8	8b ce		 mov	 ecx, esi
  000ba	ff d0		 call	 eax
$LN5@RenderSpri:

; 504  : 	while (++iter) {

  000bc	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  000c0	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  000c5	85 c0		 test	 eax, eax
  000c7	75 c7		 jne	 SHORT $LL7@RenderSpri
$LN6@RenderSpri:

; 508  : 		}
; 509  : 	}
; 510  : 
; 511  : 	// sort the list:
; 512  : 	scene->Sprites().sort();

  000c9	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000cc	83 c1 28	 add	 ecx, 40			; 00000028H
  000cf	e8 00 00 00 00	 call	 ?sort@?$List@VGraphic@@@@QAEXXZ ; List<Graphic>::sort

; 513  : 
; 514  : 	// blended items:
; 515  : 	iter.reset();
; 516  : 	while (++iter) {

  000d4	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  000d8	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+20], -1
  000e0	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  000e5	85 c0		 test	 eax, eax
  000e7	74 22		 je	 SHORT $LN3@RenderSpri
$LN4@RenderSpri:

; 517  : 		Graphic* g = iter.value();
; 518  : 		Render(g, Graphic::RENDER_ALPHA);

  000e9	8b 3e		 mov	 edi, DWORD PTR [esi]
  000eb	6a 02		 push	 2
  000ed	8d 4c 24 0c	 lea	 ecx, DWORD PTR _iter$[esp+20]
  000f1	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  000f6	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  000f9	50		 push	 eax
  000fa	8b ce		 mov	 ecx, esi
  000fc	ff d2		 call	 edx
  000fe	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  00102	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00107	85 c0		 test	 eax, eax
  00109	75 de		 jne	 SHORT $LN4@RenderSpri
$LN3@RenderSpri:

; 519  : 	}
; 520  : 
; 521  : 	// glowing items:
; 522  : 	iter.reset();
; 523  : 	while (++iter) {

  0010b	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  0010f	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+20], -1
  00117	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0011c	85 c0		 test	 eax, eax
  0011e	74 22		 je	 SHORT $LN1@RenderSpri
$LL2@RenderSpri:

; 524  : 		Graphic* g = iter.value();
; 525  : 		Render(g, Graphic::RENDER_ADDITIVE);

  00120	8b 3e		 mov	 edi, DWORD PTR [esi]
  00122	6a 04		 push	 4
  00124	8d 4c 24 0c	 lea	 ecx, DWORD PTR _iter$[esp+20]
  00128	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  0012d	50		 push	 eax
  0012e	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  00131	8b ce		 mov	 ecx, esi
  00133	ff d0		 call	 eax
  00135	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  00139	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0013e	85 c0		 test	 eax, eax
  00140	75 de		 jne	 SHORT $LL2@RenderSpri
$LN1@RenderSpri:

; 526  : 	}
; 527  : }

  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c3		 ret	 0
?RenderSprites@CameraView@@UAEXXZ ENDP			; CameraView::RenderSprites
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?RenderBackground@CameraView@@UAEXXZ
_TEXT	SEGMENT
_iter$ = -8						; size = 8
?RenderBackground@CameraView@@UAEXXZ PROC		; CameraView::RenderBackground, COMDAT
; _this$ = ecx

; 377  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 378  : 	if (scene->Background().isEmpty()) return;

  0000c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00013	57		 push	 edi
  00014	0f 84 37 01 00
	00		 je	 $LN2@RenderBack

; 379  : 
; 380  : 	video->SetRenderState(Video::FILL_MODE,         Video::FILL_SOLID);

  0001a	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00025	6a 03		 push	 3
  00027	6a 00		 push	 0
  00029	ff d0		 call	 eax

; 381  : 	video->SetRenderState(Video::Z_ENABLE,          FALSE);

  0002b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00036	6a 00		 push	 0
  00038	6a 03		 push	 3
  0003a	ff d0		 call	 eax

; 382  : 	video->SetRenderState(Video::Z_WRITE_ENABLE,    FALSE);

  0003c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0003f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00041	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00047	6a 00		 push	 0
  00049	6a 04		 push	 4
  0004b	ff d0		 call	 eax

; 383  : 	video->SetRenderState(Video::STENCIL_ENABLE,    FALSE);

  0004d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00050	8b 11		 mov	 edx, DWORD PTR [ecx]
  00052	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00058	6a 00		 push	 0
  0005a	6a 0c		 push	 12			; 0000000cH
  0005c	ff d0		 call	 eax

; 384  : 	video->SetRenderState(Video::LIGHTING_ENABLE,   TRUE);

  0005e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00069	6a 01		 push	 1
  0006b	6a 02		 push	 2
  0006d	ff d0		 call	 eax

; 385  : 
; 386  : 	// solid items:
; 387  : 	ListIter<Graphic> iter = scene->Background();

  0006f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00072	83 c1 04	 add	 ecx, 4
  00075	89 4c 24 08	 mov	 DWORD PTR _iter$[esp+16], ecx

; 388  : 	while (++iter) {

  00079	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  0007d	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+20], -1
  00085	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0008a	85 c0		 test	 eax, eax
  0008c	74 33		 je	 SHORT $LN8@RenderBack
  0008e	8b ff		 npad	 2
$LL9@RenderBack:

; 389  : 		Graphic* g = iter.value();

  00090	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  00094	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  00099	8b f8		 mov	 edi, eax

; 390  : 
; 391  : 		if (!g->Hidden())

  0009b	8b 17		 mov	 edx, DWORD PTR [edi]
  0009d	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000a0	8b cf		 mov	 ecx, edi
  000a2	ff d0		 call	 eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 0c		 jne	 SHORT $LN7@RenderBack

; 392  : 		Render(g, Graphic::RENDER_SOLID);

  000a8	8b 16		 mov	 edx, DWORD PTR [esi]
  000aa	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  000ad	6a 01		 push	 1
  000af	57		 push	 edi
  000b0	8b ce		 mov	 ecx, esi
  000b2	ff d0		 call	 eax
$LN7@RenderBack:

; 388  : 	while (++iter) {

  000b4	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  000b8	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  000bd	85 c0		 test	 eax, eax
  000bf	75 cf		 jne	 SHORT $LL9@RenderBack
$LN8@RenderBack:

; 393  : 	}
; 394  : 
; 395  : 	// blended items:
; 396  : 	iter.reset();
; 397  : 	while (++iter) {

  000c1	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  000c5	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+20], -1
  000cd	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  000d2	85 c0		 test	 eax, eax
  000d4	74 31		 je	 SHORT $LN5@RenderBack
$LL6@RenderBack:

; 398  : 		Graphic* g = iter.value();

  000d6	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  000da	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  000df	8b f8		 mov	 edi, eax

; 399  : 
; 400  : 		if (!g->Hidden())

  000e1	8b 17		 mov	 edx, DWORD PTR [edi]
  000e3	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000e6	8b cf		 mov	 ecx, edi
  000e8	ff d0		 call	 eax
  000ea	85 c0		 test	 eax, eax
  000ec	75 0c		 jne	 SHORT $LN4@RenderBack

; 401  : 		Render(g, Graphic::RENDER_ALPHA);

  000ee	8b 16		 mov	 edx, DWORD PTR [esi]
  000f0	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  000f3	6a 02		 push	 2
  000f5	57		 push	 edi
  000f6	8b ce		 mov	 ecx, esi
  000f8	ff d0		 call	 eax
$LN4@RenderBack:

; 393  : 	}
; 394  : 
; 395  : 	// blended items:
; 396  : 	iter.reset();
; 397  : 	while (++iter) {

  000fa	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  000fe	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00103	85 c0		 test	 eax, eax
  00105	75 cf		 jne	 SHORT $LL6@RenderBack
$LN5@RenderBack:

; 402  : 	}
; 403  : 
; 404  : 	// glowing items:
; 405  : 	iter.reset();
; 406  : 	while (++iter) {

  00107	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  0010b	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+20], -1
  00113	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00118	85 c0		 test	 eax, eax
  0011a	74 35		 je	 SHORT $LN2@RenderBack
  0011c	8d 64 24 00	 npad	 4
$LL3@RenderBack:

; 407  : 		Graphic* g = iter.value();

  00120	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  00124	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  00129	8b f8		 mov	 edi, eax

; 408  : 
; 409  : 		if (!g->Hidden())

  0012b	8b 17		 mov	 edx, DWORD PTR [edi]
  0012d	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00130	8b cf		 mov	 ecx, edi
  00132	ff d0		 call	 eax
  00134	85 c0		 test	 eax, eax
  00136	75 0c		 jne	 SHORT $LN1@RenderBack

; 410  : 		Render(g, Graphic::RENDER_ADDITIVE);

  00138	8b 16		 mov	 edx, DWORD PTR [esi]
  0013a	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  0013d	6a 04		 push	 4
  0013f	57		 push	 edi
  00140	8b ce		 mov	 ecx, esi
  00142	ff d0		 call	 eax
$LN1@RenderBack:

; 402  : 	}
; 403  : 
; 404  : 	// glowing items:
; 405  : 	iter.reset();
; 406  : 	while (++iter) {

  00144	8d 4c 24 08	 lea	 ecx, DWORD PTR _iter$[esp+16]
  00148	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0014d	85 c0		 test	 eax, eax
  0014f	75 cf		 jne	 SHORT $LL3@RenderBack
$LN2@RenderBack:

; 411  : 	}
; 412  : }

  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c3		 ret	 0
?RenderBackground@CameraView@@UAEXXZ ENDP		; CameraView::RenderBackground
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?MarkVisibleObjects@CameraView@@UAEXXZ
_TEXT	SEGMENT
_graphic_iter$ = -8					; size = 8
?MarkVisibleObjects@CameraView@@UAEXXZ PROC		; CameraView::MarkVisibleObjects, COMDAT
; _this$ = ecx

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 311  : 	projector.StartFrame();

  0000e	8b 47 58	 mov	 eax, DWORD PTR [edi+88]
  00011	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00014	8d 5f 58	 lea	 ebx, DWORD PTR [edi+88]
  00017	8b cb		 mov	 ecx, ebx
  00019	ff d2		 call	 edx

; 312  : 	graphics.clear();

  0001b	8d b7 80 01 00
	00		 lea	 esi, DWORD PTR [edi+384]
  00021	e8 00 00 00 00	 call	 ?clear@?$List@VGraphic@@@@QAEXXZ ; List<Graphic>::clear

; 313  : 
; 314  : 	ListIter<Graphic> graphic_iter = scene->Graphics();

  00026	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00029	83 c0 1c	 add	 eax, 28			; 0000001cH

; 315  : 	while (++graphic_iter) {

  0002c	8d 4c 24 10	 lea	 ecx, DWORD PTR _graphic_iter$[esp+24]
  00030	89 44 24 10	 mov	 DWORD PTR _graphic_iter$[esp+24], eax
  00034	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _graphic_iter$[esp+28], -1
  0003c	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00041	85 c0		 test	 eax, eax
  00043	74 50		 je	 SHORT $LN4@MarkVisibl
$LL5@MarkVisibl:

; 316  : 		Graphic* graphic = graphic_iter.value();

  00045	8d 4c 24 10	 lea	 ecx, DWORD PTR _graphic_iter$[esp+24]
  00049	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  0004e	8b f8		 mov	 edi, eax

; 317  : 
; 318  : 		if (graphic->Hidden())

  00050	8b 17		 mov	 edx, DWORD PTR [edi]
  00052	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00055	8b cf		 mov	 ecx, edi
  00057	ff d0		 call	 eax
  00059	85 c0		 test	 eax, eax
  0005b	75 2b		 jne	 SHORT $LN1@MarkVisibl

; 319  : 		continue;
; 320  : 		
; 321  : 		if (graphic->CheckVisibility(projector)) {

  0005d	8b 17		 mov	 edx, DWORD PTR [edi]
  0005f	8b 82 84 00 00
	00		 mov	 eax, DWORD PTR [edx+132]
  00065	53		 push	 ebx
  00066	8b cf		 mov	 ecx, edi
  00068	ff d0		 call	 eax

; 322  : 			graphic->Update();

  0006a	8b 17		 mov	 edx, DWORD PTR [edi]
  0006c	8b cf		 mov	 ecx, edi
  0006e	84 c0		 test	 al, al
  00070	74 0f		 je	 SHORT $LN2@MarkVisibl
  00072	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00075	ff d0		 call	 eax

; 323  : 			graphics.append(graphic);

  00077	57		 push	 edi
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?append@?$List@VGraphic@@@@QAEXPBVGraphic@@@Z ; List<Graphic>::append

; 324  : 		}
; 325  : 		else {

  0007f	eb 07		 jmp	 SHORT $LN1@MarkVisibl
$LN2@MarkVisibl:

; 326  : 			graphic->ProjectScreenRect(0);

  00081	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  00084	6a 00		 push	 0
  00086	ff d0		 call	 eax
$LN1@MarkVisibl:

; 315  : 	while (++graphic_iter) {

  00088	8d 4c 24 10	 lea	 ecx, DWORD PTR _graphic_iter$[esp+24]
  0008c	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00091	85 c0		 test	 eax, eax
  00093	75 b0		 jne	 SHORT $LL5@MarkVisibl
$LN4@MarkVisibl:

; 327  : 		}
; 328  : 	}
; 329  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?MarkVisibleObjects@CameraView@@UAEXXZ ENDP		; CameraView::MarkVisibleObjects
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?OnWindowMove@CameraView@@UAEXXZ
_TEXT	SEGMENT
_r$ = -16						; size = 16
?OnWindowMove@CameraView@@UAEXXZ PROC			; CameraView::OnWindowMove, COMDAT
; _this$ = ecx

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 115  : 	Rect r = window->GetRect();

  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	f3 0f 7e 40 04	 movq	 xmm0, QWORD PTR [eax+4]

; 116  : 	projector.UseWindow(window);

  00011	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  00014	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  00017	66 0f d6 45 f0	 movq	 QWORD PTR _r$[ebp], xmm0
  0001c	f3 0f 7e 40 0c	 movq	 xmm0, QWORD PTR [eax+12]
  00021	50		 push	 eax
  00022	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00025	66 0f d6 45 f8	 movq	 QWORD PTR _r$[ebp+8], xmm0
  0002a	ff d0		 call	 eax

; 117  : 
; 118  : 	width  = r.w;

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _r$[ebp+8]

; 119  : 	height = r.h;

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp+12]
  00032	89 8e 54 01 00
	00		 mov	 DWORD PTR [esi+340], ecx
  00038	89 96 58 01 00
	00		 mov	 DWORD PTR [esi+344], edx
  0003e	5e		 pop	 esi

; 120  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?OnWindowMove@CameraView@@UAEXXZ ENDP			; CameraView::OnWindowMove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetProjectionType@CameraView@@UAEXK@Z
_TEXT	SEGMENT
_pt$ = 8						; size = 4
?SetProjectionType@CameraView@@UAEXK@Z PROC		; CameraView::SetProjectionType, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	projector.SetOrthogonal(pt == Video::PROJECTION_ORTHOGONAL);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  00006	83 f8 02	 cmp	 eax, 2
  00009	0f 94 c2	 sete	 dl
  0000c	88 91 b8 00 00
	00		 mov	 BYTE PTR [ecx+184], dl

; 103  : 	projection_type = pt;

  00012	89 81 5c 01 00
	00		 mov	 DWORD PTR [ecx+348], eax

; 104  : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?SetProjectionType@CameraView@@UAEXK@Z ENDP		; CameraView::SetProjectionType
_TEXT	ENDS
PUBLIC	??1CameraView@@UAE@XZ				; CameraView::~CameraView
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\view.h
xdata$x	SEGMENT
__unwindtable$??1CameraView@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CameraView@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CameraView@@UAE@XZ$1
__ehfuncinfo$??1CameraView@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CameraView@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\cameraview.cpp
xdata$x	ENDS
;	COMDAT ??1CameraView@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CameraView@@UAE@XZ PROC				; CameraView::~CameraView, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CameraView@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CameraView@@6B@
  0002f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 63   : }

  00036	8b 86 88 01 00
	00		 mov	 eax, DWORD PTR [esi+392]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00042	83 c4 04	 add	 esp, 4
  00045	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  00048	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0004c	e8 00 00 00 00	 call	 ??1Projector@@UAE@XZ	; Projector::~Projector
  00051	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7View@@6B@
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CameraView@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1View@@UAE@XZ		; View::~View
__unwindfunclet$??1CameraView@@UAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 58	 add	 ecx, 88			; 00000058H
  0000e	e9 00 00 00 00	 jmp	 ??1Projector@@UAE@XZ	; Projector::~Projector
__ehhandler$??1CameraView@@UAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CameraView@@UAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CameraView@@UAE@XZ ENDP				; CameraView::~CameraView
; Function compile flags: /Ogtp
;	COMDAT ??_GCameraView@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCameraView@@UAEPAXI@Z PROC				; CameraView::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CameraView@@UAE@XZ	; CameraView::~CameraView
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@5
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@5:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCameraView@@UAEPAXI@Z ENDP				; CameraView::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z ; CameraView::CameraView
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\window.h
xdata$x	SEGMENT
__unwindtable$??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z$0
__ehfuncinfo$??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\cameraview.cpp
xdata$x	ENDS
;	COMDAT ??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z
_TEXT	SEGMENT
_r$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_cam$ = 12						; size = 4
??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z PROC ; CameraView::CameraView, COMDAT
; _c$ = ecx
; _s$ = edx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b 45 0c	 mov	 eax, DWORD PTR _cam$[ebp]
  0002a	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0002d	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00030	33 ff		 xor	 edi, edi
  00032	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00035	0f 57 c0	 xorps	 xmm0, xmm0
  00038	50		 push	 eax
  00039	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CameraView@@6B@
  0003f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00042	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00045	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00048	51		 push	 ecx
  00049	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  0004c	f2 0f 11 46 18	 movsd	 QWORD PTR [esi+24], xmm0
  00051	f2 0f 11 46 20	 movsd	 QWORD PTR [esi+32], xmm0
  00056	f2 0f 11 46 28	 movsd	 QWORD PTR [esi+40], xmm0
  0005b	e8 00 00 00 00	 call	 ??0Projector@@QAE@PAVWindow@@PAVCamera@@@Z ; Projector::Projector
  00060	89 be 50 01 00
	00		 mov	 DWORD PTR [esi+336], edi
  00066	c7 86 5c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+348], 1
  00070	89 be 60 01 00
	00		 mov	 DWORD PTR [esi+352], edi
  00076	89 be 70 01 00
	00		 mov	 DWORD PTR [esi+368], edi
  0007c	89 be 80 01 00
	00		 mov	 DWORD PTR [esi+384], edi
  00082	89 be 84 01 00
	00		 mov	 DWORD PTR [esi+388], edi
  00088	89 be 88 01 00
	00		 mov	 DWORD PTR [esi+392], edi

; 46   : 	elem_bitmap[0] = 0;

  0008e	89 be 74 01 00
	00		 mov	 DWORD PTR [esi+372], edi

; 47   : 	elem_bitmap[1] = 0;

  00094	89 be 78 01 00
	00		 mov	 DWORD PTR [esi+376], edi

; 48   : 	elem_bitmap[2] = 0;

  0009a	89 be 7c 01 00
	00		 mov	 DWORD PTR [esi+380], edi

; 49   : 
; 50   : 	if (!camera)

  000a0	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  000a3	75 07		 jne	 SHORT $LN2@CameraView

; 51   : 	camera = &emergency_cam;

  000a5	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET _emergency_cam
$LN2@CameraView:

; 52   : 
; 53   : 	if (!scene)

  000ac	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  000af	75 07		 jne	 SHORT $LN1@CameraView

; 54   : 	scene = &emergency_scene;

  000b1	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], OFFSET _emergency_scene
$LN1@CameraView:

; 55   : 
; 56   : 	Rect r = window->GetRect();

  000b8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000bb	f3 0f 7e 40 04	 movq	 xmm0, QWORD PTR [eax+4]
  000c0	66 0f d6 45 e4	 movq	 QWORD PTR _r$[ebp], xmm0
  000c5	f3 0f 7e 40 0c	 movq	 xmm0, QWORD PTR [eax+12]
  000ca	66 0f d6 45 ec	 movq	 QWORD PTR _r$[ebp+8], xmm0

; 57   : 	width  = r.w;

  000cf	8b 45 ec	 mov	 eax, DWORD PTR _r$[ebp+8]

; 58   : 	height = r.h;

  000d2	8b 4d f0	 mov	 ecx, DWORD PTR _r$[ebp+12]
  000d5	89 86 54 01 00
	00		 mov	 DWORD PTR [esi+340], eax
  000db	89 8e 58 01 00
	00		 mov	 DWORD PTR [esi+344], ecx

; 59   : }

  000e1	8b c6		 mov	 eax, esi
  000e3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ed	59		 pop	 ecx
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z$0:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1View@@UAE@XZ		; View::~View
__ehhandler$??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CameraView@@QAE@PAVWindow@@PAVCamera@@PAVScene@@@Z ENDP ; CameraView::CameraView
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\light.h
;	COMDAT ?Location@Light@@QBE?AUPoint@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?Location@Light@@QBE?AUPoint@@XZ PROC			; Light::Location, COMDAT
; _this$ = ecx

; 53   : 	Point             Location()        const { return loc;     }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	dd 41 10	 fld	 QWORD PTR [ecx+16]
  00009	dd 18		 fstp	 QWORD PTR [eax]
  0000b	dd 41 18	 fld	 QWORD PTR [ecx+24]
  0000e	dd 58 08	 fstp	 QWORD PTR [eax+8]
  00011	dd 41 20	 fld	 QWORD PTR [ecx+32]
  00014	dd 58 10	 fstp	 QWORD PTR [eax+16]
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?Location@Light@@QBE?AUPoint@@XZ ENDP			; Light::Location
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\scene.h
_TEXT	ENDS
;	COMDAT ?Ambient@Scene@@QAE?AVColor@@XZ
_TEXT	SEGMENT
?Ambient@Scene@@QAE?AVColor@@XZ PROC			; Scene::Ambient, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 55   : 	Color             Ambient()                  { return ambient;    }

  00000	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00003	89 10		 mov	 DWORD PTR [eax], edx
  00005	c3		 ret	 0
?Ambient@Scene@@QAE?AVColor@@XZ ENDP			; Scene::Ambient
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\geometry.h
_TEXT	ENDS
;	COMDAT ??GPoint@@QBE?AU0@XZ
_TEXT	SEGMENT
??GPoint@@QBE?AU0@XZ PROC				; Point::operator-, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 205  : 	Point operator- ()               const { return Point(-x, -y, -z);          }

  00000	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __mask@@NegDouble@
  00008	f2 0f 10 09	 movsd	 xmm1, QWORD PTR [ecx]
  0000c	66 0f 57 c8	 xorpd	 xmm1, xmm0
  00010	f2 0f 11 08	 movsd	 QWORD PTR [eax], xmm1
  00014	f2 0f 10 49 08	 movsd	 xmm1, QWORD PTR [ecx+8]
  00019	66 0f 57 c8	 xorpd	 xmm1, xmm0
  0001d	f2 0f 11 48 08	 movsd	 QWORD PTR [eax+8], xmm1
  00022	f2 0f 10 49 10	 movsd	 xmm1, QWORD PTR [ecx+16]
  00027	66 0f 57 c8	 xorpd	 xmm1, xmm0
  0002b	f2 0f 11 48 10	 movsd	 QWORD PTR [eax+16], xmm1
  00030	c3		 ret	 0
??GPoint@@QBE?AU0@XZ ENDP				; Point::operator-
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??GVec3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_p$ = 12						; size = 4
??GVec3@@QBE?AU0@ABU0@@Z PROC				; Vec3::operator-, COMDAT
; _this$ = ecx

; 159  : 	Vec3   operator- (const Vec3& p)  const { return Vec3(x-p.x, y-p.y, z-p.z);  }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000a	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	0f 5a c9	 cvtps2pd xmm1, xmm1
  00017	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0001b	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00020	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00024	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00028	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	0f 5a c9	 cvtps2pd xmm1, xmm1
  00033	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00037	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [edx+8]
  0003c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00040	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00045	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0004a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0004d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00050	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00054	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00058	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
??GVec3@@QBE?AU0@ABU0@@Z ENDP				; Vec3::operator-
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GView@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GView@@UAEPAXI@Z PROC				; View::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7View@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar@6
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar@6:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GView@@UAEPAXI@Z ENDP				; View::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\cameraview.cpp
;	COMDAT ?WorldPlaneToView@CameraView@@MAEXAAUPlane@@@Z
_TEXT	SEGMENT
_tnormal$ = -12						; size = 12
_plane$ = 8						; size = 4
?WorldPlaneToView@CameraView@@MAEXAAUPlane@@@Z PROC	; CameraView::WorldPlaneToView, COMDAT
; _this$ = ecx

; 788  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 10	 sub	 esp, 16			; 00000010H

; 789  : 	// Determine the distance from the viewpoint
; 790  : 	Vec3 tnormal = plane.normal;
; 791  : 
; 792  : 	if (!infinite)

  00009	83 b9 50 01 00
	00 00		 cmp	 DWORD PTR [ecx+336], 0
  00010	8b 55 08	 mov	 edx, DWORD PTR _plane$[ebp]
  00013	f3 0f 7e 42 04	 movq	 xmm0, QWORD PTR [edx+4]
  00018	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001b	66 0f d6 44 24
	04		 movq	 QWORD PTR _tnormal$[esp+16], xmm0
  00021	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR _tnormal$[esp+20]
  00027	f3 0f 10 4c 24
	04		 movss	 xmm1, DWORD PTR _tnormal$[esp+16]
  0002d	89 44 24 0c	 mov	 DWORD PTR _tnormal$[esp+24], eax
  00031	f3 0f 10 74 24
	0c		 movss	 xmm6, DWORD PTR _tnormal$[esp+24]
  00037	75 59		 jne	 SHORT $LN1@WorldPlane

; 793  : 	plane.distance -= (float) (camera->Pos() * tnormal);

  00039	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0003c	f2 0f 10 50 18	 movsd	 xmm2, QWORD PTR [eax+24]
  00041	f3 0f 10 3a	 movss	 xmm7, DWORD PTR [edx]
  00045	0f 5a e0	 cvtps2pd xmm4, xmm0
  00048	f2 0f 10 40 10	 movsd	 xmm0, QWORD PTR [eax+16]
  0004d	f2 0f 59 c4	 mulsd	 xmm0, xmm4
  00051	0f 5a d9	 cvtps2pd xmm3, xmm1
  00054	f2 0f 10 48 08	 movsd	 xmm1, QWORD PTR [eax+8]
  00059	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  0005d	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00061	f3 0f 10 4c 24
	04		 movss	 xmm1, DWORD PTR _tnormal$[esp+16]
  00067	0f 5a ee	 cvtps2pd xmm5, xmm6
  0006a	f2 0f 59 d5	 mulsd	 xmm2, xmm5
  0006e	f2 0f 58 c2	 addsd	 xmm0, xmm2
  00072	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00076	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0007a	0f 5a ff	 cvtps2pd xmm7, xmm7
  0007d	f2 0f 5c f8	 subsd	 xmm7, xmm0
  00081	0f 57 c0	 xorps	 xmm0, xmm0
  00084	66 0f 5a c7	 cvtpd2ps xmm0, xmm7
  00088	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0
  0008c	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR _tnormal$[esp+20]
$LN1@WorldPlane:

; 794  : 
; 795  : 	// Rotate the normal into view orientation
; 796  : 	plane.normal.x = tnormal * cvrt;

  00092	f3 0f 10 51 34	 movss	 xmm2, DWORD PTR [ecx+52]
  00097	0f 5a d8	 cvtps2pd xmm3, xmm0
  0009a	0f 5a d2	 cvtps2pd xmm2, xmm2
  0009d	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  000a1	f3 0f 10 59 30	 movss	 xmm3, DWORD PTR [ecx+48]
  000a6	0f 5a db	 cvtps2pd xmm3, xmm3
  000a9	0f 5a e1	 cvtps2pd xmm4, xmm1
  000ac	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  000b0	f2 0f 58 d3	 addsd	 xmm2, xmm3
  000b4	f3 0f 10 59 38	 movss	 xmm3, DWORD PTR [ecx+56]
  000b9	0f 5a db	 cvtps2pd xmm3, xmm3
  000bc	0f 5a e6	 cvtps2pd xmm4, xmm6
  000bf	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  000c3	f2 0f 58 d3	 addsd	 xmm2, xmm3
  000c7	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  000cb	f3 0f 11 52 04	 movss	 DWORD PTR [edx+4], xmm2

; 797  : 	plane.normal.y = tnormal * cvup;

  000d0	f3 0f 10 51 40	 movss	 xmm2, DWORD PTR [ecx+64]
  000d5	0f 5a d2	 cvtps2pd xmm2, xmm2
  000d8	0f 5a d8	 cvtps2pd xmm3, xmm0
  000db	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  000df	f3 0f 10 59 3c	 movss	 xmm3, DWORD PTR [ecx+60]
  000e4	0f 5a e1	 cvtps2pd xmm4, xmm1
  000e7	0f 5a db	 cvtps2pd xmm3, xmm3
  000ea	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  000ee	f2 0f 58 d3	 addsd	 xmm2, xmm3
  000f2	f3 0f 10 59 44	 movss	 xmm3, DWORD PTR [ecx+68]

; 798  : 	plane.normal.z = tnormal * cvpn;

  000f7	0f 5a c0	 cvtps2pd xmm0, xmm0
  000fa	0f 5a db	 cvtps2pd xmm3, xmm3
  000fd	0f 5a e6	 cvtps2pd xmm4, xmm6
  00100	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  00104	f2 0f 58 d3	 addsd	 xmm2, xmm3
  00108	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  0010c	f3 0f 11 52 08	 movss	 DWORD PTR [edx+8], xmm2
  00111	f3 0f 10 51 4c	 movss	 xmm2, DWORD PTR [ecx+76]
  00116	0f 5a d2	 cvtps2pd xmm2, xmm2
  00119	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  0011d	f3 0f 10 41 48	 movss	 xmm0, DWORD PTR [ecx+72]
  00122	0f 5a c0	 cvtps2pd xmm0, xmm0
  00125	0f 5a c9	 cvtps2pd xmm1, xmm1
  00128	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0012c	f2 0f 58 d0	 addsd	 xmm2, xmm0
  00130	f3 0f 10 41 50	 movss	 xmm0, DWORD PTR [ecx+80]
  00135	0f 5a c0	 cvtps2pd xmm0, xmm0
  00138	0f 5a ce	 cvtps2pd xmm1, xmm6
  0013b	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0013f	f2 0f 58 d0	 addsd	 xmm2, xmm0
  00143	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  00147	f3 0f 11 42 0c	 movss	 DWORD PTR [edx+12], xmm0

; 799  : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 04 00	 ret	 4
?WorldPlaneToView@CameraView@@MAEXAAUPlane@@@Z ENDP	; CameraView::WorldPlaneToView
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?RenderLensFlare@CameraView@@UAEXXZ
_TEXT	SEGMENT
_vlen$85437 = -92					; size = 4
_light_iter$ = -88					; size = 8
$T320911 = -80						; size = 8
$T320739 = -72						; size = 12
_center$ = -60						; size = 12
_sun_pos$85420 = -48					; size = 24
_vector$85433 = -24					; size = 24
$T320740 = -24						; size = 24
?RenderLensFlare@CameraView@@UAEXXZ PROC		; CameraView::RenderLensFlare, COMDAT
; _this$ = ecx

; 694  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 74	 sub	 esp, 116		; 00000074H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 695  : 	if (!lens_flare_enable || lens_flare_dim < 0.01)

  0000e	83 bf 60 01 00
	00 00		 cmp	 DWORD PTR [edi+352], 0
  00015	0f 84 02 04 00
	00		 je	 $LN15@RenderLens
  0001b	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f847ae147ae147b
  00023	66 0f 2f 87 68
	01 00 00	 comisd	 xmm0, QWORD PTR [edi+360]
  0002b	0f 87 ec 03 00
	00		 ja	 $LN15@RenderLens

; 696  : 	return;
; 697  : 
; 698  : 	if (!halo_bitmap)

  00031	83 bf 70 01 00
	00 00		 cmp	 DWORD PTR [edi+368], 0
  00038	0f 84 df 03 00
	00		 je	 $LN15@RenderLens

; 699  : 	return;
; 700  : 
; 701  : 	video->SetRenderState(Video::STENCIL_ENABLE,    FALSE);

  0003e	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00049	6a 00		 push	 0
  0004b	6a 0c		 push	 12			; 0000000cH
  0004d	ff d2		 call	 edx

; 702  : 	video->SetRenderState(Video::Z_ENABLE,          FALSE);

  0004f	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0005a	6a 00		 push	 0
  0005c	6a 03		 push	 3
  0005e	ff d2		 call	 edx

; 703  : 	video->SetRenderState(Video::Z_WRITE_ENABLE,    FALSE);

  00060	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00063	8b 01		 mov	 eax, DWORD PTR [ecx]
  00065	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0006b	6a 00		 push	 0
  0006d	6a 04		 push	 4
  0006f	ff d2		 call	 edx

; 704  : 
; 705  : 	Vec3 flare_pos;
; 706  : 	Vec3 sun_pos;
; 707  : 	Vec3 center((float)width/2.0f, (float)height/2.0f, 1.0f);

  00071	66 0f 6e 87 54
	01 00 00	 movd	 xmm0, DWORD PTR [edi+340]

; 708  : 	int  flare_visible = 0;
; 709  : 
; 710  : 	ListIter<Light> light_iter = scene->Lights();

  00079	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0007c	0f 57 c9	 xorps	 xmm1, xmm1
  0007f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00082	f3 0f 5a c8	 cvtss2sd xmm1, xmm0
  00086	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR _BLEED
  0008e	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00092	f3 0f 11 4c 24
	44		 movss	 DWORD PTR _center$[esp+128], xmm1
  00098	66 0f 6e 8f 58
	01 00 00	 movd	 xmm1, DWORD PTR [edi+344]
  000a0	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000a3	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  000a7	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR _BLEED
  000af	0f 57 c0	 xorps	 xmm0, xmm0
  000b2	83 c0 34	 add	 eax, 52			; 00000034H
  000b5	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1

; 711  : 	while (++light_iter) {

  000b9	8d 4c 24 28	 lea	 ecx, DWORD PTR _light_iter$[esp+128]
  000bd	f3 0f 11 44 24
	48		 movss	 DWORD PTR _center$[esp+132], xmm0
  000c3	89 44 24 28	 mov	 DWORD PTR _light_iter$[esp+128], eax
  000c7	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR _light_iter$[esp+132], -1
  000cf	e8 00 00 00 00	 call	 ?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::next
  000d4	85 c0		 test	 eax, eax
  000d6	0f 84 41 03 00
	00		 je	 $LN15@RenderLens
$LN13@RenderLens:

; 712  : 		Light* light = light_iter.value();

  000dc	8d 4c 24 28	 lea	 ecx, DWORD PTR _light_iter$[esp+128]
  000e0	e8 00 00 00 00	 call	 ?value@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::value
  000e5	8b f0		 mov	 esi, eax

; 713  : 
; 714  : 		if (!light->IsActive())

  000e7	80 7e 38 00	 cmp	 BYTE PTR [esi+56], 0
  000eb	0f 84 1b 03 00
	00		 je	 $LN2@RenderLens

; 715  : 		continue;
; 716  : 
; 717  : 		if (light->Type() == Light::LIGHT_DIRECTIONAL && light->Intensity() < 1)

  000f1	83 7e 0c 03	 cmp	 DWORD PTR [esi+12], 3
  000f5	75 12		 jne	 SHORT $LN10@RenderLens
  000f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000ff	0f 2f 46 2c	 comiss	 xmm0, DWORD PTR [esi+44]
  00103	0f 87 03 03 00
	00		 ja	 $LN2@RenderLens
$LN10@RenderLens:

; 718  : 		continue;
; 719  : 
; 720  : 		double distance = (light->Location()-camera->Pos()).length();

  00109	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0010c	f2 0f 10 5e 10	 movsd	 xmm3, QWORD PTR [esi+16]
  00111	f2 0f 10 66 18	 movsd	 xmm4, QWORD PTR [esi+24]
  00116	f2 0f 10 6e 20	 movsd	 xmm5, QWORD PTR [esi+32]
  0011b	66 0f 28 c3	 movapd	 xmm0, xmm3
  0011f	f2 0f 5c 40 08	 subsd	 xmm0, QWORD PTR [eax+8]
  00124	66 0f 28 cc	 movapd	 xmm1, xmm4
  00128	f2 0f 5c 48 10	 subsd	 xmm1, QWORD PTR [eax+16]
  0012d	66 0f 28 d5	 movapd	 xmm2, xmm5
  00131	f2 0f 5c 50 18	 subsd	 xmm2, QWORD PTR [eax+24]
  00136	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  0013a	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0013e	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00142	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  00146	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0014a	f2 0f 51 c1	 sqrtsd	 xmm0, xmm1

; 721  : 
; 722  : 		// only do lens flare for the sun:
; 723  : 		if (distance > 1e9) {

  0014e	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@41cdcd6500000000
  00156	0f 86 b0 02 00
	00		 jbe	 $LN2@RenderLens

; 724  : 			if (projector.IsVisible(light->Location(), 1.0f)) {

  0015c	66 0f 5a c3	 cvtpd2ps xmm0, xmm3
  00160	f3 0f 11 44 24
	38		 movss	 DWORD PTR $T320739[esp+128], xmm0
  00166	51		 push	 ecx
  00167	8d 4c 24 3c	 lea	 ecx, DWORD PTR $T320739[esp+132]
  0016b	66 0f 5a c4	 cvtpd2ps xmm0, xmm4
  0016f	f3 0f 11 44 24
	40		 movss	 DWORD PTR $T320739[esp+136], xmm0
  00175	66 0f 5a c5	 cvtpd2ps xmm0, xmm5
  00179	f3 0f 11 44 24
	44		 movss	 DWORD PTR $T320739[esp+140], xmm0
  0017f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00187	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018c	51		 push	 ecx
  0018d	8d 4f 58	 lea	 ecx, DWORD PTR [edi+88]
  00190	e8 00 00 00 00	 call	 ?IsVisible@Projector@@QBEHABUVec3@@M@Z ; Projector::IsVisible
  00195	85 c0		 test	 eax, eax
  00197	0f 84 6f 02 00
	00		 je	 $LN2@RenderLens

; 725  : 				// FOUND IT: TRANSFORM/PROJECT FLARE LOCATION
; 726  : 				Point sun_pos = light->Location();
; 727  : 
; 728  : 				if (light->CastsShadow() && scene->IsLightObscured(camera->Pos(), sun_pos, -1))

  0019d	80 7e 39 00	 cmp	 BYTE PTR [esi+57], 0
  001a1	f2 0f 10 46 10	 movsd	 xmm0, QWORD PTR [esi+16]
  001a6	f2 0f 11 44 24
	50		 movsd	 QWORD PTR _sun_pos$85420[esp+128], xmm0
  001ac	f2 0f 10 46 18	 movsd	 xmm0, QWORD PTR [esi+24]
  001b1	f2 0f 11 44 24
	58		 movsd	 QWORD PTR _sun_pos$85420[esp+136], xmm0
  001b7	f2 0f 10 46 20	 movsd	 xmm0, QWORD PTR [esi+32]
  001bc	f2 0f 11 44 24
	60		 movsd	 QWORD PTR _sun_pos$85420[esp+144], xmm0
  001c2	74 55		 je	 SHORT $LN7@RenderLens
  001c4	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  001c7	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  001cc	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  001cf	f2 0f 11 44 24
	68		 movsd	 QWORD PTR $T320740[esp+128], xmm0
  001d5	f2 0f 10 40 10	 movsd	 xmm0, QWORD PTR [eax+16]
  001da	f2 0f 11 44 24
	70		 movsd	 QWORD PTR $T320740[esp+136], xmm0
  001e0	f2 0f 10 40 18	 movsd	 xmm0, QWORD PTR [eax+24]
  001e5	6a 00		 push	 0
  001e7	83 ec 08	 sub	 esp, 8
  001ea	f2 0f 11 84 24
	84 00 00 00	 movsd	 QWORD PTR $T320740[esp+156], xmm0
  001f3	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bff0000000000000
  001fb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fd	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00200	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00205	8d 44 24 5c	 lea	 eax, DWORD PTR _sun_pos$85420[esp+140]
  00209	50		 push	 eax
  0020a	8d 44 24 78	 lea	 eax, DWORD PTR $T320740[esp+144]
  0020e	50		 push	 eax
  0020f	ff d2		 call	 edx
  00211	84 c0		 test	 al, al
  00213	0f 85 f3 01 00
	00		 jne	 $LN2@RenderLens
$LN7@RenderLens:

; 729  : 				continue;
; 730  : 
; 731  : 				projector.Transform(sun_pos);

  00219	8b 47 58	 mov	 eax, DWORD PTR [edi+88]
  0021c	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  0021f	8d 4c 24 50	 lea	 ecx, DWORD PTR _sun_pos$85420[esp+128]
  00223	51		 push	 ecx
  00224	8d 4f 58	 lea	 ecx, DWORD PTR [edi+88]
  00227	ff d2		 call	 edx

; 732  : 
; 733  : 				if (sun_pos.z < 100)

  00229	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4059000000000000
  00231	66 0f 2f 44 24
	60		 comisd	 xmm0, QWORD PTR _sun_pos$85420[esp+144]
  00237	0f 87 cf 01 00
	00		 ja	 $LN2@RenderLens

; 734  : 				continue;
; 735  : 
; 736  : 				projector.Project(sun_pos, false);

  0023d	8b 47 58	 mov	 eax, DWORD PTR [edi+88]
  00240	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00243	6a 00		 push	 0
  00245	8d 4c 24 54	 lea	 ecx, DWORD PTR _sun_pos$85420[esp+132]
  00249	51		 push	 ecx
  0024a	8d 4f 58	 lea	 ecx, DWORD PTR [edi+88]
  0024d	ff d2		 call	 edx

; 737  : 
; 738  : 				int x = (int) (sun_pos.x);
; 739  : 				int y = (int) (sun_pos.y);
; 740  : 				int w = (int) (window->Width() / 4.0);

  0024f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00252	66 0f 6e 41 0c	 movd	 xmm0, DWORD PTR [ecx+12]

; 741  : 				int h = w;
; 742  : 
; 743  : 				// halo:
; 744  : 				window->DrawBitmap(x-w,y-h,x+w,y+h, halo_bitmap, Video::BLEND_ADDITIVE);

  00257	8b 9f 70 01 00
	00		 mov	 ebx, DWORD PTR [edi+368]
  0025d	f2 0f 2c 54 24
	58		 cvttsd2si edx, QWORD PTR _sun_pos$85420[esp+136]
  00263	f2 0f 2c 44 24
	50		 cvttsd2si eax, QWORD PTR _sun_pos$85420[esp+128]
  00269	6a 04		 push	 4
  0026b	53		 push	 ebx
  0026c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00270	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR _SENSOR_THRESHOLD
  00278	f2 0f 2c f0	 cvttsd2si esi, xmm0
  0027c	8d 1c 16	 lea	 ebx, DWORD PTR [esi+edx]
  0027f	53		 push	 ebx
  00280	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  00283	53		 push	 ebx
  00284	2b d6		 sub	 edx, esi
  00286	52		 push	 edx
  00287	2b c6		 sub	 eax, esi
  00289	50		 push	 eax
  0028a	e8 00 00 00 00	 call	 ?DrawBitmap@Window@@QAEXHHHHPAVBitmap@@H@Z ; Window::DrawBitmap

; 745  : 
; 746  : 				// lens elements:
; 747  : 				if (elem_bitmap[0]) {

  0028f	83 bf 74 01 00
	00 00		 cmp	 DWORD PTR [edi+372], 0
  00296	0f 84 70 01 00
	00		 je	 $LN2@RenderLens

; 748  : 					Point vector = center - sun_pos;

  0029c	f2 0f 10 44 24
	50		 movsd	 xmm0, QWORD PTR _sun_pos$85420[esp+128]
  002a2	f3 0f 10 5c 24
	44		 movss	 xmm3, DWORD PTR _center$[esp+128]
  002a8	f2 0f 10 4c 24
	58		 movsd	 xmm1, QWORD PTR _sun_pos$85420[esp+136]
  002ae	f2 0f 10 54 24
	60		 movsd	 xmm2, QWORD PTR _sun_pos$85420[esp+144]
  002b4	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  002b8	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  002bc	0f 5a db	 cvtps2pd xmm3, xmm3
  002bf	f2 0f 5c d8	 subsd	 xmm3, xmm0
  002c3	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  002c7	0f 57 c0	 xorps	 xmm0, xmm0
  002ca	f2 0f 5a c3	 cvtsd2ss xmm0, xmm3
  002ce	f3 0f 10 5c 24
	48		 movss	 xmm3, DWORD PTR _center$[esp+132]
  002d4	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  002d8	0f 5a db	 cvtps2pd xmm3, xmm3
  002db	f2 0f 5c d9	 subsd	 xmm3, xmm1
  002df	0f 57 c9	 xorps	 xmm1, xmm1
  002e2	f2 0f 5a cb	 cvtsd2ss xmm1, xmm3
  002e6	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  002ee	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  002f2	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  002f6	f2 0f 5c da	 subsd	 xmm3, xmm2
  002fa	0f 57 d2	 xorps	 xmm2, xmm2
  002fd	0f 5a c0	 cvtps2pd xmm0, xmm0
  00300	0f 5a c9	 cvtps2pd xmm1, xmm1
  00303	66 0f 5a d3	 cvtpd2ps xmm2, xmm3
  00307	f2 0f 11 44 24
	68		 movsd	 QWORD PTR _vector$85433[esp+128], xmm0
  0030d	f2 0f 11 4c 24
	70		 movsd	 QWORD PTR _vector$85433[esp+136], xmm1
  00313	0f 5a d2	 cvtps2pd xmm2, xmm2

; 749  : 					float vlen = (float) vector.length();

  00316	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0031a	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  0031e	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00322	f2 0f 11 54 24
	78		 movsd	 QWORD PTR _vector$85433[esp+144], xmm2
  00328	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  0032c	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00330	f2 0f 51 c1	 sqrtsd	 xmm0, xmm1
  00334	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 750  : 					vector.Normalize();

  00338	8d 4c 24 68	 lea	 ecx, DWORD PTR _vector$85433[esp+128]
  0033c	f3 0f 11 44 24
	24		 movss	 DWORD PTR _vlen$85437[esp+128], xmm0
  00342	e8 00 00 00 00	 call	 ?Normalize@Point@@QAENXZ ; Point::Normalize
  00347	dd d8		 fstp	 ST(0)

; 767  : 
; 768  : 						flare_pos = sun_pos + (vector * elem_dist[elem] * vlen);

  00349	f3 0f 10 5c 24
	24		 movss	 xmm3, DWORD PTR _vlen$85437[esp+128]
  0034f	0f 5a db	 cvtps2pd xmm3, xmm3
  00352	f2 0f 11 5c 24
	30		 movsd	 QWORD PTR $T320911[esp+128], xmm3
  00358	33 db		 xor	 ebx, ebx
  0035a	eb 0a		 jmp	 SHORT $LN4@RenderLens
  0035c	8d 64 24 00	 npad	 4
$LL111@RenderLens:

; 751  : 
; 752  : 					static int   nelem = 12;
; 753  : 					static int   elem_indx[] = {  0,    1,    1,     1,     0,      0,     0,    0,    2,    0,    0,    2    };
; 754  : 					static float elem_dist[] = { -0.2f, 0.5f, 0.55f, 0.62f, 1.23f, 1.33f, 1.35f, 0.8f, 0.9f, 1.4f, 1.7f, 1.8f };
; 755  : 					static float elem_size[] = {  0.3f, 0.2f, 0.4f,  0.3f,  0.4f,  0.2f,  0.6f,  0.1f, 0.1f, 1.6f, 1.0f, 0.2f };
; 756  : 
; 757  : 					for (int elem = 0; elem < nelem; elem++) {

  00360	f2 0f 10 5c 24
	30		 movsd	 xmm3, QWORD PTR $T320911[esp+128]
$LN4@RenderLens:

; 758  : 						Bitmap* img = elem_bitmap[elem_indx[elem]];

  00366	8b 83 00 00 00
	00		 mov	 eax, DWORD PTR ?elem_indx@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4PAHA[ebx]
  0036c	8b 8c 87 74 01
	00 00		 mov	 ecx, DWORD PTR [edi+eax*4+372]

; 759  : 
; 760  : 						/***
; 761  : 				if (elem == 10)
; 762  : 					shade *= 0.5;
; 763  : 				***/
; 764  : 
; 765  : 						if (img == 0)

  00373	85 c9		 test	 ecx, ecx
  00375	75 06		 jne	 SHORT $LN1@RenderLens

; 766  : 						img = elem_bitmap[0];

  00377	8b 8f 74 01 00
	00		 mov	 ecx, DWORD PTR [edi+372]
$LN1@RenderLens:

; 767  : 
; 768  : 						flare_pos = sun_pos + (vector * elem_dist[elem] * vlen);

  0037d	f3 0f 10 83 00
	00 00 00	 movss	 xmm0, DWORD PTR ?elem_dist@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4PAMA[ebx]
  00385	f2 0f 10 4c 24
	70		 movsd	 xmm1, QWORD PTR _vector$85433[esp+136]

; 769  : 						x = (int) (flare_pos.x);
; 770  : 						y = (int) (flare_pos.y);
; 771  : 						w = (int) (window->Width() / 8.0 * elem_size[elem]);

  0038b	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0038e	0f 5a d0	 cvtps2pd xmm2, xmm0
  00391	f2 0f 10 44 24
	68		 movsd	 xmm0, QWORD PTR _vector$85433[esp+128]
  00397	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0039b	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  0039f	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  003a3	f2 0f 58 4c 24
	58		 addsd	 xmm1, QWORD PTR _sun_pos$85420[esp+136]
  003a9	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  003ad	f2 0f 58 44 24
	50		 addsd	 xmm0, QWORD PTR _sun_pos$85420[esp+128]
  003b3	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  003b7	f3 0f 2c d1	 cvttss2si edx, xmm1
  003bb	66 0f 6e 4e 0c	 movd	 xmm1, DWORD PTR [esi+12]
  003c0	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  003c4	f3 0f 2c c0	 cvttss2si eax, xmm0
  003c8	f3 0f 10 83 00
	00 00 00	 movss	 xmm0, DWORD PTR ?elem_size@?BJ@??RenderLensFlare@CameraView@@UAEXXZ@4PAMA[ebx]

; 772  : 						h = w;
; 773  : 
; 774  : 						window->DrawBitmap(x-w,y-h,x+w,y+h, img, Video::BLEND_ADDITIVE);

  003d0	6a 04		 push	 4
  003d2	51		 push	 ecx
  003d3	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  003d7	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fc0000000000000
  003df	0f 5a c0	 cvtps2pd xmm0, xmm0
  003e2	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  003e6	f2 0f 2c f0	 cvttsd2si esi, xmm0
  003ea	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  003ed	51		 push	 ecx
  003ee	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  003f1	51		 push	 ecx
  003f2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  003f5	2b d6		 sub	 edx, esi
  003f7	52		 push	 edx
  003f8	2b c6		 sub	 eax, esi
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ?DrawBitmap@Window@@QAEXHHHHPAVBitmap@@H@Z ; Window::DrawBitmap
  00400	83 c3 04	 add	 ebx, 4
  00403	83 fb 30	 cmp	 ebx, 48			; 00000030H
  00406	0f 8c 54 ff ff
	ff		 jl	 $LL111@RenderLens
$LN2@RenderLens:

; 711  : 	while (++light_iter) {

  0040c	8d 4c 24 28	 lea	 ecx, DWORD PTR _light_iter$[esp+128]
  00410	e8 00 00 00 00	 call	 ?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::next
  00415	85 c0		 test	 eax, eax
  00417	0f 85 bf fc ff
	ff		 jne	 $LN13@RenderLens
$LN15@RenderLens:

; 775  : 					}
; 776  : 				}
; 777  : 			}
; 778  : 		}
; 779  : 	}
; 780  : }

  0041d	5f		 pop	 edi
  0041e	5e		 pop	 esi
  0041f	5b		 pop	 ebx
  00420	8b e5		 mov	 esp, ebp
  00422	5d		 pop	 ebp
  00423	c3		 ret	 0
?RenderLensFlare@CameraView@@UAEXXZ ENDP		; CameraView::RenderLensFlare
_TEXT	ENDS
PUBLIC	__real@49742400
PUBLIC	__real@5368d4a5
;	COMDAT __real@49742400
; File c:\matrix games\dev\foundationex\list.h
CONST	SEGMENT
__real@49742400 DD 049742400r			; 1e+006
CONST	ENDS
;	COMDAT __real@5368d4a5
CONST	SEGMENT
__real@5368d4a5 DD 05368d4a5r			; 1e+012
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\cameraview.cpp
CONST	ENDS
;	COMDAT ?RenderSceneObjects@CameraView@@UAEX_N@Z
_TEXT	SEGMENT
tv782 = -16						; size = 4
tv769 = -16						; size = 4
_shadow_iter$85347 = -16				; size = 8
_iter$ = -8						; size = 8
_distant$ = 8						; size = 1
?RenderSceneObjects@CameraView@@UAEX_N@Z PROC		; CameraView::RenderSceneObjects, COMDAT
; _this$ = ecx

; 575  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi

; 576  : 	ListIter<Graphic> iter = graphics;
; 577  : 
; 578  : 	video->SetAmbient(scene->Ambient());

  0000e	51		 push	 ecx
  0000f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00012	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00015	8d 86 80 01 00
	00		 lea	 eax, DWORD PTR [esi+384]
  0001b	89 44 24 1c	 mov	 DWORD PTR _iter$[esp+36], eax
  0001f	8b c4		 mov	 eax, esp
  00021	89 10		 mov	 DWORD PTR [eax], edx
  00023	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  0002e	ff d2		 call	 edx

; 579  : 	video->SetRenderState(Video::FILL_MODE,         Video::FILL_SOLID);

  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0003b	6a 03		 push	 3
  0003d	6a 00		 push	 0
  0003f	ff d2		 call	 edx

; 580  : 	video->SetRenderState(Video::Z_ENABLE,          TRUE);

  00041	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00044	8b 01		 mov	 eax, DWORD PTR [ecx]
  00046	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0004c	6a 01		 push	 1
  0004e	6a 03		 push	 3
  00050	ff d2		 call	 edx

; 581  : 	video->SetRenderState(Video::Z_WRITE_ENABLE,    TRUE);

  00052	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00055	8b 01		 mov	 eax, DWORD PTR [ecx]
  00057	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0005d	6a 01		 push	 1
  0005f	6a 04		 push	 4
  00061	ff d2		 call	 edx

; 582  : 	video->SetRenderState(Video::LIGHTING_ENABLE,   TRUE);

  00063	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00066	8b 01		 mov	 eax, DWORD PTR [ecx]
  00068	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0006e	6a 01		 push	 1
  00070	6a 02		 push	 2
  00072	ff d2		 call	 edx

; 583  : 
; 584  : 	if (distant)
; 585  : 	video->SetProjection((float) GetFieldOfView(), 5.0e6f, 1.0e12f, projection_type);

  00074	8b 8e 5c 01 00
	00		 mov	 ecx, DWORD PTR [esi+348]
  0007a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0007d	8a 5d 08	 mov	 bl, BYTE PTR _distant$[ebp]
  00080	8b 16		 mov	 edx, DWORD PTR [esi]
  00082	8b 38		 mov	 edi, DWORD PTR [eax]
  00084	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00087	51		 push	 ecx
  00088	83 ec 08	 sub	 esp, 8
  0008b	8b ce		 mov	 ecx, esi
  0008d	84 db		 test	 bl, bl
  0008f	74 27		 je	 SHORT $LN39@RenderScen@2
  00091	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@5368d4a5
  00099	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0009f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@4a989680
  000a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ac	ff d0		 call	 eax
  000ae	d9 5c 24 1c	 fstp	 DWORD PTR tv782[esp+44]
  000b2	d9 44 24 1c	 fld	 DWORD PTR tv782[esp+44]

; 586  : 	else

  000b6	eb 25		 jmp	 SHORT $LN100@RenderScen@2
$LN39@RenderScen@2:

; 587  : 	video->SetProjection((float) GetFieldOfView(), 1.0f,   1.0e6f,  projection_type);

  000b8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@49742400
  000c0	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000c6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d3	ff d0		 call	 eax
  000d5	d9 5c 24 1c	 fstp	 DWORD PTR tv769[esp+44]
  000d9	d9 44 24 1c	 fld	 DWORD PTR tv769[esp+44]
$LN100@RenderScen@2:
  000dd	8b 97 98 00 00
	00		 mov	 edx, DWORD PTR [edi+152]
  000e3	51		 push	 ecx
  000e4	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000e7	d9 1c 24	 fstp	 DWORD PTR [esp]
  000ea	ff d2		 call	 edx

; 588  : 
; 589  : 	if (video->IsShadowEnabled() || video->IsBumpMapEnabled()) {

  000ec	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000ef	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f1	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  000f4	ff d2		 call	 edx
  000f6	84 c0		 test	 al, al
  000f8	75 73		 jne	 SHORT $LN36@RenderScen@2
  000fa	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000fd	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ff	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  00102	ff d2		 call	 edx
  00104	84 c0		 test	 al, al
  00106	75 65		 jne	 SHORT $LN36@RenderScen@2

; 630  : 			}
; 631  : 		}
; 632  : 	}
; 633  : 
; 634  : 	else {
; 635  : 		// solid items:
; 636  : 		iter.reset();
; 637  : 		while (++iter) {

  00108	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  0010c	c7 44 24 1c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+36], -1
  00114	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00119	85 c0		 test	 eax, eax
  0011b	0f 84 fb 01 00
	00		 je	 $LN20@RenderScen@2
$LL15@RenderScen@2:

; 638  : 			Graphic* g = iter.value();

  00121	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  00125	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  0012a	8b f8		 mov	 edi, eax

; 639  : 
; 640  : 			if (distant && g->Depth() > 5e6 || !distant && g->Depth() < 5e6) {

  0012c	8b 07		 mov	 eax, DWORD PTR [edi]
  0012e	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00131	8b cf		 mov	 ecx, edi
  00133	ff d2		 call	 edx
  00135	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4a989680
  0013b	84 db		 test	 bl, bl
  0013d	74 0a		 je	 SHORT $LN97@RenderScen@2
  0013f	d9 c9		 fxch	 ST(1)
  00141	df f1		 fcomip	 ST(1)
  00143	dd d8		 fstp	 ST(0)
  00145	77 08		 ja	 SHORT $LN12@RenderScen@2
  00147	eb 12		 jmp	 SHORT $LN13@RenderScen@2
$LN97@RenderScen@2:
  00149	df f1		 fcomip	 ST(1)
  0014b	dd d8		 fstp	 ST(0)
  0014d	76 0c		 jbe	 SHORT $LN13@RenderScen@2
$LN12@RenderScen@2:

; 641  : 				Render(g, Graphic::RENDER_SOLID);

  0014f	8b 06		 mov	 eax, DWORD PTR [esi]
  00151	8b 50 68	 mov	 edx, DWORD PTR [eax+104]
  00154	6a 01		 push	 1
  00156	57		 push	 edi
  00157	8b ce		 mov	 ecx, esi
  00159	ff d2		 call	 edx
$LN13@RenderScen@2:

; 630  : 			}
; 631  : 		}
; 632  : 	}
; 633  : 
; 634  : 	else {
; 635  : 		// solid items:
; 636  : 		iter.reset();
; 637  : 		while (++iter) {

  0015b	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  0015f	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00164	85 c0		 test	 eax, eax
  00166	75 b9		 jne	 SHORT $LL15@RenderScen@2

; 588  : 
; 589  : 	if (video->IsShadowEnabled() || video->IsBumpMapEnabled()) {

  00168	e9 af 01 00 00	 jmp	 $LN20@RenderScen@2
$LN36@RenderScen@2:

; 590  : 		// solid items, ambient and non-shadow lights:
; 591  : 		iter.reset();
; 592  : 		while (++iter) {

  0016d	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  00171	c7 44 24 1c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+36], -1
  00179	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0017e	85 c0		 test	 eax, eax
  00180	74 4a		 je	 SHORT $LN34@RenderScen@2
$LL35@RenderScen@2:

; 593  : 			Graphic* g = iter.value();

  00182	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  00186	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  0018b	8b f8		 mov	 edi, eax

; 594  : 
; 595  : 			if (distant && g->Depth() > 5e6 || !distant && g->Depth() < 5e6) {

  0018d	8b 07		 mov	 eax, DWORD PTR [edi]
  0018f	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00192	8b cf		 mov	 ecx, edi
  00194	ff d2		 call	 edx
  00196	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4a989680
  0019c	84 db		 test	 bl, bl
  0019e	74 0a		 je	 SHORT $LN96@RenderScen@2
  001a0	d9 c9		 fxch	 ST(1)
  001a2	df f1		 fcomip	 ST(1)
  001a4	dd d8		 fstp	 ST(0)
  001a6	77 08		 ja	 SHORT $LN32@RenderScen@2
  001a8	eb 15		 jmp	 SHORT $LN33@RenderScen@2
$LN96@RenderScen@2:
  001aa	df f1		 fcomip	 ST(1)
  001ac	dd d8		 fstp	 ST(0)
  001ae	76 0f		 jbe	 SHORT $LN33@RenderScen@2
$LN32@RenderScen@2:

; 596  : 				Render(g, Graphic::RENDER_SOLID | Graphic::RENDER_FIRST_LIGHT);

  001b0	8b 06		 mov	 eax, DWORD PTR [esi]
  001b2	8b 50 68	 mov	 edx, DWORD PTR [eax+104]
  001b5	68 01 10 00 00	 push	 4097			; 00001001H
  001ba	57		 push	 edi
  001bb	8b ce		 mov	 ecx, esi
  001bd	ff d2		 call	 edx
$LN33@RenderScen@2:

; 590  : 		// solid items, ambient and non-shadow lights:
; 591  : 		iter.reset();
; 592  : 		while (++iter) {

  001bf	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  001c3	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  001c8	85 c0		 test	 eax, eax
  001ca	75 b6		 jne	 SHORT $LL35@RenderScen@2
$LN34@RenderScen@2:

; 597  : 			}
; 598  : 		}
; 599  : 
; 600  : 		// send shadows to stencil buffer:
; 601  : 		if (video->IsShadowEnabled()) {

  001cc	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001cf	8b 01		 mov	 eax, DWORD PTR [ecx]
  001d1	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  001d4	ff d2		 call	 edx
  001d6	84 c0		 test	 al, al
  001d8	0f 84 a5 00 00
	00		 je	 $LN28@RenderScen@2

; 602  : 			iter.reset();
; 603  : 			while (++iter) {

  001de	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  001e2	c7 44 24 1c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+36], -1
  001ea	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  001ef	85 c0		 test	 eax, eax
  001f1	0f 84 8c 00 00
	00		 je	 $LN28@RenderScen@2
$LL29@RenderScen@2:

; 604  : 				Graphic* g = iter.value();

  001f7	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  001fb	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  00200	8b f8		 mov	 edi, eax

; 605  : 				if (distant && g->Depth() > 5e6 || !distant && g->Depth() < 5e6) {

  00202	8b 07		 mov	 eax, DWORD PTR [edi]
  00204	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00207	8b cf		 mov	 ecx, edi
  00209	ff d2		 call	 edx
  0020b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4a989680
  00211	84 db		 test	 bl, bl
  00213	74 0a		 je	 SHORT $LN95@RenderScen@2
  00215	d9 c9		 fxch	 ST(1)
  00217	df f1		 fcomip	 ST(1)
  00219	dd d8		 fstp	 ST(0)
  0021b	77 08		 ja	 SHORT $LN26@RenderScen@2
  0021d	eb 53		 jmp	 SHORT $LN22@RenderScen@2
$LN95@RenderScen@2:
  0021f	df f1		 fcomip	 ST(1)
  00221	dd d8		 fstp	 ST(0)
  00223	76 4d		 jbe	 SHORT $LN22@RenderScen@2
$LN26@RenderScen@2:

; 606  : 					if (g->IsSolid()) {

  00225	8b 07		 mov	 eax, DWORD PTR [edi]
  00227	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  0022a	8b cf		 mov	 ecx, edi
  0022c	ff d2		 call	 edx
  0022e	84 c0		 test	 al, al
  00230	74 40		 je	 SHORT $LN22@RenderScen@2

; 607  : 						Solid* solid = (Solid*) g;
; 608  : 
; 609  : 						ListIter<Shadow> shadow_iter = solid->GetShadows();

  00232	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H

; 610  : 						while (++shadow_iter) {

  00238	8d 54 24 10	 lea	 edx, DWORD PTR _shadow_iter$85347[esp+32]
  0023c	89 7c 24 10	 mov	 DWORD PTR _shadow_iter$85347[esp+32], edi
  00240	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _shadow_iter$85347[esp+36], -1
  00248	e8 00 00 00 00	 call	 ?next@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ ; ListIter<Shadow>::next
  0024d	85 c0		 test	 eax, eax
  0024f	74 21		 je	 SHORT $LN22@RenderScen@2
$LL23@RenderScen@2:

; 611  : 							Shadow* shadow = shadow_iter.value();
; 612  : 							shadow->Render(video);

  00251	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00254	50		 push	 eax
  00255	8d 44 24 14	 lea	 eax, DWORD PTR _shadow_iter$85347[esp+36]
  00259	e8 00 00 00 00	 call	 ?value@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ ; ListIter<Shadow>::value
  0025e	8b c8		 mov	 ecx, eax
  00260	e8 00 00 00 00	 call	 ?Render@Shadow@@QAEXPAVVideo@@@Z ; Shadow::Render
  00265	8d 54 24 10	 lea	 edx, DWORD PTR _shadow_iter$85347[esp+32]
  00269	e8 00 00 00 00	 call	 ?next@?$ListIter@VShadow@@@@QAEPAVShadow@@XZ ; ListIter<Shadow>::next
  0026e	85 c0		 test	 eax, eax
  00270	75 df		 jne	 SHORT $LL23@RenderScen@2
$LN22@RenderScen@2:

; 602  : 			iter.reset();
; 603  : 			while (++iter) {

  00272	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  00276	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0027b	85 c0		 test	 eax, eax
  0027d	0f 85 74 ff ff
	ff		 jne	 $LL29@RenderScen@2
$LN28@RenderScen@2:

; 613  : 						}
; 614  : 					}
; 615  : 				}
; 616  : 			}
; 617  : 		}
; 618  : 
; 619  : 		video->SetAmbient(Color::Black);

  00283	51		 push	 ecx
  00284	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Black@Color@@2V1@A ; Color::Black
  0028a	8b c4		 mov	 eax, esp
  0028c	89 08		 mov	 DWORD PTR [eax], ecx
  0028e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00291	8b 11		 mov	 edx, DWORD PTR [ecx]
  00293	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  00299	ff d0		 call	 eax

; 620  : 		video->SetRenderState(Video::LIGHTING_PASS,     2);

  0029b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0029e	8b 11		 mov	 edx, DWORD PTR [ecx]
  002a0	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  002a6	6a 02		 push	 2
  002a8	6a 0e		 push	 14			; 0000000eH
  002aa	ff d0		 call	 eax

; 621  : 		video->SetRenderState(Video::STENCIL_ENABLE,    TRUE);

  002ac	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  002af	8b 11		 mov	 edx, DWORD PTR [ecx]
  002b1	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  002b7	6a 01		 push	 1
  002b9	6a 0c		 push	 12			; 0000000cH
  002bb	ff d0		 call	 eax

; 622  : 
; 623  : 		// solid items, shadow lights:
; 624  : 		iter.reset();
; 625  : 		while (++iter) {

  002bd	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  002c1	c7 44 24 1c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+36], -1
  002c9	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  002ce	85 c0		 test	 eax, eax
  002d0	74 4a		 je	 SHORT $LN20@RenderScen@2
$LL21@RenderScen@2:

; 626  : 			Graphic* g = iter.value();

  002d2	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  002d6	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  002db	8b f8		 mov	 edi, eax

; 627  : 
; 628  : 			if (distant && g->Depth() > 5e6 || !distant && g->Depth() < 5e6) {

  002dd	8b 17		 mov	 edx, DWORD PTR [edi]
  002df	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  002e2	8b cf		 mov	 ecx, edi
  002e4	ff d0		 call	 eax
  002e6	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4a989680
  002ec	84 db		 test	 bl, bl
  002ee	74 0a		 je	 SHORT $LN94@RenderScen@2
  002f0	d9 c9		 fxch	 ST(1)
  002f2	df f1		 fcomip	 ST(1)
  002f4	dd d8		 fstp	 ST(0)
  002f6	77 08		 ja	 SHORT $LN18@RenderScen@2
  002f8	eb 15		 jmp	 SHORT $LN19@RenderScen@2
$LN94@RenderScen@2:
  002fa	df f1		 fcomip	 ST(1)
  002fc	dd d8		 fstp	 ST(0)
  002fe	76 0f		 jbe	 SHORT $LN19@RenderScen@2
$LN18@RenderScen@2:

; 629  : 				Render(g, Graphic::RENDER_SOLID | Graphic::RENDER_ADD_LIGHT);

  00300	8b 16		 mov	 edx, DWORD PTR [esi]
  00302	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00305	68 01 20 00 00	 push	 8193			; 00002001H
  0030a	57		 push	 edi
  0030b	8b ce		 mov	 ecx, esi
  0030d	ff d0		 call	 eax
$LN19@RenderScen@2:

; 622  : 
; 623  : 		// solid items, shadow lights:
; 624  : 		iter.reset();
; 625  : 		while (++iter) {

  0030f	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  00313	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00318	85 c0		 test	 eax, eax
  0031a	75 b6		 jne	 SHORT $LL21@RenderScen@2
$LN20@RenderScen@2:

; 642  : 			}
; 643  : 		}
; 644  : 	}
; 645  : 
; 646  : 	video->SetAmbient(scene->Ambient());

  0031c	51		 push	 ecx
  0031d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00320	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00323	8b c4		 mov	 eax, esp
  00325	89 10		 mov	 DWORD PTR [eax], edx
  00327	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0032a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0032c	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  00332	ff d2		 call	 edx

; 647  : 	video->SetRenderState(Video::LIGHTING_PASS,     0);

  00334	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00337	8b 01		 mov	 eax, DWORD PTR [ecx]
  00339	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0033f	6a 00		 push	 0
  00341	6a 0e		 push	 14			; 0000000eH
  00343	ff d2		 call	 edx

; 648  : 	video->SetRenderState(Video::STENCIL_ENABLE,    FALSE);

  00345	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00348	8b 01		 mov	 eax, DWORD PTR [ecx]
  0034a	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00350	6a 00		 push	 0
  00352	6a 0c		 push	 12			; 0000000cH
  00354	ff d2		 call	 edx

; 649  : 	video->SetRenderState(Video::Z_ENABLE,          TRUE);

  00356	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00359	8b 01		 mov	 eax, DWORD PTR [ecx]
  0035b	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00361	6a 01		 push	 1
  00363	6a 03		 push	 3
  00365	ff d2		 call	 edx

; 650  : 	video->SetRenderState(Video::Z_WRITE_ENABLE,    FALSE);

  00367	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0036a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0036c	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00372	6a 00		 push	 0
  00374	6a 04		 push	 4
  00376	ff d2		 call	 edx

; 651  : 
; 652  : 	// blended items:
; 653  : 	iter.reset();
; 654  : 	while (++iter) {

  00378	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  0037c	c7 44 24 1c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+36], -1
  00384	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00389	85 c0		 test	 eax, eax
  0038b	74 57		 je	 SHORT $LN9@RenderScen@2
  0038d	8d 49 00	 npad	 3
$LL10@RenderScen@2:

; 655  : 		Graphic* g = iter.value();

  00390	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  00394	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  00399	8b f8		 mov	 edi, eax

; 656  : 
; 657  : 		if (distant && g->Depth() > 5e6 || !distant && g->Depth() < 5e6) {

  0039b	8b 07		 mov	 eax, DWORD PTR [edi]
  0039d	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  003a0	8b cf		 mov	 ecx, edi
  003a2	ff d2		 call	 edx
  003a4	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4a989680
  003aa	84 db		 test	 bl, bl
  003ac	74 0a		 je	 SHORT $LN93@RenderScen@2
  003ae	d9 c9		 fxch	 ST(1)
  003b0	df f1		 fcomip	 ST(1)
  003b2	dd d8		 fstp	 ST(0)
  003b4	77 08		 ja	 SHORT $LN7@RenderScen@2
  003b6	eb 1f		 jmp	 SHORT $LN8@RenderScen@2
$LN93@RenderScen@2:
  003b8	df f1		 fcomip	 ST(1)
  003ba	dd d8		 fstp	 ST(0)
  003bc	76 19		 jbe	 SHORT $LN8@RenderScen@2
$LN7@RenderScen@2:

; 658  : 			Render(g, Graphic::RENDER_ALPHA);

  003be	8b 06		 mov	 eax, DWORD PTR [esi]
  003c0	8b 50 68	 mov	 edx, DWORD PTR [eax+104]
  003c3	6a 02		 push	 2
  003c5	57		 push	 edi
  003c6	8b ce		 mov	 ecx, esi
  003c8	ff d2		 call	 edx

; 659  : 			g->ProjectScreenRect(&projector);

  003ca	8b 07		 mov	 eax, DWORD PTR [edi]
  003cc	8b 50 74	 mov	 edx, DWORD PTR [eax+116]
  003cf	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  003d2	51		 push	 ecx
  003d3	8b cf		 mov	 ecx, edi
  003d5	ff d2		 call	 edx
$LN8@RenderScen@2:

; 651  : 
; 652  : 	// blended items:
; 653  : 	iter.reset();
; 654  : 	while (++iter) {

  003d7	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  003db	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  003e0	85 c0		 test	 eax, eax
  003e2	75 ac		 jne	 SHORT $LL10@RenderScen@2
$LN9@RenderScen@2:

; 660  : 		}
; 661  : 	}
; 662  : 
; 663  : 	// glowing items:
; 664  : 	iter.reset();
; 665  : 	while (++iter) {

  003e4	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  003e8	c7 44 24 1c ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+36], -1
  003f0	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  003f5	85 c0		 test	 eax, eax
  003f7	74 5b		 je	 SHORT $LN4@RenderScen@2
  003f9	8d a4 24 00 00
	00 00		 npad	 7
$LL5@RenderScen@2:

; 666  : 		Graphic* g = iter.value();

  00400	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  00404	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  00409	8b f8		 mov	 edi, eax

; 667  : 
; 668  : 		if (distant && g->Depth() > 5e6 || !distant && g->Depth() < 5e6) {

  0040b	8b 07		 mov	 eax, DWORD PTR [edi]
  0040d	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00410	8b cf		 mov	 ecx, edi
  00412	ff d2		 call	 edx
  00414	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4a989680
  0041a	84 db		 test	 bl, bl
  0041c	74 0a		 je	 SHORT $LN92@RenderScen@2
  0041e	d9 c9		 fxch	 ST(1)
  00420	df f1		 fcomip	 ST(1)
  00422	dd d8		 fstp	 ST(0)
  00424	77 08		 ja	 SHORT $LN2@RenderScen@2
  00426	eb 1f		 jmp	 SHORT $LN3@RenderScen@2
$LN92@RenderScen@2:
  00428	df f1		 fcomip	 ST(1)
  0042a	dd d8		 fstp	 ST(0)
  0042c	76 19		 jbe	 SHORT $LN3@RenderScen@2
$LN2@RenderScen@2:

; 669  : 			Render(g, Graphic::RENDER_ADDITIVE);

  0042e	8b 06		 mov	 eax, DWORD PTR [esi]
  00430	8b 50 68	 mov	 edx, DWORD PTR [eax+104]
  00433	6a 04		 push	 4
  00435	57		 push	 edi
  00436	8b ce		 mov	 ecx, esi
  00438	ff d2		 call	 edx

; 670  : 			g->ProjectScreenRect(&projector);

  0043a	8b 07		 mov	 eax, DWORD PTR [edi]
  0043c	8b 50 74	 mov	 edx, DWORD PTR [eax+116]
  0043f	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  00442	51		 push	 ecx
  00443	8b cf		 mov	 ecx, edi
  00445	ff d2		 call	 edx
$LN3@RenderScen@2:

; 660  : 		}
; 661  : 	}
; 662  : 
; 663  : 	// glowing items:
; 664  : 	iter.reset();
; 665  : 	while (++iter) {

  00447	8d 4c 24 18	 lea	 ecx, DWORD PTR _iter$[esp+32]
  0044b	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00450	85 c0		 test	 eax, eax
  00452	75 ac		 jne	 SHORT $LL5@RenderScen@2
$LN4@RenderScen@2:

; 671  : 		}
; 672  : 	}
; 673  : }

  00454	5f		 pop	 edi
  00455	5e		 pop	 esi
  00456	5b		 pop	 ebx
  00457	8b e5		 mov	 esp, ebp
  00459	5d		 pop	 ebp
  0045a	c2 04 00	 ret	 4
?RenderSceneObjects@CameraView@@UAEX_N@Z ENDP		; CameraView::RenderSceneObjects
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?RenderForeground@CameraView@@UAEXXZ
_TEXT	SEGMENT
tv555 = -12						; size = 4
_iter$ = -8						; size = 8
?RenderForeground@CameraView@@UAEXXZ PROC		; CameraView::RenderForeground, COMDAT
; _this$ = ecx

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 419  : 	bool foregroundVisible = false;
; 420  : 
; 421  : 	ListIter<Graphic> iter = scene->Foreground();

  0000d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00010	83 c0 10	 add	 eax, 16			; 00000010H
  00013	57		 push	 edi

; 422  : 	while (++iter && !foregroundVisible) {

  00014	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  00018	32 db		 xor	 bl, bl
  0001a	89 44 24 10	 mov	 DWORD PTR _iter$[esp+24], eax
  0001e	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+28], -1
  00026	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 c1 02 00
	00		 je	 $LN1@RenderFore
$LL17@RenderFore:
  00033	84 db		 test	 bl, bl
  00035	75 31		 jne	 SHORT $LN63@RenderFore

; 423  : 		Graphic* g = iter.value();

  00037	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  0003b	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value

; 424  : 		if (g && !g->Hidden())

  00040	85 c0		 test	 eax, eax
  00042	74 0f		 je	 SHORT $LN15@RenderFore
  00044	8b 10		 mov	 edx, DWORD PTR [eax]
  00046	8b c8		 mov	 ecx, eax
  00048	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0004b	ff d0		 call	 eax
  0004d	85 c0		 test	 eax, eax
  0004f	75 02		 jne	 SHORT $LN15@RenderFore

; 425  : 		foregroundVisible = true;

  00051	b3 01		 mov	 bl, 1
$LN15@RenderFore:

; 422  : 	while (++iter && !foregroundVisible) {

  00053	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  00057	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0005c	85 c0		 test	 eax, eax
  0005e	75 d3		 jne	 SHORT $LL17@RenderFore

; 426  : 	}
; 427  : 
; 428  : 	if (!foregroundVisible)

  00060	84 db		 test	 bl, bl
  00062	0f 84 8c 02 00
	00		 je	 $LN1@RenderFore
$LN63@RenderFore:

; 429  : 	return;
; 430  : 
; 431  : 	video->SetRenderState(Video::FILL_MODE,         Video::FILL_SOLID);

  00068	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0006b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006d	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00073	6a 03		 push	 3
  00075	6a 00		 push	 0
  00077	ff d0		 call	 eax

; 432  : 	video->SetRenderState(Video::Z_ENABLE,          TRUE);

  00079	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00084	6a 01		 push	 1
  00086	6a 03		 push	 3
  00088	ff d0		 call	 eax

; 433  : 	video->SetRenderState(Video::Z_WRITE_ENABLE,    TRUE);

  0008a	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0008d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008f	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00095	6a 01		 push	 1
  00097	6a 04		 push	 4
  00099	ff d0		 call	 eax

; 434  : 	video->SetRenderState(Video::STENCIL_ENABLE,    FALSE);

  0009b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  000a6	6a 00		 push	 0
  000a8	6a 0c		 push	 12			; 0000000cH
  000aa	ff d0		 call	 eax

; 435  : 	video->SetRenderState(Video::LIGHTING_ENABLE,   TRUE);

  000ac	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000af	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b1	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  000b7	6a 01		 push	 1
  000b9	6a 02		 push	 2
  000bb	ff d0		 call	 eax

; 436  : 	video->SetProjection((float) GetFieldOfView(), 1.0f,   1.0e6f,  projection_type);

  000bd	8b 96 5c 01 00
	00		 mov	 edx, DWORD PTR [esi+348]
  000c3	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000c6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@49742400
  000ce	8b 06		 mov	 eax, DWORD PTR [esi]
  000d0	8b 39		 mov	 edi, DWORD PTR [ecx]
  000d2	52		 push	 edx
  000d3	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  000d6	83 ec 08	 sub	 esp, 8
  000d9	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000df	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000e7	8b ce		 mov	 ecx, esi
  000e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ee	ff d2		 call	 edx
  000f0	d9 5c 24 18	 fstp	 DWORD PTR tv555[esp+36]
  000f4	d9 44 24 18	 fld	 DWORD PTR tv555[esp+36]
  000f8	8b 87 98 00 00
	00		 mov	 eax, DWORD PTR [edi+152]
  000fe	51		 push	 ecx
  000ff	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00102	d9 1c 24	 fstp	 DWORD PTR [esp]
  00105	ff d0		 call	 eax

; 437  : 
; 438  : 	if (video->IsShadowEnabled() || video->IsBumpMapEnabled()) {

  00107	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0010a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010c	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0010f	ff d0		 call	 eax
  00111	84 c0		 test	 al, al
  00113	75 52		 jne	 SHORT $LN12@RenderFore
  00115	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00118	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011a	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0011d	ff d0		 call	 eax
  0011f	84 c0		 test	 al, al
  00121	75 44		 jne	 SHORT $LN12@RenderFore

; 454  : 		}
; 455  : 	}
; 456  : 
; 457  : 	else {
; 458  : 		// solid items:
; 459  : 		iter.reset();
; 460  : 		while (++iter) {

  00123	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  00127	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+28], -1
  0012f	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00134	85 c0		 test	 eax, eax
  00136	0f 84 c9 00 00
	00		 je	 $LN8@RenderFore
  0013c	8d 64 24 00	 npad	 4
$LL6@RenderFore:

; 461  : 			Graphic* g = iter.value();
; 462  : 			Render(g, Graphic::RENDER_SOLID);

  00140	8b 3e		 mov	 edi, DWORD PTR [esi]
  00142	6a 01		 push	 1
  00144	8d 4c 24 14	 lea	 ecx, DWORD PTR _iter$[esp+28]
  00148	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  0014d	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  00150	50		 push	 eax
  00151	8b ce		 mov	 ecx, esi
  00153	ff d2		 call	 edx
  00155	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  00159	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0015e	85 c0		 test	 eax, eax
  00160	75 de		 jne	 SHORT $LL6@RenderFore

; 437  : 
; 438  : 	if (video->IsShadowEnabled() || video->IsBumpMapEnabled()) {

  00162	e9 9e 00 00 00	 jmp	 $LN8@RenderFore
$LN12@RenderFore:

; 439  : 		// solid items, ambient and non-shadow lights:
; 440  : 		iter.reset();

  00167	83 cf ff	 or	 edi, -1

; 441  : 		while (++iter) {

  0016a	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  0016e	89 7c 24 14	 mov	 DWORD PTR _iter$[esp+28], edi
  00172	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00177	85 c0		 test	 eax, eax
  00179	74 2a		 je	 SHORT $LN10@RenderFore
  0017b	eb 03 8d 49 00	 npad	 5
$LL11@RenderFore:

; 442  : 			Graphic* g = iter.value();
; 443  : 			Render(g, Graphic::RENDER_SOLID | Graphic::RENDER_FIRST_LIGHT);

  00180	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00182	68 01 10 00 00	 push	 4097			; 00001001H
  00187	8d 4c 24 14	 lea	 ecx, DWORD PTR _iter$[esp+28]
  0018b	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  00190	50		 push	 eax
  00191	8b 43 68	 mov	 eax, DWORD PTR [ebx+104]
  00194	8b ce		 mov	 ecx, esi
  00196	ff d0		 call	 eax
  00198	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  0019c	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  001a1	85 c0		 test	 eax, eax
  001a3	75 db		 jne	 SHORT $LL11@RenderFore
$LN10@RenderFore:

; 444  : 		}
; 445  : 
; 446  : 		video->SetAmbient(Color::Black);

  001a5	51		 push	 ecx
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Black@Color@@2V1@A ; Color::Black
  001ac	8b c4		 mov	 eax, esp
  001ae	89 08		 mov	 DWORD PTR [eax], ecx
  001b0	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001b3	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b5	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  001bb	ff d0		 call	 eax

; 447  : 		video->SetRenderState(Video::LIGHTING_PASS,     2);

  001bd	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001c0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c2	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  001c8	6a 02		 push	 2
  001ca	6a 0e		 push	 14			; 0000000eH
  001cc	ff d0		 call	 eax

; 448  : 
; 449  : 		// solid items, shadow lights:
; 450  : 		iter.reset();
; 451  : 		while (++iter) {

  001ce	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  001d2	89 7c 24 14	 mov	 DWORD PTR _iter$[esp+28], edi
  001d6	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  001db	85 c0		 test	 eax, eax
  001dd	74 26		 je	 SHORT $LN8@RenderFore
  001df	90		 npad	 1
$LL9@RenderFore:

; 452  : 			Graphic* g = iter.value();
; 453  : 			Render(g, Graphic::RENDER_SOLID | Graphic::RENDER_ADD_LIGHT);

  001e0	8b 3e		 mov	 edi, DWORD PTR [esi]
  001e2	68 01 20 00 00	 push	 8193			; 00002001H
  001e7	8d 4c 24 14	 lea	 ecx, DWORD PTR _iter$[esp+28]
  001eb	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  001f0	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  001f3	50		 push	 eax
  001f4	8b ce		 mov	 ecx, esi
  001f6	ff d2		 call	 edx
  001f8	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  001fc	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00201	85 c0		 test	 eax, eax
  00203	75 db		 jne	 SHORT $LL9@RenderFore
$LN8@RenderFore:

; 463  : 		}
; 464  : 	}
; 465  : 
; 466  : 	video->SetAmbient(scene->Ambient());

  00205	51		 push	 ecx
  00206	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00209	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0020c	8b c4		 mov	 eax, esp
  0020e	89 10		 mov	 DWORD PTR [eax], edx
  00210	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00213	8b 01		 mov	 eax, DWORD PTR [ecx]
  00215	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  0021b	ff d2		 call	 edx

; 467  : 	video->SetRenderState(Video::LIGHTING_PASS,     0);

  0021d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00220	8b 01		 mov	 eax, DWORD PTR [ecx]
  00222	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00228	6a 00		 push	 0
  0022a	6a 0e		 push	 14			; 0000000eH
  0022c	ff d2		 call	 edx

; 468  : 	video->SetRenderState(Video::STENCIL_ENABLE,    FALSE);

  0022e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00231	8b 01		 mov	 eax, DWORD PTR [ecx]
  00233	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00239	6a 00		 push	 0
  0023b	6a 0c		 push	 12			; 0000000cH
  0023d	ff d2		 call	 edx

; 469  : 	video->SetRenderState(Video::Z_ENABLE,          TRUE);

  0023f	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00242	8b 01		 mov	 eax, DWORD PTR [ecx]
  00244	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0024a	6a 01		 push	 1
  0024c	6a 03		 push	 3
  0024e	ff d2		 call	 edx

; 470  : 	video->SetRenderState(Video::Z_WRITE_ENABLE,    FALSE);

  00250	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00253	8b 01		 mov	 eax, DWORD PTR [ecx]
  00255	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0025b	6a 00		 push	 0
  0025d	6a 04		 push	 4
  0025f	ff d2		 call	 edx

; 471  : 
; 472  : 	// blended items:
; 473  : 	iter.reset();
; 474  : 	while (++iter) {

  00261	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  00265	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+28], -1
  0026d	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00272	85 c0		 test	 eax, eax
  00274	74 38		 je	 SHORT $LN3@RenderFore
  00276	8d 5e 58	 lea	 ebx, DWORD PTR [esi+88]
  00279	8d a4 24 00 00
	00 00		 npad	 7
$LL4@RenderFore:

; 475  : 		Graphic* g = iter.value();

  00280	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  00284	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  00289	8b f8		 mov	 edi, eax

; 476  : 		Render(g, Graphic::RENDER_ALPHA);

  0028b	8b 06		 mov	 eax, DWORD PTR [esi]
  0028d	8b 50 68	 mov	 edx, DWORD PTR [eax+104]
  00290	6a 02		 push	 2
  00292	57		 push	 edi
  00293	8b ce		 mov	 ecx, esi
  00295	ff d2		 call	 edx

; 477  : 		g->ProjectScreenRect(&projector);

  00297	8b 07		 mov	 eax, DWORD PTR [edi]
  00299	8b 50 74	 mov	 edx, DWORD PTR [eax+116]
  0029c	53		 push	 ebx
  0029d	8b cf		 mov	 ecx, edi
  0029f	ff d2		 call	 edx
  002a1	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  002a5	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  002aa	85 c0		 test	 eax, eax
  002ac	75 d2		 jne	 SHORT $LL4@RenderFore
$LN3@RenderFore:

; 478  : 	}
; 479  : 
; 480  : 	// glowing items:
; 481  : 	iter.reset();
; 482  : 	while (++iter) {

  002ae	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  002b2	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+28], -1
  002ba	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  002bf	85 c0		 test	 eax, eax
  002c1	74 31		 je	 SHORT $LN1@RenderFore
  002c3	8d 5e 58	 lea	 ebx, DWORD PTR [esi+88]
$LL2@RenderFore:

; 483  : 		Graphic* g = iter.value();

  002c6	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  002ca	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  002cf	8b f8		 mov	 edi, eax

; 484  : 		Render(g, Graphic::RENDER_ADDITIVE);

  002d1	8b 06		 mov	 eax, DWORD PTR [esi]
  002d3	8b 50 68	 mov	 edx, DWORD PTR [eax+104]
  002d6	6a 04		 push	 4
  002d8	57		 push	 edi
  002d9	8b ce		 mov	 ecx, esi
  002db	ff d2		 call	 edx

; 485  : 		g->ProjectScreenRect(&projector);

  002dd	8b 07		 mov	 eax, DWORD PTR [edi]
  002df	8b 50 74	 mov	 edx, DWORD PTR [eax+116]
  002e2	53		 push	 ebx
  002e3	8b cf		 mov	 ecx, edi
  002e5	ff d2		 call	 edx
  002e7	8d 4c 24 10	 lea	 ecx, DWORD PTR _iter$[esp+24]
  002eb	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  002f0	85 c0		 test	 eax, eax
  002f2	75 d2		 jne	 SHORT $LL2@RenderFore
$LN1@RenderFore:

; 486  : 	}
; 487  : }

  002f4	5f		 pop	 edi
  002f5	5e		 pop	 esi
  002f6	5b		 pop	 ebx
  002f7	8b e5		 mov	 esp, ebp
  002f9	5d		 pop	 ebp
  002fa	c3		 ret	 0
?RenderForeground@CameraView@@UAEXXZ ENDP		; CameraView::RenderForeground
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?MarkVisibleLights@CameraView@@UAEXPAVGraphic@@K@Z
_TEXT	SEGMENT
_light_iter$85166 = -8					; size = 8
_graphic$ = 8						; size = 4
_flags$ = 12						; size = 4
?MarkVisibleLights@CameraView@@UAEXPAVGraphic@@K@Z PROC	; CameraView::MarkVisibleLights, COMDAT
; _this$ = ecx

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 334  : 	if (flags < Graphic::RENDER_FIRST_LIGHT) {

  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _flags$[ebp]
  0000e	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  00014	73 06		 jae	 SHORT $LN11@MarkVisibl@2

; 335  : 		flags = flags | Graphic::RENDER_FIRST_LIGHT | Graphic::RENDER_ADD_LIGHT;

  00016	81 cf 00 30 00
	00		 or	 edi, 12288		; 00003000H
$LN11@MarkVisibl@2:

; 336  : 	}
; 337  : 
; 338  : 	if (graphic->IsVisible()) {

  0001c	8b 75 08	 mov	 esi, DWORD PTR _graphic$[ebp]
  0001f	80 7e 34 00	 cmp	 BYTE PTR [esi+52], 0
  00023	0f 84 bf 00 00
	00		 je	 $LN8@MarkVisibl@2

; 339  : 		Vec3 eye = camera->Pos();
; 340  : 
; 341  : 		ListIter<Light> light_iter = scene->Lights();

  00029	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0002c	83 c0 34	 add	 eax, 52			; 00000034H

; 342  : 
; 343  : 		while (++light_iter) {

  0002f	8d 4c 24 08	 lea	 ecx, DWORD PTR _light_iter$85166[esp+16]
  00033	89 44 24 08	 mov	 DWORD PTR _light_iter$85166[esp+16], eax
  00037	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _light_iter$85166[esp+20], -1
  0003f	e8 00 00 00 00	 call	 ?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::next
  00044	85 c0		 test	 eax, eax
  00046	0f 84 9c 00 00
	00		 je	 $LN8@MarkVisibl@2
  0004c	8d 64 24 00	 npad	 4
$LL9@MarkVisibl@2:

; 344  : 			Light* light = light_iter.value();

  00050	8d 4c 24 08	 lea	 ecx, DWORD PTR _light_iter$85166[esp+16]
  00054	e8 00 00 00 00	 call	 ?value@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::value

; 345  : 			bool bright_enough = light->Type()      == Light::LIGHT_DIRECTIONAL ||
; 346  : 			light->Intensity() >= 1e9;

  00059	83 78 0c 03	 cmp	 DWORD PTR [eax+12], 3
  0005d	74 5b		 je	 SHORT $LN14@MarkVisibl@2
  0005f	f3 0f 10 70 2c	 movss	 xmm6, DWORD PTR [eax+44]
  00064	0f 5a c6	 cvtps2pd xmm0, xmm6
  00067	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@41cdcd6500000000
  0006f	73 49		 jae	 SHORT $LN14@MarkVisibl@2

; 347  : 
; 348  : 			if (!bright_enough) {
; 349  : 				Point test = graphic->Location() - light->Location();

  00071	f2 0f 10 4e 18	 movsd	 xmm1, QWORD PTR [esi+24]
  00076	f2 0f 5c 48 18	 subsd	 xmm1, QWORD PTR [eax+24]
  0007b	f2 0f 10 46 10	 movsd	 xmm0, QWORD PTR [esi+16]
  00080	f2 0f 5c 40 10	 subsd	 xmm0, QWORD PTR [eax+16]
  00085	f2 0f 10 56 20	 movsd	 xmm2, QWORD PTR [esi+32]
  0008a	f2 0f 5c 50 20	 subsd	 xmm2, QWORD PTR [eax+32]

; 350  : 				if (test.length() < light->Intensity()*10)

  0008f	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00093	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00097	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0009b	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  0009f	f2 0f 58 ca	 addsd	 xmm1, xmm2
  000a3	f2 0f 51 c1	 sqrtsd	 xmm0, xmm1
  000a7	32 c9		 xor	 cl, cl
  000a9	0f 5a ce	 cvtps2pd xmm1, xmm6
  000ac	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR _DEFAULT_TRACK_AGE
  000b4	66 0f 2f c8	 comisd	 xmm1, xmm0
  000b8	76 02		 jbe	 SHORT $LN6@MarkVisibl@2
$LN14@MarkVisibl@2:

; 351  : 				bright_enough = true;

  000ba	b1 01		 mov	 cl, 1
$LN6@MarkVisibl@2:

; 352  : 			}
; 353  : 
; 354  : 			// turn off lights that won't be used this pass:
; 355  : 			if (light->CastsShadow()) {

  000bc	80 78 39 00	 cmp	 BYTE PTR [eax+57], 0
  000c0	74 08		 je	 SHORT $LN5@MarkVisibl@2

; 356  : 				if ((flags & Graphic::RENDER_ADD_LIGHT) == 0)

  000c2	f7 c7 00 20 00
	00		 test	 edi, 8192		; 00002000H

; 357  : 				bright_enough = false;
; 358  : 			}
; 359  : 			else {

  000c8	eb 06		 jmp	 SHORT $LN61@MarkVisibl@2
$LN5@MarkVisibl@2:

; 360  : 				if ((flags & Graphic::RENDER_FIRST_LIGHT) == 0)

  000ca	f7 c7 00 10 00
	00		 test	 edi, 4096		; 00001000H
$LN61@MarkVisibl@2:
  000d0	75 02		 jne	 SHORT $LN2@MarkVisibl@2

; 361  : 				bright_enough = false;

  000d2	32 c9		 xor	 cl, cl
$LN2@MarkVisibl@2:

; 362  : 			}
; 363  : 
; 364  : 			double obs_radius = graphic->Radius();
; 365  : 			if (obs_radius < 100)
; 366  : 			obs_radius = 100;
; 367  : 
; 368  : 			light->SetActive(bright_enough);

  000d4	88 48 38	 mov	 BYTE PTR [eax+56], cl
  000d7	8d 4c 24 08	 lea	 ecx, DWORD PTR _light_iter$85166[esp+16]
  000db	e8 00 00 00 00	 call	 ?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::next
  000e0	85 c0		 test	 eax, eax
  000e2	0f 85 68 ff ff
	ff		 jne	 $LL9@MarkVisibl@2
$LN8@MarkVisibl@2:

; 369  : 		}
; 370  : 	}
; 371  : }

  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 08 00	 ret	 8
?MarkVisibleLights@CameraView@@UAEXPAVGraphic@@K@Z ENDP	; CameraView::MarkVisibleLights
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?UnTranslateScene@CameraView@@UAEXXZ
_TEXT	SEGMENT
_l_iter$ = -32						; size = 8
_g_iter$ = -32						; size = 8
_reloc$ = -24						; size = 24
?UnTranslateScene@CameraView@@UAEXXZ PROC		; CameraView::UnTranslateScene, COMDAT
; _this$ = ecx

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 24	 sub	 esp, 36			; 00000024H

; 271  : 	Point reloc = -camera_loc;

  00009	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __mask@@NegDouble@
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b f9		 mov	 edi, ecx
  00016	f2 0f 10 4f 18	 movsd	 xmm1, QWORD PTR [edi+24]

; 272  : 
; 273  : 	ListIter<Graphic> g_iter = scene->Graphics();

  0001b	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0001e	8d 5f 18	 lea	 ebx, DWORD PTR [edi+24]
  00021	66 0f 57 c8	 xorpd	 xmm1, xmm0
  00025	f2 0f 11 4c 24
	18		 movsd	 QWORD PTR _reloc$[esp+48], xmm1
  0002b	f2 0f 10 4b 08	 movsd	 xmm1, QWORD PTR [ebx+8]
  00030	66 0f 57 c8	 xorpd	 xmm1, xmm0
  00034	f2 0f 11 4c 24
	20		 movsd	 QWORD PTR _reloc$[esp+56], xmm1
  0003a	f2 0f 10 4b 10	 movsd	 xmm1, QWORD PTR [ebx+16]
  0003f	83 c0 1c	 add	 eax, 28			; 0000001cH
  00042	66 0f 57 c8	 xorpd	 xmm1, xmm0

; 274  : 	while (++g_iter) {

  00046	8d 4c 24 10	 lea	 ecx, DWORD PTR _g_iter$[esp+48]
  0004a	f2 0f 11 4c 24
	28		 movsd	 QWORD PTR _reloc$[esp+64], xmm1
  00050	89 44 24 10	 mov	 DWORD PTR _g_iter$[esp+48], eax
  00054	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _g_iter$[esp+52], -1
  0005c	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00061	85 c0		 test	 eax, eax
  00063	74 33		 je	 SHORT $LN9@UnTranslat
$LL10@UnTranslat:

; 275  : 		Graphic* graphic = g_iter.value();

  00065	8d 4c 24 10	 lea	 ecx, DWORD PTR _g_iter$[esp+48]
  00069	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  0006e	8b f0		 mov	 esi, eax

; 276  : 
; 277  : 		if (!graphic->IsInfinite())

  00070	8b 16		 mov	 edx, DWORD PTR [esi]
  00072	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00075	8b ce		 mov	 ecx, esi
  00077	ff d0		 call	 eax
  00079	85 c0		 test	 eax, eax
  0007b	75 0e		 jne	 SHORT $LN8@UnTranslat

; 278  : 		graphic->TranslateBy(reloc);

  0007d	8b 16		 mov	 edx, DWORD PTR [esi]
  0007f	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00082	8d 44 24 18	 lea	 eax, DWORD PTR _reloc$[esp+48]
  00086	50		 push	 eax
  00087	8b ce		 mov	 ecx, esi
  00089	ff d2		 call	 edx
$LN8@UnTranslat:

; 274  : 	while (++g_iter) {

  0008b	8d 4c 24 10	 lea	 ecx, DWORD PTR _g_iter$[esp+48]
  0008f	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00094	85 c0		 test	 eax, eax
  00096	75 cd		 jne	 SHORT $LL10@UnTranslat
$LN9@UnTranslat:

; 279  : 	}
; 280  : 
; 281  : 	g_iter.attach(scene->Foreground());

  00098	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0009b	83 c0 10	 add	 eax, 16			; 00000010H
  0009e	50		 push	 eax
  0009f	8d 4c 24 14	 lea	 ecx, DWORD PTR _g_iter$[esp+52]
  000a3	e8 00 00 00 00	 call	 ?attach@?$ListIter@VGraphic@@@@QAEXAAV?$List@VGraphic@@@@@Z ; ListIter<Graphic>::attach

; 282  : 	while (++g_iter) {

  000a8	8d 4c 24 10	 lea	 ecx, DWORD PTR _g_iter$[esp+48]
  000ac	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  000b1	85 c0		 test	 eax, eax
  000b3	74 24		 je	 SHORT $LN6@UnTranslat
$LL7@UnTranslat:

; 283  : 		Graphic* graphic = g_iter.value();

  000b5	8d 4c 24 10	 lea	 ecx, DWORD PTR _g_iter$[esp+48]
  000b9	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value

; 284  : 		graphic->TranslateBy(reloc);

  000be	8b 10		 mov	 edx, DWORD PTR [eax]
  000c0	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  000c3	8d 4c 24 18	 lea	 ecx, DWORD PTR _reloc$[esp+48]
  000c7	51		 push	 ecx
  000c8	8b c8		 mov	 ecx, eax
  000ca	ff d2		 call	 edx
  000cc	8d 4c 24 10	 lea	 ecx, DWORD PTR _g_iter$[esp+48]
  000d0	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  000d5	85 c0		 test	 eax, eax
  000d7	75 dc		 jne	 SHORT $LL7@UnTranslat
$LN6@UnTranslat:

; 285  : 	}
; 286  : 
; 287  : 	g_iter.attach(scene->Sprites());

  000d9	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000dc	83 c0 28	 add	 eax, 40			; 00000028H
  000df	50		 push	 eax
  000e0	8d 4c 24 14	 lea	 ecx, DWORD PTR _g_iter$[esp+52]
  000e4	e8 00 00 00 00	 call	 ?attach@?$ListIter@VGraphic@@@@QAEXAAV?$List@VGraphic@@@@@Z ; ListIter<Graphic>::attach

; 288  : 	while (++g_iter) {

  000e9	8d 4c 24 10	 lea	 ecx, DWORD PTR _g_iter$[esp+48]
  000ed	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  000f2	85 c0		 test	 eax, eax
  000f4	74 33		 je	 SHORT $LN4@UnTranslat
$LL5@UnTranslat:

; 289  : 		Graphic* graphic = g_iter.value();

  000f6	8d 4c 24 10	 lea	 ecx, DWORD PTR _g_iter$[esp+48]
  000fa	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  000ff	8b f0		 mov	 esi, eax

; 290  : 
; 291  : 		if (!graphic->IsInfinite())

  00101	8b 16		 mov	 edx, DWORD PTR [esi]
  00103	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00106	8b ce		 mov	 ecx, esi
  00108	ff d0		 call	 eax
  0010a	85 c0		 test	 eax, eax
  0010c	75 0e		 jne	 SHORT $LN3@UnTranslat

; 292  : 		graphic->TranslateBy(reloc);

  0010e	8b 16		 mov	 edx, DWORD PTR [esi]
  00110	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00113	8d 44 24 18	 lea	 eax, DWORD PTR _reloc$[esp+48]
  00117	50		 push	 eax
  00118	8b ce		 mov	 ecx, esi
  0011a	ff d2		 call	 edx
$LN3@UnTranslat:

; 288  : 	while (++g_iter) {

  0011c	8d 4c 24 10	 lea	 ecx, DWORD PTR _g_iter$[esp+48]
  00120	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00125	85 c0		 test	 eax, eax
  00127	75 cd		 jne	 SHORT $LL5@UnTranslat
$LN4@UnTranslat:

; 293  : 	}
; 294  : 
; 295  : 	ListIter<Light> l_iter = scene->Lights();

  00129	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0012c	83 c0 34	 add	 eax, 52			; 00000034H

; 296  : 	while (++l_iter) {

  0012f	8d 4c 24 10	 lea	 ecx, DWORD PTR _l_iter$[esp+48]
  00133	89 44 24 10	 mov	 DWORD PTR _l_iter$[esp+48], eax
  00137	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _l_iter$[esp+52], -1
  0013f	e8 00 00 00 00	 call	 ?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::next
  00144	85 c0		 test	 eax, eax
  00146	74 2c		 je	 SHORT $LN1@UnTranslat
  00148	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL2@UnTranslat:

; 297  : 		Light* light = l_iter.value();

  00150	8d 4c 24 10	 lea	 ecx, DWORD PTR _l_iter$[esp+48]
  00154	e8 00 00 00 00	 call	 ?value@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::value

; 298  : 		light->TranslateBy(reloc);

  00159	8b 10		 mov	 edx, DWORD PTR [eax]
  0015b	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  0015e	8d 4c 24 18	 lea	 ecx, DWORD PTR _reloc$[esp+48]
  00162	51		 push	 ecx
  00163	8b c8		 mov	 ecx, eax
  00165	ff d2		 call	 edx
  00167	8d 4c 24 10	 lea	 ecx, DWORD PTR _l_iter$[esp+48]
  0016b	e8 00 00 00 00	 call	 ?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::next
  00170	85 c0		 test	 eax, eax
  00172	75 dc		 jne	 SHORT $LL2@UnTranslat
$LN1@UnTranslat:

; 299  : 	}
; 300  : 
; 301  : 	camera->MoveTo(camera_loc);

  00174	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00177	53		 push	 ebx
  00178	e8 00 00 00 00	 call	 ?MoveTo@Camera@@QAEXABUPoint@@@Z ; Camera::MoveTo

; 302  : }

  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
?UnTranslateScene@CameraView@@UAEXXZ ENDP		; CameraView::UnTranslateScene
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?TranslateScene@CameraView@@UAEXXZ
_TEXT	SEGMENT
_l_iter$ = -8						; size = 8
_g_iter$ = -8						; size = 8
?TranslateScene@CameraView@@UAEXXZ PROC			; CameraView::TranslateScene, COMDAT
; _this$ = ecx

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx

; 231  : 	camera_loc = camera->Pos();

  0000c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0000f	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  00014	f2 0f 10 48 10	 movsd	 xmm1, QWORD PTR [eax+16]
  00019	f2 0f 10 50 18	 movsd	 xmm2, QWORD PTR [eax+24]

; 232  : 
; 233  : 	ListIter<Graphic> g_iter = scene->Graphics();

  0001e	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00021	56		 push	 esi
  00022	8d 73 18	 lea	 esi, DWORD PTR [ebx+24]
  00025	83 c0 1c	 add	 eax, 28			; 0000001cH
  00028	57		 push	 edi

; 234  : 	while (++g_iter) {

  00029	8d 4c 24 38	 lea	 ecx, DWORD PTR _g_iter$[esp+64]
  0002d	f2 0f 11 06	 movsd	 QWORD PTR [esi], xmm0
  00031	f2 0f 11 4e 08	 movsd	 QWORD PTR [esi+8], xmm1
  00036	f2 0f 11 56 10	 movsd	 QWORD PTR [esi+16], xmm2
  0003b	89 44 24 38	 mov	 DWORD PTR _g_iter$[esp+64], eax
  0003f	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR _g_iter$[esp+68], -1
  00047	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0004c	85 c0		 test	 eax, eax
  0004e	74 2f		 je	 SHORT $LN9@TranslateS
$LL10@TranslateS:

; 235  : 		Graphic* graphic = g_iter.value();

  00050	8d 4c 24 38	 lea	 ecx, DWORD PTR _g_iter$[esp+64]
  00054	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  00059	8b f8		 mov	 edi, eax

; 236  : 
; 237  : 		if (!graphic->IsInfinite())

  0005b	8b 17		 mov	 edx, DWORD PTR [edi]
  0005d	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00060	8b cf		 mov	 ecx, edi
  00062	ff d0		 call	 eax
  00064	85 c0		 test	 eax, eax
  00066	75 0a		 jne	 SHORT $LN8@TranslateS

; 238  : 		graphic->TranslateBy(camera_loc);

  00068	8b 17		 mov	 edx, DWORD PTR [edi]
  0006a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0006d	56		 push	 esi
  0006e	8b cf		 mov	 ecx, edi
  00070	ff d0		 call	 eax
$LN8@TranslateS:

; 234  : 	while (++g_iter) {

  00072	8d 4c 24 38	 lea	 ecx, DWORD PTR _g_iter$[esp+64]
  00076	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0007b	85 c0		 test	 eax, eax
  0007d	75 d1		 jne	 SHORT $LL10@TranslateS
$LN9@TranslateS:

; 239  : 	}
; 240  : 
; 241  : 	g_iter.attach(scene->Foreground());

  0007f	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00082	83 c1 10	 add	 ecx, 16			; 00000010H
  00085	51		 push	 ecx
  00086	8d 4c 24 3c	 lea	 ecx, DWORD PTR _g_iter$[esp+68]
  0008a	e8 00 00 00 00	 call	 ?attach@?$ListIter@VGraphic@@@@QAEXAAV?$List@VGraphic@@@@@Z ; ListIter<Graphic>::attach

; 242  : 	while (++g_iter) {

  0008f	8d 4c 24 38	 lea	 ecx, DWORD PTR _g_iter$[esp+64]
  00093	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  00098	85 c0		 test	 eax, eax
  0009a	74 24		 je	 SHORT $LN6@TranslateS
  0009c	8d 64 24 00	 npad	 4
$LL7@TranslateS:

; 243  : 		Graphic* graphic = g_iter.value();

  000a0	8d 4c 24 38	 lea	 ecx, DWORD PTR _g_iter$[esp+64]
  000a4	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value

; 244  : 		graphic->TranslateBy(camera_loc);

  000a9	8b 10		 mov	 edx, DWORD PTR [eax]
  000ab	8b c8		 mov	 ecx, eax
  000ad	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000b0	56		 push	 esi
  000b1	ff d0		 call	 eax
  000b3	8d 4c 24 38	 lea	 ecx, DWORD PTR _g_iter$[esp+64]
  000b7	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  000bc	85 c0		 test	 eax, eax
  000be	75 e0		 jne	 SHORT $LL7@TranslateS
$LN6@TranslateS:

; 245  : 	}
; 246  : 
; 247  : 	g_iter.attach(scene->Sprites());

  000c0	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  000c3	83 c1 28	 add	 ecx, 40			; 00000028H
  000c6	51		 push	 ecx
  000c7	8d 4c 24 3c	 lea	 ecx, DWORD PTR _g_iter$[esp+68]
  000cb	e8 00 00 00 00	 call	 ?attach@?$ListIter@VGraphic@@@@QAEXAAV?$List@VGraphic@@@@@Z ; ListIter<Graphic>::attach

; 248  : 	while (++g_iter) {

  000d0	8d 4c 24 38	 lea	 ecx, DWORD PTR _g_iter$[esp+64]
  000d4	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  000d9	85 c0		 test	 eax, eax
  000db	74 32		 je	 SHORT $LN4@TranslateS
  000dd	8d 49 00	 npad	 3
$LL5@TranslateS:

; 249  : 		Graphic* graphic = g_iter.value();

  000e0	8d 4c 24 38	 lea	 ecx, DWORD PTR _g_iter$[esp+64]
  000e4	e8 00 00 00 00	 call	 ?value@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::value
  000e9	8b f8		 mov	 edi, eax

; 250  : 
; 251  : 		if (!graphic->IsInfinite())

  000eb	8b 17		 mov	 edx, DWORD PTR [edi]
  000ed	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000f0	8b cf		 mov	 ecx, edi
  000f2	ff d0		 call	 eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 0a		 jne	 SHORT $LN3@TranslateS

; 252  : 		graphic->TranslateBy(camera_loc);

  000f8	8b 17		 mov	 edx, DWORD PTR [edi]
  000fa	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000fd	56		 push	 esi
  000fe	8b cf		 mov	 ecx, edi
  00100	ff d0		 call	 eax
$LN3@TranslateS:

; 248  : 	while (++g_iter) {

  00102	8d 4c 24 38	 lea	 ecx, DWORD PTR _g_iter$[esp+64]
  00106	e8 00 00 00 00	 call	 ?next@?$ListIter@VGraphic@@@@QAEPAVGraphic@@XZ ; ListIter<Graphic>::next
  0010b	85 c0		 test	 eax, eax
  0010d	75 d1		 jne	 SHORT $LL5@TranslateS
$LN4@TranslateS:

; 253  : 	}
; 254  : 
; 255  : 	ListIter<Light> l_iter = scene->Lights();

  0010f	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00112	83 c1 34	 add	 ecx, 52			; 00000034H
  00115	89 4c 24 38	 mov	 DWORD PTR _l_iter$[esp+64], ecx

; 256  : 	while (++l_iter) {

  00119	8d 4c 24 38	 lea	 ecx, DWORD PTR _l_iter$[esp+64]
  0011d	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR _l_iter$[esp+68], -1
  00125	e8 00 00 00 00	 call	 ?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::next
  0012a	85 c0		 test	 eax, eax
  0012c	74 22		 je	 SHORT $LN1@TranslateS
  0012e	8b ff		 npad	 2
$LL2@TranslateS:

; 257  : 		Light* light = l_iter.value();

  00130	8d 4c 24 38	 lea	 ecx, DWORD PTR _l_iter$[esp+64]
  00134	e8 00 00 00 00	 call	 ?value@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::value

; 258  : 		light->TranslateBy(camera_loc);

  00139	8b 10		 mov	 edx, DWORD PTR [eax]
  0013b	8b c8		 mov	 ecx, eax
  0013d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00140	56		 push	 esi
  00141	ff d0		 call	 eax
  00143	8d 4c 24 38	 lea	 ecx, DWORD PTR _l_iter$[esp+64]
  00147	e8 00 00 00 00	 call	 ?next@?$ListIter@VLight@@@@QAEPAVLight@@XZ ; ListIter<Light>::next
  0014c	85 c0		 test	 eax, eax
  0014e	75 e0		 jne	 SHORT $LL2@TranslateS
$LN1@TranslateS:

; 259  : 	}
; 260  : 
; 261  : 	camera->MoveTo(0,0,0);

  00150	0f 57 c0	 xorps	 xmm0, xmm0
  00153	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00156	83 ec 18	 sub	 esp, 24			; 00000018H
  00159	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  0015f	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  00165	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0016a	e8 00 00 00 00	 call	 ?MoveTo@Camera@@QAEXNNN@Z ; Camera::MoveTo

; 262  : }

  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	5b		 pop	 ebx
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
?TranslateScene@CameraView@@UAEXXZ ENDP			; CameraView::TranslateScene
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Refresh@CameraView@@UAEXXZ
_TEXT	SEGMENT
tv451 = -20						; size = 4
_old_rect$ = -16					; size = 16
?Refresh@CameraView@@UAEXXZ PROC			; CameraView::Refresh, COMDAT
; _this$ = ecx

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 186  : 	// disabled:
; 187  : 	if (camera == &emergency_cam)

  0000c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000f	57		 push	 edi
  00010	3d 00 00 00 00	 cmp	 eax, OFFSET _emergency_cam
  00015	0f 84 82 01 00
	00		 je	 $LN3@Refresh

; 188  : 	return;
; 189  : 
; 190  : 	// prologue:
; 191  : 	video = Video::GetInstance();

  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?video_instance@Video@@1PAV1@A ; Video::video_instance

; 192  : 	if (!video)

  00021	33 ff		 xor	 edi, edi
  00023	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00026	3b cf		 cmp	 ecx, edi
  00028	0f 84 6f 01 00
	00		 je	 $LN3@Refresh

; 193  : 	return;
; 194  : 
; 195  : 	int cw = window->Width();
; 196  : 	int ch = window->Height();
; 197  : 
; 198  : 	cvrt = camera->vrt();

  0002e	f2 0f 10 40 20	 movsd	 xmm0, QWORD PTR [eax+32]
  00033	f2 0f 10 48 28	 movsd	 xmm1, QWORD PTR [eax+40]
  00038	f2 0f 10 50 30	 movsd	 xmm2, QWORD PTR [eax+48]
  0003d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00041	f3 0f 11 46 30	 movss	 DWORD PTR [esi+48], xmm0
  00046	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  0004a	f3 0f 11 4e 34	 movss	 DWORD PTR [esi+52], xmm1
  0004f	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  00053	f3 0f 11 56 38	 movss	 DWORD PTR [esi+56], xmm2

; 199  : 	cvup = camera->vup();

  00058	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005b	f2 0f 10 40 38	 movsd	 xmm0, QWORD PTR [eax+56]
  00060	f2 0f 10 48 40	 movsd	 xmm1, QWORD PTR [eax+64]
  00065	f2 0f 10 50 48	 movsd	 xmm2, QWORD PTR [eax+72]
  0006a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0006e	f3 0f 11 46 3c	 movss	 DWORD PTR [esi+60], xmm0
  00073	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00077	f3 0f 11 4e 40	 movss	 DWORD PTR [esi+64], xmm1
  0007c	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  00080	f3 0f 11 56 44	 movss	 DWORD PTR [esi+68], xmm2

; 200  : 	cvpn = camera->vpn();

  00085	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00088	f2 0f 10 40 50	 movsd	 xmm0, QWORD PTR [eax+80]
  0008d	f2 0f 10 48 58	 movsd	 xmm1, QWORD PTR [eax+88]
  00092	f2 0f 10 50 60	 movsd	 xmm2, QWORD PTR [eax+96]
  00097	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0009b	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  0009f	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  000a3	f3 0f 11 46 48	 movss	 DWORD PTR [esi+72], xmm0
  000a8	f3 0f 11 4e 4c	 movss	 DWORD PTR [esi+76], xmm1
  000ad	f3 0f 11 56 50	 movss	 DWORD PTR [esi+80], xmm2

; 201  : 
; 202  : 	TranslateScene();

  000b2	8b 16		 mov	 edx, DWORD PTR [esi]
  000b4	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000b7	8b ce		 mov	 ecx, esi
  000b9	ff d0		 call	 eax

; 203  : 	MarkVisibleObjects();

  000bb	8b 16		 mov	 edx, DWORD PTR [esi]
  000bd	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  000c0	8b ce		 mov	 ecx, esi
  000c2	ff d0		 call	 eax

; 204  : 
; 205  : 	Rect old_rect;
; 206  : 	video->GetWindowRect(old_rect);

  000c4	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000c7	89 7c 24 10	 mov	 DWORD PTR _old_rect$[esp+32], edi
  000cb	89 7c 24 14	 mov	 DWORD PTR _old_rect$[esp+36], edi
  000cf	89 7c 24 18	 mov	 DWORD PTR _old_rect$[esp+40], edi
  000d3	89 7c 24 1c	 mov	 DWORD PTR _old_rect$[esp+44], edi
  000d7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d9	8b 92 88 00 00
	00		 mov	 edx, DWORD PTR [edx+136]
  000df	8d 44 24 10	 lea	 eax, DWORD PTR _old_rect$[esp+32]
  000e3	50		 push	 eax
  000e4	ff d2		 call	 edx

; 207  : 
; 208  : 	video->SetCamera(camera);

  000e6	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000e9	8b 01		 mov	 eax, DWORD PTR [ecx]
  000eb	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ee	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [eax+148]
  000f4	52		 push	 edx
  000f5	ff d0		 call	 eax

; 209  : 	video->SetWindowRect(window->GetRect());

  000f7	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000fa	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000fd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ff	8b 92 8c 00 00
	00		 mov	 edx, DWORD PTR [edx+140]
  00105	83 c0 04	 add	 eax, 4
  00108	50		 push	 eax
  00109	ff d2		 call	 edx

; 210  : 	video->SetProjection((float) GetFieldOfView(), 1.0f, 1.0e6f, projection_type);

  0010b	8b 8e 5c 01 00
	00		 mov	 ecx, DWORD PTR [esi+348]
  00111	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00114	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@49742400
  0011c	8b 16		 mov	 edx, DWORD PTR [esi]
  0011e	8b 38		 mov	 edi, DWORD PTR [eax]
  00120	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00123	51		 push	 ecx
  00124	83 ec 08	 sub	 esp, 8
  00127	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0012d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00135	8b ce		 mov	 ecx, esi
  00137	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013c	ff d0		 call	 eax
  0013e	d9 5c 24 18	 fstp	 DWORD PTR tv451[esp+44]
  00142	d9 44 24 18	 fld	 DWORD PTR tv451[esp+44]
  00146	8b 97 98 00 00
	00		 mov	 edx, DWORD PTR [edi+152]
  0014c	51		 push	 ecx
  0014d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00150	d9 1c 24	 fstp	 DWORD PTR [esp]
  00153	ff d2		 call	 edx

; 211  : 
; 212  : 	// project and render:
; 213  : 	RenderBackground();

  00155	8b 06		 mov	 eax, DWORD PTR [esi]
  00157	8b 50 5c	 mov	 edx, DWORD PTR [eax+92]
  0015a	8b ce		 mov	 ecx, esi
  0015c	ff d2		 call	 edx

; 214  : 	RenderScene();

  0015e	8b 06		 mov	 eax, DWORD PTR [esi]
  00160	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  00163	8b ce		 mov	 ecx, esi
  00165	ff d2		 call	 edx

; 215  : 	RenderForeground();

  00167	8b 06		 mov	 eax, DWORD PTR [esi]
  00169	8b 50 58	 mov	 edx, DWORD PTR [eax+88]
  0016c	8b ce		 mov	 ecx, esi
  0016e	ff d2		 call	 edx

; 216  : 	RenderSprites();

  00170	8b 06		 mov	 eax, DWORD PTR [esi]
  00172	8b 50 60	 mov	 edx, DWORD PTR [eax+96]
  00175	8b ce		 mov	 ecx, esi
  00177	ff d2		 call	 edx

; 217  : 	RenderLensFlare();

  00179	8b 06		 mov	 eax, DWORD PTR [esi]
  0017b	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  0017e	8b ce		 mov	 ecx, esi
  00180	ff d2		 call	 edx

; 218  : 
; 219  : 	UnTranslateScene();

  00182	8b 06		 mov	 eax, DWORD PTR [esi]
  00184	8b 50 44	 mov	 edx, DWORD PTR [eax+68]
  00187	8b ce		 mov	 ecx, esi
  00189	ff d2		 call	 edx

; 220  : 
; 221  : 	video->SetWindowRect(old_rect);

  0018b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0018e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00190	8b 80 8c 00 00
	00		 mov	 eax, DWORD PTR [eax+140]
  00196	8d 54 24 10	 lea	 edx, DWORD PTR _old_rect$[esp+32]
  0019a	52		 push	 edx
  0019b	ff d0		 call	 eax
$LN3@Refresh:

; 222  : }

  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c3		 ret	 0
?Refresh@CameraView@@UAEXXZ ENDP			; CameraView::Refresh
_TEXT	ENDS
PUBLIC	__real@60ad78ec
;	COMDAT __real@60ad78ec
; File c:\matrix games\dev\ngenex\geometry.h
CONST	SEGMENT
__real@60ad78ec DD 060ad78ecr			; 1e+020
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\cameraview.cpp
CONST	ENDS
;	COMDAT ?FindDepth@CameraView@@UAEXPAVGraphic@@@Z
_TEXT	SEGMENT
_g$ = 8							; size = 4
?FindDepth@CameraView@@UAEXPAVGraphic@@@Z PROC		; CameraView::FindDepth, COMDAT
; _this$ = ecx

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 168  : 	if (infinite) {

  00006	83 b9 50 01 00
	00 00		 cmp	 DWORD PTR [ecx+336], 0
  0000d	74 1e		 je	 SHORT $LN1@FindDepth

; 169  : 		g->SetDepth(1.0e20f);

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]

; 178  : 	g->SetDepth(z);

  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@60ad78ec
  0001c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0001f	51		 push	 ecx
  00020	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00025	ff d2		 call	 edx

; 179  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN1@FindDepth:

; 170  : 		return;
; 171  : 	}
; 172  : 
; 173  : 	// Translate into a viewpoint-relative coordinate
; 174  : 	Vec3 loc = g->Location() - camera->Pos();

  0002d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _g$[ebp]
  00033	f2 0f 10 49 18	 movsd	 xmm1, QWORD PTR [ecx+24]
  00038	f2 0f 5c 48 10	 subsd	 xmm1, QWORD PTR [eax+16]

; 175  : 
; 176  : 	// Rotate into the view orientation
; 177  : 	float z = (float) (loc * camera->vpn());

  0003d	f2 0f 10 60 58	 movsd	 xmm4, QWORD PTR [eax+88]
  00042	f2 0f 10 41 10	 movsd	 xmm0, QWORD PTR [ecx+16]
  00047	f2 0f 5c 40 08	 subsd	 xmm0, QWORD PTR [eax+8]
  0004c	f2 0f 10 58 50	 movsd	 xmm3, QWORD PTR [eax+80]
  00051	f2 0f 10 51 20	 movsd	 xmm2, QWORD PTR [ecx+32]
  00056	f2 0f 5c 50 18	 subsd	 xmm2, QWORD PTR [eax+24]
  0005b	f2 0f 10 68 60	 movsd	 xmm5, QWORD PTR [eax+96]

; 178  : 	g->SetDepth(z);

  00060	8b 01		 mov	 eax, DWORD PTR [ecx]
  00062	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00065	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00069	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  0006d	66 0f 5a e4	 cvtpd2ps xmm4, xmm4
  00071	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00075	f3 0f 5a e4	 cvtss2sd xmm4, xmm4
  00079	f2 0f 59 e1	 mulsd	 xmm4, xmm1
  0007d	0f 57 c9	 xorps	 xmm1, xmm1
  00080	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00084	66 0f 5a db	 cvtpd2ps xmm3, xmm3
  00088	f3 0f 5a cb	 cvtss2sd xmm1, xmm3
  0008c	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00090	f2 0f 58 e1	 addsd	 xmm4, xmm1
  00094	0f 57 c0	 xorps	 xmm0, xmm0
  00097	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  0009b	66 0f 5a ed	 cvtpd2ps xmm5, xmm5
  0009f	f3 0f 5a c5	 cvtss2sd xmm0, xmm5
  000a3	0f 57 c9	 xorps	 xmm1, xmm1
  000a6	f3 0f 5a ca	 cvtss2sd xmm1, xmm2
  000aa	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  000ae	f2 0f 58 e0	 addsd	 xmm4, xmm0
  000b2	51		 push	 ecx
  000b3	66 0f 5a c4	 cvtpd2ps xmm0, xmm4
  000b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bc	ff d2		 call	 edx

; 179  : }

  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 04 00	 ret	 4
?FindDepth@CameraView@@UAEXPAVGraphic@@@Z ENDP		; CameraView::FindDepth
	ORG $+7757
_DEGREES DQ	03f91df46a2529d39r		; 0.0174533
; Function compile flags: /Ogtp
;	COMDAT ??__Eemergency_cam@@YAXXZ
text$yc	SEGMENT
??__Eemergency_cam@@YAXXZ PROC				; `dynamic initializer for 'emergency_cam'', COMDAT

; 36   : static Camera  emergency_cam;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	83 ec 18	 sub	 esp, 24			; 00000018H
  0000c	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  00012	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET _emergency_cam
  0001d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00022	e8 00 00 00 00	 call	 ??0Camera@@QAE@NNN@Z	; Camera::Camera
  00027	68 00 00 00 00	 push	 OFFSET ??__Femergency_cam@@YAXXZ ; `dynamic atexit destructor for 'emergency_cam''
  0002c	e8 00 00 00 00	 call	 _atexit
  00031	83 c4 04	 add	 esp, 4
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??__Eemergency_cam@@YAXXZ ENDP				; `dynamic initializer for 'emergency_cam''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Eemergency_scene@@YAXXZ
text$yc	SEGMENT
??__Eemergency_scene@@YAXXZ PROC			; `dynamic initializer for 'emergency_scene'', COMDAT

; 37   : static Scene   emergency_scene;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET _emergency_scene
  00005	e8 00 00 00 00	 call	 ??0Scene@@QAE@XZ	; Scene::Scene
  0000a	68 00 00 00 00	 push	 OFFSET ??__Femergency_scene@@YAXXZ ; `dynamic atexit destructor for 'emergency_scene''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eemergency_scene@@YAXXZ ENDP			; `dynamic initializer for 'emergency_scene''
; Function compile flags: /Ogtp
;	COMDAT ??__Femergency_scene@@YAXXZ
text$yd	SEGMENT
??__Femergency_scene@@YAXXZ PROC			; `dynamic atexit destructor for 'emergency_scene'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET _emergency_scene
  00005	e9 00 00 00 00	 jmp	 ??1Scene@@UAE@XZ	; Scene::~Scene
??__Femergency_scene@@YAXXZ ENDP			; `dynamic atexit destructor for 'emergency_scene''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Femergency_cam@@YAXXZ
text$yd	SEGMENT
??__Femergency_cam@@YAXXZ PROC				; `dynamic atexit destructor for 'emergency_cam'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET _emergency_cam
  00005	e9 00 00 00 00	 jmp	 ??1Camera@@UAE@XZ	; Camera::~Camera
??__Femergency_cam@@YAXXZ ENDP				; `dynamic atexit destructor for 'emergency_cam''
_emergency_cam DB 068H DUP (?)
_emergency_scene DB 044H DUP (?)
_emergency_cam$initializer$ DD FLAT:??__Eemergency_cam@@YAXXZ
_emergency_scene$initializer$ DD FLAT:??__Eemergency_scene@@YAXXZ
END
