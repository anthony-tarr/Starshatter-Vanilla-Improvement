; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Matrix Games\Dev\Stars45\Sim.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4Resource@@6B@				; Resource::`RTTI Complete Object Locator'
PUBLIC	??_R4Bitmap@@6B@				; Bitmap::`RTTI Complete Object Locator'
PUBLIC	??_R3Bitmap@@8					; Bitmap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Bitmap@@8					; Bitmap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Resource@@8			; Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3Resource@@8				; Resource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Resource@@8				; Resource::`RTTI Base Class Array'
PUBLIC	??_R0?AVResource@@@8				; Resource `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@Bitmap@@8				; Bitmap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVBitmap@@@8				; Bitmap `RTTI Type Descriptor'
PUBLIC	?InsertObject@SimRegion@@UAEXPAVShip@@@Z	; SimRegion::InsertObject
PUBLIC	?InsertObject@SimRegion@@UAEXPAVShot@@@Z	; SimRegion::InsertObject
PUBLIC	?InsertObject@SimRegion@@UAEXPAVExplosion@@@Z	; SimRegion::InsertObject
PUBLIC	?InsertObject@SimRegion@@UAEXPAVDebris@@@Z	; SimRegion::InsertObject
PUBLIC	?InsertObject@SimRegion@@UAEXPAVAsteroid@@@Z	; SimRegion::InsertObject
PUBLIC	?FindShotByObjID@SimRegion@@UAEPAVShot@@K@Z	; SimRegion::FindShotByObjID
PUBLIC	?FindShipByObjID@SimRegion@@UAEPAVShip@@K@Z	; SimRegion::FindShipByObjID
PUBLIC	?ExecFrame@SimRegion@@UAEXN@Z			; SimRegion::ExecFrame
PUBLIC	?Deactivate@SimRegion@@UAEXXZ			; SimRegion::Deactivate
PUBLIC	?Activate@SimRegion@@UAEXXZ			; SimRegion::Activate
PUBLIC	??_R4SimRegion@@6B@				; SimRegion::`RTTI Complete Object Locator'
PUBLIC	??_R3SimRegion@@8				; SimRegion::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimRegion@@8				; SimRegion::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimRegion@@8			; SimRegion::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSimRegion@@@8				; SimRegion `RTTI Type Descriptor'
PUBLIC	?FindShotByObjID@Sim@@UAEPAVShot@@K@Z		; Sim::FindShotByObjID
PUBLIC	?FindShipByObjID@Sim@@UAEPAVShip@@K@Z		; Sim::FindShipByObjID
PUBLIC	?ExecFrame@Sim@@UAEXN@Z				; Sim::ExecFrame
PUBLIC	??_R4Sim@@6B@					; Sim::`RTTI Complete Object Locator'
PUBLIC	??_R3Sim@@8					; Sim::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Sim@@8					; Sim::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Sim@@8				; Sim::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSim@@@8					; Sim `RTTI Type Descriptor'
PUBLIC	??_R4Universe@@6B@				; Universe::`RTTI Complete Object Locator'
PUBLIC	??_R3Universe@@8				; Universe::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Universe@@8				; Universe::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Universe@@8			; Universe::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVUniverse@@@8				; Universe `RTTI Type Descriptor'
PUBLIC	??0Universe@@QAE@XZ				; Universe::Universe
PUBLIC	??0?$List@VSimHyper@@@@QAE@XZ			; List<SimHyper>::List<SimHyper>
PUBLIC	??0?$List@VSimSplash@@@@QAE@XZ			; List<SimSplash>::List<SimSplash>
PUBLIC	?ExecFrame@Universe@@UAEXN@Z			; Universe::ExecFrame
PUBLIC	??_GUniverse@@UAEPAXI@Z				; Universe::`scalar deleting destructor'
PUBLIC	??1Universe@@UAE@XZ				; Universe::~Universe
PUBLIC	??1?$List@VSimHyper@@@@QAE@XZ			; List<SimHyper>::~List<SimHyper>
PUBLIC	??1?$List@VSimSplash@@@@QAE@XZ			; List<SimSplash>::~List<SimSplash>
PUBLIC	??_GSim@@UAEPAXI@Z				; Sim::`scalar deleting destructor'
PUBLIC	?GetCombatGroup@ShipStats@@QBEPAVCombatGroup@@XZ ; ShipStats::GetCombatGroup
PUBLIC	?GetElementIndex@ShipStats@@QBEHXZ		; ShipStats::GetElementIndex
PUBLIC	?IsPlayer@ShipStats@@QBE_NXZ			; ShipStats::IsPlayer
PUBLIC	?destroy@?$List@VSimRegion@@@@QAEXXZ		; List<SimRegion>::destroy
PUBLIC	?destroy@?$List@VElement@@@@QAEXXZ		; List<Element>::destroy
PUBLIC	??8Model@@QBEHABV0@@Z				; Model::operator==
PUBLIC	?index@?$List@VModel@@@@QBEHPBVModel@@@Z	; List<Model>::index
PUBLIC	?contains@?$List@VModel@@@@QBE_NPBVModel@@@Z	; List<Model>::contains
PUBLIC	??0?$ListIter@VModel@@@@QAE@AAV?$List@VModel@@@@@Z ; ListIter<Model>::ListIter<Model>
PUBLIC	?next@?$ListIter@VModel@@@@QAEPAVModel@@XZ	; ListIter<Model>::next
PUBLIC	??E?$ListIter@VModel@@@@QAEHXZ			; ListIter<Model>::operator++
PUBLIC	?value@?$ListIter@VModel@@@@QAEPAVModel@@XZ	; ListIter<Model>::value
PUBLIC	?Dust@Starshatter@@QAEHXZ			; Starshatter::Dust
PUBLIC	?NumDust@StarSystem@@QBEHXZ			; StarSystem::NumDust
PUBLIC	?Stardate@Mission@@QBENXZ			; Mission::Stardate
PUBLIC	?Links@OrbitalRegion@@QAEAAV?$List@VText@@@@XZ	; OrbitalRegion::Links
PUBLIC	?SetShipClass@ShipStats@@QAEXH@Z		; ShipStats::SetShipClass
PUBLIC	?SetInvulnerable@Ship@@QAEX_N@Z			; Ship::SetInvulnerable
PUBLIC	?UseSkin@Ship@@QAEXPBVSkin@@@Z			; Ship::UseSkin
PUBLIC	?SetPlayer@Element@@QAEXH@Z			; Element::SetPlayer
PUBLIC	?SetRogue@Element@@QAEX_N@Z			; Element::SetRogue
PUBLIC	?SetPlayable@Element@@QAEX_N@Z			; Element::SetPlayable
PUBLIC	?SetCommandAILevel@Element@@QAEXH@Z		; Element::SetCommandAILevel
PUBLIC	?SetCount@Element@@QAEXH@Z			; Element::SetCount
PUBLIC	?IsRogue@MissionElement@@QBE_NXZ		; MissionElement::IsRogue
PUBLIC	?IsInvulnerable@MissionElement@@QBE_NXZ		; MissionElement::IsInvulnerable
PUBLIC	?GetSkin@MissionShip@@QBEPBVSkin@@XZ		; MissionShip::GetSkin
PUBLIC	??D?$ListIter@VText@@@@QAEAAVText@@XZ		; ListIter<Text>::operator*
PUBLIC	??_GResource@@UAEPAXI@Z				; Resource::`scalar deleting destructor'
PUBLIC	??0Resource@@QAE@ABV0@@Z			; Resource::Resource
PUBLIC	??_GBitmap@@UAEPAXI@Z				; Bitmap::`scalar deleting destructor'
PUBLIC	??0Bitmap@@QAE@ABV0@@Z				; Bitmap::Bitmap
PUBLIC	??0MissionEvent@@QAE@ABV0@@Z			; MissionEvent::MissionEvent
PUBLIC	?remove@?$List@VElement@@@@QAEPAVElement@@PBV2@@Z ; List<Element>::remove
PUBLIC	?at@?$List@VElement@@@@QAEAAPAVElement@@H@Z	; List<Element>::at
PUBLIC	?GetAssignment@Element@@QBEPAV1@XZ		; Element::GetAssignment
PUBLIC	?resize@?$List@VSimSplash@@@@AAEXH@Z		; List<SimSplash>::resize
PUBLIC	?append@?$List@VSimSplash@@@@QAEXPBVSimSplash@@@Z ; List<SimSplash>::append
PUBLIC	??0SimSplash@@QAE@PAVSimRegion@@ABUPoint@@NN@Z	; SimSplash::SimSplash
PUBLIC	?GetPlayerShip@SimRegion@@QAEPAVShip@@XZ	; SimRegion::GetPlayerShip
PUBLIC	??A?$List@VElement@@@@QAEAAPAVElement@@H@Z	; List<Element>::operator[]
PUBLIC	?resize@?$List@VSimHyper@@@@AAEXH@Z		; List<SimHyper>::resize
PUBLIC	?append@?$List@VSimHyper@@@@QAEXPBVSimHyper@@@Z	; List<SimHyper>::append
PUBLIC	??0SimHyper@@QAE@PAVShip@@PAVSimRegion@@ABUPoint@@H_N00@Z ; SimHyper::SimHyper
PUBLIC	?removeIndex@?$List@VSimRegion@@@@QAEPAVSimRegion@@H@Z ; List<SimRegion>::removeIndex
PUBLIC	?clear@?$List@VSimRegion@@@@QAEXXZ		; List<SimRegion>::clear
PUBLIC	?isEmpty@?$List@VSimRegion@@@@QBE_NXZ		; List<SimRegion>::isEmpty
PUBLIC	??C?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ	; ListIter<SimRegion>::operator->
PUBLIC	?TYPENAME@SimObserver@@SAPBDXZ			; SimObserver::TYPENAME
PUBLIC	?check@?$List@VElement@@@@ABE_NAAH@Z		; List<Element>::check
PUBLIC	?removeIndex@?$List@VElement@@@@QAEPAVElement@@H@Z ; List<Element>::removeIndex
PUBLIC	?removeItem@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::removeItem
PUBLIC	?Roll@Physical@@QBENXZ				; Physical::Roll
PUBLIC	?Pitch@Physical@@QBENXZ				; Physical::Pitch
PUBLIC	?Yaw@Physical@@QBENXZ				; Physical::Yaw
PUBLIC	??A?$List@VSimRegion@@@@QAEAAPAVSimRegion@@H@Z	; List<SimRegion>::operator[]
PUBLIC	?destroy@?$List@VSimHyper@@@@QAEXXZ		; List<SimHyper>::destroy
PUBLIC	?size@?$List@VSimHyper@@@@QBEHXZ		; List<SimHyper>::size
PUBLIC	??0?$ListIter@VSimHyper@@@@QAE@AAV?$List@VSimHyper@@@@@Z ; ListIter<SimHyper>::ListIter<SimHyper>
PUBLIC	?next@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ ; ListIter<SimHyper>::next
PUBLIC	??E?$ListIter@VSimHyper@@@@QAEHXZ		; ListIter<SimHyper>::operator++
PUBLIC	?value@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ ; ListIter<SimHyper>::value
PUBLIC	??1SimSplash@@QAE@XZ				; SimSplash::~SimSplash
PUBLIC	??_GSimSplash@@QAEPAXI@Z			; SimSplash::`scalar deleting destructor'
PUBLIC	?destroy@?$List@VSimSplash@@@@QAEXXZ		; List<SimSplash>::destroy
PUBLIC	?size@?$List@VSimSplash@@@@QBEHXZ		; List<SimSplash>::size
PUBLIC	??0?$ListIter@VSimSplash@@@@QAE@AAV?$List@VSimSplash@@@@@Z ; ListIter<SimSplash>::ListIter<SimSplash>
PUBLIC	?next@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ ; ListIter<SimSplash>::next
PUBLIC	??E?$ListIter@VSimSplash@@@@QAEHXZ		; ListIter<SimSplash>::operator++
PUBLIC	?value@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ ; ListIter<SimSplash>::value
PUBLIC	?IsPending@MissionEvent@@QBE_NXZ		; MissionEvent::IsPending
PUBLIC	?IsActive@MissionEvent@@QBE_NXZ			; MissionEvent::IsActive
PUBLIC	?Player@Element@@QBEHXZ				; Element::Player
PUBLIC	?IsRogue@Element@@QBE_NXZ			; Element::IsRogue
PUBLIC	?IsPlayable@Element@@QBE_NXZ			; Element::IsPlayable
PUBLIC	?GetCommandAILevel@Element@@QBEHXZ		; Element::GetCommandAILevel
PUBLIC	?GetSquadron@Element@@QBEABVText@@XZ		; Element::GetSquadron
PUBLIC	?GetCount@Element@@QBEHXZ			; Element::GetCount
PUBLIC	?SetPath@MissionElement@@QAEXPBD@Z		; MissionElement::SetPath
PUBLIC	?SetRogue@MissionElement@@QAEX_N@Z		; MissionElement::SetRogue
PUBLIC	?SetZoneLock@MissionElement@@QAEXH@Z		; MissionElement::SetZoneLock
PUBLIC	?AddInstruction@MissionElement@@QAEXPBD@Z	; MissionElement::AddInstruction
PUBLIC	?SetDecoys@MissionShip@@QAEXH@Z			; MissionShip::SetDecoys
PUBLIC	?SetProbes@MissionShip@@QAEXH@Z			; MissionShip::SetProbes
PUBLIC	??0?$List@VDrone@@@@QAE@XZ			; List<Drone>::List<Drone>
PUBLIC	??0?$List@VExplosion@@@@QAE@XZ			; List<Explosion>::List<Explosion>
PUBLIC	??0?$List@VDebris@@@@QAE@XZ			; List<Debris>::List<Debris>
PUBLIC	??0?$List@VAsteroid@@@@QAE@XZ			; List<Asteroid>::List<Asteroid>
PUBLIC	?System@Orbital@@QBEPAVStarSystem@@XZ		; Orbital::System
PUBLIC	?Asteroids@OrbitalRegion@@QBEHXZ		; OrbitalRegion::Asteroids
PUBLIC	?destroy@?$List@VShip@@@@QAEXXZ			; List<Ship>::destroy
PUBLIC	?destroy@?$List@VShot@@@@QAEXXZ			; List<Shot>::destroy
PUBLIC	??1?$List@VDrone@@@@QAE@XZ			; List<Drone>::~List<Drone>
PUBLIC	??1?$List@VExplosion@@@@QAE@XZ			; List<Explosion>::~List<Explosion>
PUBLIC	?destroy@?$List@VExplosion@@@@QAEXXZ		; List<Explosion>::destroy
PUBLIC	??1?$List@VDebris@@@@QAE@XZ			; List<Debris>::~List<Debris>
PUBLIC	?destroy@?$List@VDebris@@@@QAEXXZ		; List<Debris>::destroy
PUBLIC	??1?$List@VAsteroid@@@@QAE@XZ			; List<Asteroid>::~List<Asteroid>
PUBLIC	?destroy@?$List@VAsteroid@@@@QAEXXZ		; List<Asteroid>::destroy
PUBLIC	??_GSimRegion@@UAEPAXI@Z			; SimRegion::`scalar deleting destructor'
PUBLIC	??C?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ	; ListIter<Explosion>::operator->
PUBLIC	??C?$ListIter@VDebris@@@@QAEPAVDebris@@XZ	; ListIter<Debris>::operator->
PUBLIC	?GetMaxFrameLength@Game@@SANXZ			; Game::GetMaxFrameLength
PUBLIC	??C?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ	; ListIter<Asteroid>::operator->
PUBLIC	?SetAIMode@Ship@@QAEXH@Z			; Ship::SetAIMode
PUBLIC	??0?$ListIter@VExplosion@@@@QAE@AAV?$List@VExplosion@@@@@Z ; ListIter<Explosion>::ListIter<Explosion>
PUBLIC	?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::next
PUBLIC	??E?$ListIter@VExplosion@@@@QAEHXZ		; ListIter<Explosion>::operator++
PUBLIC	?value@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::value
PUBLIC	?removeItem@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::removeItem
PUBLIC	?AddCommandPoints@ShipStats@@QAEXH@Z		; ShipStats::AddCommandPoints
PUBLIC	?SetHitTarget@Shot@@QAEX_N@Z			; Shot::SetHitTarget
PUBLIC	?SetLife@Drone@@QAEXH@Z				; Drone::SetLife
PUBLIC	?size@?$List@VDebris@@@@QBEHXZ			; List<Debris>::size
PUBLIC	?removeItem@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::removeItem
PUBLIC	?TYPENAME@Drone@@SAPBDXZ			; Drone::TYPENAME
PUBLIC	?check@?$List@VDrone@@@@ABE_NAAH@Z		; List<Drone>::check
PUBLIC	?removeIndex@?$List@VDrone@@@@QAEPAVDrone@@H@Z	; List<Drone>::removeIndex
PUBLIC	?remove@?$List@VDrone@@@@QAEPAVDrone@@PBV2@@Z	; List<Drone>::remove
PUBLIC	?removeItem@?$ListIter@VShot@@@@QAEPAVShot@@XZ	; ListIter<Shot>::removeItem
PUBLIC	?IsTestMode@Sim@@QBE_NXZ			; Sim::IsTestMode
PUBLIC	?Registry@Ship@@QBEPBDXZ			; Ship::Registry
PUBLIC	?RespawnLoc@Ship@@QBEABUPoint@@XZ		; Ship::RespawnLoc
PUBLIC	?GetCarrier@Ship@@QBEPAV1@XZ			; Ship::GetCarrier
PUBLIC	?removeItem@?$ListIter@VShip@@@@QAEPAVShip@@XZ	; ListIter<Ship>::removeItem
PUBLIC	?resize@?$List@VDrone@@@@AAEXH@Z		; List<Drone>::resize
PUBLIC	?append@?$List@VDrone@@@@QAEXPBVDrone@@@Z	; List<Drone>::append
PUBLIC	?resize@?$List@VExplosion@@@@AAEXH@Z		; List<Explosion>::resize
PUBLIC	?append@?$List@VExplosion@@@@QAEXPBVExplosion@@@Z ; List<Explosion>::append
PUBLIC	?TYPENAME@Explosion@@SAPBDXZ			; Explosion::TYPENAME
PUBLIC	?check@?$List@VExplosion@@@@ABE_NAAH@Z		; List<Explosion>::check
PUBLIC	?removeIndex@?$List@VExplosion@@@@QAEPAVExplosion@@H@Z ; List<Explosion>::removeIndex
PUBLIC	?remove@?$List@VExplosion@@@@QAEPAVExplosion@@PBV2@@Z ; List<Explosion>::remove
PUBLIC	?resize@?$List@VDebris@@@@AAEXH@Z		; List<Debris>::resize
PUBLIC	?append@?$List@VDebris@@@@QAEXPBVDebris@@@Z	; List<Debris>::append
PUBLIC	?check@?$List@VDebris@@@@ABE_NAAH@Z		; List<Debris>::check
PUBLIC	?removeIndex@?$List@VDebris@@@@QAEPAVDebris@@H@Z ; List<Debris>::removeIndex
PUBLIC	?remove@?$List@VDebris@@@@QAEPAVDebris@@PBV2@@Z	; List<Debris>::remove
PUBLIC	?resize@?$List@VAsteroid@@@@AAEXH@Z		; List<Asteroid>::resize
PUBLIC	?append@?$List@VAsteroid@@@@QAEXPBVAsteroid@@@Z	; List<Asteroid>::append
PUBLIC	?check@?$List@VAsteroid@@@@ABE_NAAH@Z		; List<Asteroid>::check
PUBLIC	?removeIndex@?$List@VAsteroid@@@@QAEPAVAsteroid@@H@Z ; List<Asteroid>::removeIndex
PUBLIC	?remove@?$List@VAsteroid@@@@QAEPAVAsteroid@@PBV2@@Z ; List<Asteroid>::remove
PUBLIC	?SetRegion@CombatGroup@@QAEXVText@@@Z		; CombatGroup::SetRegion
PUBLIC	??_C@_0M@EIEAPHAO@SimObserver?$AA@		; `string'
PUBLIC	??_C@_0CG@DCHCODGP@c?3?2matrix?5games?2dev?2stars45?2Miss@ ; `string'
PUBLIC	??_C@_0BC@CAMCFAKE@Collateral?5Damage?$AA@	; `string'
PUBLIC	?sim@Sim@@1PAV1@A				; Sim::sim
PUBLIC	??_C@_0BE@MDJAGKKE@?6?6FINAL?5SCORE?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0DP@BCONEFGH@Name?5?5?5?5?5?5?5?5?5?5?5?5?5?5Kill1?5?5Kill2?5?5@ ; `string'
PUBLIC	??_C@_0DO@BFFMOOLB@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5?5?9?9?9?9?9?5?5?9?9?9?9?9?5?5@ ; `string'
PUBLIC	??_C@_0CF@KFDPBJH@?$CF?916s?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5?5?$CF6d?5?5@ ; `string'
PUBLIC	??_C@_0CO@IHAFINE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_0CH@GLANDEFM@TOTAL?5?5?5?5?5?5?5?5?5?5?5?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5@ ; `string'
PUBLIC	??_C@_0CN@BNNLBOCC@Sim?3?3ExecMission?$CI?$CJ?5?9?5No?5mission?5@ ; `string'
PUBLIC	??_C@_0DE@LJMJJDEL@Sim?3?3ExecMission?$CI?$CFs?$CJ?5mission?5is?5@ ; `string'
PUBLIC	??_C@_0BF@INLOODOL@?6Exec?5Mission?3?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_07MHJMBJCP@Sim?4cpp?$AA@			; `string'
PUBLIC	??_C@_0CJ@IICEGJCO@WARNING?3?5alert?5ship?5?8?$CFs?8?5region?5@ ; `string'
PUBLIC	??_C@_0N@CNEAMPHK@Unidentified?$AA@		; `string'
PUBLIC	??_C@_0CJ@BABHFBHK@WARNING?3?5CreateShip?$CI?$CFs?$CJ?3?5invalid@ ; `string'
PUBLIC	??_C@_0CJ@POPAIFMC@Inserting?5Ship?$CI?$CFs?$CJ?5into?5Region?$CI?$CF@ ; `string'
PUBLIC	??_C@_0EB@OCIFAMJD@WARNING?3?5Sim?3?3ActivateRegion?$CI?$CJ?5N@ ; `string'
PUBLIC	??_C@_0BL@GPICPCGA@Ship?5?8?$CFs?8?5farcast?5to?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@KPJAHLOO@Ship?5?8?$CFs?8?5broke?5orbit?5to?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@EADKDGGP@Ship?5?8?$CFs?8?5achieved?5orbit?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@BLBMKKEF@Ship?5?8?$CFs?8?5quantum?5to?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@DDGAJNGP@Warning?3?5Unusual?5jump?5request?5fo@ ; `string'
PUBLIC	??_C@_0BH@IBFIGKOO@?5?5?5?5?$CFs?5Killed?5?$CFs?5?$CI?$CFs?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0M@PMIPMFJL@?1Mods?1Ships?$AA@		; `string'
PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@		; `string'
PUBLIC	??_C@_0DN@GOGEGHME@SimRegion?5?$CFs?5could?5not?5set?5playe@ ; `string'
PUBLIC	??_C@_05JPAGBMGJ@?$FLKIA?$FN?$AA@		; `string'
PUBLIC	??_C@_0CL@IBPHLHIK@?5?5?5ship?5?$CFs?5died?5in?5collision?5wit@ ; `string'
PUBLIC	??_C@_06CAKIJOOM@DEBRIS?$AA@			; `string'
PUBLIC	??_C@_08OJEDLGMF@ASTEROID?$AA@			; `string'
PUBLIC	??_C@_0CG@GLNEEKDA@?5?5?5?5ship?5destroyed?5by?5crash?3?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0DA@FMJBEPL@Warning?3?5No?5Element?5found?5for?5?8?$CF@ ; `string'
PUBLIC	??_C@_0BH@CIBPJMDL@?5?5?5?5?$CFs?5Docked?5with?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@MNIJIMLO@?$CF02d?3?$CF02d?3?$CF02d?4?$CF03d?$AA@ ; `string'
PUBLIC	??_C@_0P@GCEINJHL@?$CF02d?3?$CF02d?4?$CF03d?$AA@ ; `string'
PUBLIC	??_7Universe@@6B@				; Universe::`vftable'
PUBLIC	??_7Sim@@6B@					; Sim::`vftable'
PUBLIC	??_7SimRegion@@6B@				; SimRegion::`vftable'
PUBLIC	??_7Bitmap@@6B@					; Bitmap::`vftable'
PUBLIC	??_7Resource@@6B@				; Resource::`vftable'
EXTRN	??_EUniverse@@UAEPAXI@Z:PROC			; Universe::`vector deleting destructor'
EXTRN	??_ESim@@UAEPAXI@Z:PROC				; Sim::`vector deleting destructor'
EXTRN	?GetVideo@Game@@SAPAVVideo@@XZ:PROC		; Game::GetVideo
EXTRN	??1Resource@@UAE@XZ:PROC			; Resource::~Resource
EXTRN	??_EResource@@UAEPAXI@Z:PROC			; Resource::`vector deleting destructor'
EXTRN	?GetSurface@Bitmap@@UAEPAEXZ:PROC		; Bitmap::GetSurface
EXTRN	?Pitch@Bitmap@@UBEHXZ:PROC			; Bitmap::Pitch
EXTRN	?PixSize@Bitmap@@UBEHXZ:PROC			; Bitmap::PixSize
EXTRN	?SkipGameTime@Game@@SAXN@Z:PROC			; Game::SkipGameTime
EXTRN	??_ESimRegion@@UAEPAXI@Z:PROC			; SimRegion::`vector deleting destructor'
EXTRN	?max_frame_length@Game@@1NA:QWORD		; Game::max_frame_length
EXTRN	?SetListener@Sound@@SAXABVCamera@@ABUVec3@@@Z:PROC ; Sound::SetListener
EXTRN	?SemiElasticCollision@Physical@@SAXAAV1@0@Z:PROC ; Physical::SemiElasticCollision
?sim@Sim@@1PAV1@A DD 01H DUP (?)			; Sim::sim
;	COMDAT ??_7Resource@@6B@
CONST	SEGMENT
??_7Resource@@6B@ DD FLAT:??_R4Resource@@6B@		; Resource::`vftable'
	DD	FLAT:??_EResource@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4Resource@@6B@
rdata$r	SEGMENT
??_R4Resource@@6B@ DD 00H				; Resource::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVResource@@@8
	DD	FLAT:??_R3Resource@@8
rdata$r	ENDS
;	COMDAT ??_7Bitmap@@6B@
CONST	SEGMENT
??_7Bitmap@@6B@ DD FLAT:??_R4Bitmap@@6B@		; Bitmap::`vftable'
	DD	FLAT:??_EBitmap@@UAEPAXI@Z
	DD	FLAT:?GetSurface@Bitmap@@UAEPAEXZ
	DD	FLAT:?Pitch@Bitmap@@UBEHXZ
	DD	FLAT:?PixSize@Bitmap@@UBEHXZ
CONST	ENDS
;	COMDAT ??_R4Bitmap@@6B@
rdata$r	SEGMENT
??_R4Bitmap@@6B@ DD 00H					; Bitmap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBitmap@@@8
	DD	FLAT:??_R3Bitmap@@8
rdata$r	ENDS
;	COMDAT ??_R3Bitmap@@8
rdata$r	SEGMENT
??_R3Bitmap@@8 DD 00H					; Bitmap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Bitmap@@8
rdata$r	ENDS
;	COMDAT ??_R2Bitmap@@8
rdata$r	SEGMENT
??_R2Bitmap@@8 DD FLAT:??_R1A@?0A@EA@Bitmap@@8		; Bitmap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Resource@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Resource@@8 DD FLAT:??_R0?AVResource@@@8	; Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Resource@@8
rdata$r	ENDS
;	COMDAT ??_R3Resource@@8
rdata$r	SEGMENT
??_R3Resource@@8 DD 00H					; Resource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Resource@@8
rdata$r	ENDS
;	COMDAT ??_R2Resource@@8
rdata$r	SEGMENT
??_R2Resource@@8 DD FLAT:??_R1A@?0A@EA@Resource@@8	; Resource::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVResource@@@8
_DATA	SEGMENT
??_R0?AVResource@@@8 DD FLAT:??_7type_info@@6B@		; Resource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVResource@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@Bitmap@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Bitmap@@8 DD FLAT:??_R0?AVBitmap@@@8	; Bitmap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Bitmap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBitmap@@@8
_DATA	SEGMENT
??_R0?AVBitmap@@@8 DD FLAT:??_7type_info@@6B@		; Bitmap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBitmap@@', 00H
_DATA	ENDS
;	COMDAT ??_7SimRegion@@6B@
CONST	SEGMENT
??_7SimRegion@@6B@ DD FLAT:??_R4SimRegion@@6B@		; SimRegion::`vftable'
	DD	FLAT:??_ESimRegion@@UAEPAXI@Z
	DD	FLAT:?Activate@SimRegion@@UAEXXZ
	DD	FLAT:?Deactivate@SimRegion@@UAEXXZ
	DD	FLAT:?ExecFrame@SimRegion@@UAEXN@Z
	DD	FLAT:?FindShipByObjID@SimRegion@@UAEPAVShip@@K@Z
	DD	FLAT:?FindShotByObjID@SimRegion@@UAEPAVShot@@K@Z
	DD	FLAT:?InsertObject@SimRegion@@UAEXPAVAsteroid@@@Z
	DD	FLAT:?InsertObject@SimRegion@@UAEXPAVDebris@@@Z
	DD	FLAT:?InsertObject@SimRegion@@UAEXPAVExplosion@@@Z
	DD	FLAT:?InsertObject@SimRegion@@UAEXPAVShot@@@Z
	DD	FLAT:?InsertObject@SimRegion@@UAEXPAVShip@@@Z
CONST	ENDS
;	COMDAT ??_R4SimRegion@@6B@
rdata$r	SEGMENT
??_R4SimRegion@@6B@ DD 00H				; SimRegion::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSimRegion@@@8
	DD	FLAT:??_R3SimRegion@@8
rdata$r	ENDS
;	COMDAT ??_R3SimRegion@@8
rdata$r	SEGMENT
??_R3SimRegion@@8 DD 00H				; SimRegion::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SimRegion@@8
rdata$r	ENDS
;	COMDAT ??_R2SimRegion@@8
rdata$r	SEGMENT
??_R2SimRegion@@8 DD FLAT:??_R1A@?0A@EA@SimRegion@@8	; SimRegion::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SimRegion@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimRegion@@8 DD FLAT:??_R0?AVSimRegion@@@8 ; SimRegion::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimRegion@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimRegion@@@8
_DATA	SEGMENT
??_R0?AVSimRegion@@@8 DD FLAT:??_7type_info@@6B@	; SimRegion `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimRegion@@', 00H
_DATA	ENDS
;	COMDAT ??_7Sim@@6B@
CONST	SEGMENT
??_7Sim@@6B@ DD	FLAT:??_R4Sim@@6B@			; Sim::`vftable'
	DD	FLAT:??_ESim@@UAEPAXI@Z
	DD	FLAT:?ExecFrame@Sim@@UAEXN@Z
	DD	FLAT:?FindShipByObjID@Sim@@UAEPAVShip@@K@Z
	DD	FLAT:?FindShotByObjID@Sim@@UAEPAVShot@@K@Z
CONST	ENDS
;	COMDAT ??_R4Sim@@6B@
rdata$r	SEGMENT
??_R4Sim@@6B@ DD 00H					; Sim::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSim@@@8
	DD	FLAT:??_R3Sim@@8
rdata$r	ENDS
;	COMDAT ??_R3Sim@@8
rdata$r	SEGMENT
??_R3Sim@@8 DD	00H					; Sim::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Sim@@8
rdata$r	ENDS
;	COMDAT ??_R2Sim@@8
rdata$r	SEGMENT
??_R2Sim@@8 DD	FLAT:??_R1A@?0A@EA@Sim@@8		; Sim::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Universe@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Sim@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Sim@@8 DD FLAT:??_R0?AVSim@@@8		; Sim::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Sim@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSim@@@8
_DATA	SEGMENT
??_R0?AVSim@@@8 DD FLAT:??_7type_info@@6B@		; Sim `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSim@@', 00H
_DATA	ENDS
;	COMDAT ??_7Universe@@6B@
CONST	SEGMENT
??_7Universe@@6B@ DD FLAT:??_R4Universe@@6B@		; Universe::`vftable'
	DD	FLAT:??_EUniverse@@UAEPAXI@Z
	DD	FLAT:?ExecFrame@Universe@@UAEXN@Z
CONST	ENDS
;	COMDAT ??_R4Universe@@6B@
rdata$r	SEGMENT
??_R4Universe@@6B@ DD 00H				; Universe::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVUniverse@@@8
	DD	FLAT:??_R3Universe@@8
rdata$r	ENDS
;	COMDAT ??_R3Universe@@8
rdata$r	SEGMENT
??_R3Universe@@8 DD 00H					; Universe::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Universe@@8
rdata$r	ENDS
;	COMDAT ??_R2Universe@@8
rdata$r	SEGMENT
??_R2Universe@@8 DD FLAT:??_R1A@?0A@EA@Universe@@8	; Universe::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Universe@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Universe@@8 DD FLAT:??_R0?AVUniverse@@@8	; Universe::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Universe@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUniverse@@@8
_DATA	SEGMENT
??_R0?AVUniverse@@@8 DD FLAT:??_7type_info@@6B@		; Universe `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVUniverse@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0P@GCEINJHL@?$CF02d?3?$CF02d?4?$CF03d?$AA@
CONST	SEGMENT
??_C@_0P@GCEINJHL@?$CF02d?3?$CF02d?4?$CF03d?$AA@ DB '%02d:%02d.%03d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MNIJIMLO@?$CF02d?3?$CF02d?3?$CF02d?4?$CF03d?$AA@
CONST	SEGMENT
??_C@_0BE@MNIJIMLO@?$CF02d?3?$CF02d?3?$CF02d?4?$CF03d?$AA@ DB '%02d:%02d:'
	DB	'%02d.%03d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CIBPJMDL@?5?5?5?5?$CFs?5Docked?5with?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@CIBPJMDL@?5?5?5?5?$CFs?5Docked?5with?5?$CFs?6?$AA@ DB '    %s D'
	DB	'ocked with %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FMJBEPL@Warning?3?5No?5Element?5found?5for?5?8?$CF@
CONST	SEGMENT
??_C@_0DA@FMJBEPL@Warning?3?5No?5Element?5found?5for?5?8?$CF@ DB 'Warning'
	DB	': No Element found for ''%s'' on respawn.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GLNEEKDA@?5?5?5?5ship?5destroyed?5by?5crash?3?5?$CFs?5@
CONST	SEGMENT
??_C@_0CG@GLNEEKDA@?5?5?5?5ship?5destroyed?5by?5crash?3?5?$CFs?5@ DB '   '
	DB	' ship destroyed by crash: %s (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJEDLGMF@ASTEROID?$AA@
CONST	SEGMENT
??_C@_08OJEDLGMF@ASTEROID?$AA@ DB 'ASTEROID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CAKIJOOM@DEBRIS?$AA@
CONST	SEGMENT
??_C@_06CAKIJOOM@DEBRIS?$AA@ DB 'DEBRIS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IBPHLHIK@?5?5?5ship?5?$CFs?5died?5in?5collision?5wit@
CONST	SEGMENT
??_C@_0CL@IBPHLHIK@?5?5?5ship?5?$CFs?5died?5in?5collision?5wit@ DB '   sh'
	DB	'ip %s died in collision with %s (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPAGBMGJ@?$FLKIA?$FN?$AA@
CONST	SEGMENT
??_C@_05JPAGBMGJ@?$FLKIA?$FN?$AA@ DB '[KIA]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GOGEGHME@SimRegion?5?$CFs?5could?5not?5set?5playe@
CONST	SEGMENT
??_C@_0DN@GOGEGHME@SimRegion?5?$CFs?5could?5not?5set?5playe@ DB 'SimRegio'
	DB	'n %s could not set player ship ''%s'' - not in region', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ DB '(null)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PMIPMFJL@?1Mods?1Ships?$AA@
CONST	SEGMENT
??_C@_0M@PMIPMFJL@?1Mods?1Ships?$AA@ DB '/Mods/Ships', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IBFIGKOO@?5?5?5?5?$CFs?5Killed?5?$CFs?5?$CI?$CFs?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BH@IBFIGKOO@?5?5?5?5?$CFs?5Killed?5?$CFs?5?$CI?$CFs?$CJ?6?$AA@ DB ' '
	DB	'   %s Killed %s (%s)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DDGAJNGP@Warning?3?5Unusual?5jump?5request?5fo@
CONST	SEGMENT
??_C@_0CN@DDGAJNGP@Warning?3?5Unusual?5jump?5request?5fo@ DB 'Warning: Un'
	DB	'usual jump request for ship ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BLBMKKEF@Ship?5?8?$CFs?8?5quantum?5to?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BL@BLBMKKEF@Ship?5?8?$CFs?8?5quantum?5to?5?8?$CFs?8?6?$AA@ DB 'Shi'
	DB	'p ''%s'' quantum to ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EADKDGGP@Ship?5?8?$CFs?8?5achieved?5orbit?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BP@EADKDGGP@Ship?5?8?$CFs?8?5achieved?5orbit?5?8?$CFs?8?6?$AA@ DB 'S'
	DB	'hip ''%s'' achieved orbit ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KPJAHLOO@Ship?5?8?$CFs?8?5broke?5orbit?5to?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BP@KPJAHLOO@Ship?5?8?$CFs?8?5broke?5orbit?5to?5?8?$CFs?8?6?$AA@ DB 'S'
	DB	'hip ''%s'' broke orbit to ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GPICPCGA@Ship?5?8?$CFs?8?5farcast?5to?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BL@GPICPCGA@Ship?5?8?$CFs?8?5farcast?5to?5?8?$CFs?8?6?$AA@ DB 'Shi'
	DB	'p ''%s'' farcast to ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@OCIFAMJD@WARNING?3?5Sim?3?3ActivateRegion?$CI?$CJ?5N@
CONST	SEGMENT
??_C@_0EB@OCIFAMJD@WARNING?3?5Sim?3?3ActivateRegion?$CI?$CJ?5N@ DB 'WARNI'
	DB	'NG: Sim::ActivateRegion() No star system found for rgn ''%s'''
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@POPAIFMC@Inserting?5Ship?$CI?$CFs?$CJ?5into?5Region?$CI?$CF@
CONST	SEGMENT
??_C@_0CJ@POPAIFMC@Inserting?5Ship?$CI?$CFs?$CJ?5into?5Region?$CI?$CF@ DB 'I'
	DB	'nserting Ship(%s) into Region(%s) (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BABHFBHK@WARNING?3?5CreateShip?$CI?$CFs?$CJ?3?5invalid@
CONST	SEGMENT
??_C@_0CJ@BABHFBHK@WARNING?3?5CreateShip?$CI?$CFs?$CJ?3?5invalid@ DB 'WAR'
	DB	'NING: CreateShip(%s): invalid design', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CNEAMPHK@Unidentified?$AA@
CONST	SEGMENT
??_C@_0N@CNEAMPHK@Unidentified?$AA@ DB 'Unidentified', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IICEGJCO@WARNING?3?5alert?5ship?5?8?$CFs?8?5region?5@
CONST	SEGMENT
??_C@_0CJ@IICEGJCO@WARNING?3?5alert?5ship?5?8?$CFs?8?5region?5@ DB 'WARNI'
	DB	'NG: alert ship ''%s'' region is null', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
CONST	SEGMENT
??_C@_07MHJMBJCP@Sim?4cpp?$AA@ DB 'Sim.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@INLOODOL@?6Exec?5Mission?3?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BF@INLOODOL@?6Exec?5Mission?3?5?8?$CFs?8?6?$AA@ DB 0aH, 'Exec Miss'
	DB	'ion: ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@LJMJJDEL@Sim?3?3ExecMission?$CI?$CFs?$CJ?5mission?5is?5@
CONST	SEGMENT
??_C@_0DE@LJMJJDEL@Sim?3?3ExecMission?$CI?$CFs?$CJ?5mission?5is?5@ DB 'Si'
	DB	'm::ExecMission(%s) mission is already executing.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BNNLBOCC@Sim?3?3ExecMission?$CI?$CJ?5?9?5No?5mission?5@
CONST	SEGMENT
??_C@_0CN@BNNLBOCC@Sim?3?3ExecMission?$CI?$CJ?5?9?5No?5mission?5@ DB 'Sim'
	DB	'::ExecMission() - No mission to execute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GLANDEFM@TOTAL?5?5?5?5?5?5?5?5?5?5?5?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5@
CONST	SEGMENT
??_C@_0CH@GLANDEFM@TOTAL?5?5?5?5?5?5?5?5?5?5?5?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5@ DB 'T'
	DB	'OTAL             %5d  %5d  %5d  %5d', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IHAFINE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0CO@IHAFINE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------------------', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KFDPBJH@?$CF?916s?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5?5?$CF6d?5?5@
CONST	SEGMENT
??_C@_0CF@KFDPBJH@?$CF?916s?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5?5?$CF6d?5?5@ DB '%'
	DB	'-16s  %5d  %5d  %5d  %5d  %6d  %6d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@BFFMOOLB@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5?5?9?9?9?9?9?5?5?9?9?9?9?9?5?5@
CONST	SEGMENT
??_C@_0DO@BFFMOOLB@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5?5?9?9?9?9?9?5?5?9?9?9?9?9?5?5@ DB '-'
	DB	'---------------  -----  -----  -----  -----  ------  ------', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@BCONEFGH@Name?5?5?5?5?5?5?5?5?5?5?5?5?5?5Kill1?5?5Kill2?5?5@
CONST	SEGMENT
??_C@_0DP@BCONEFGH@Name?5?5?5?5?5?5?5?5?5?5?5?5?5?5Kill1?5?5Kill2?5?5@ DB 'N'
	DB	'ame              Kill1  Kill2  Died   Colls  Points  Cmd Pts', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MDJAGKKE@?6?6FINAL?5SCORE?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BE@MDJAGKKE@?6?6FINAL?5SCORE?5?8?$CFs?8?6?$AA@ DB 0aH, 0aH, 'FINAL'
	DB	' SCORE ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CAMCFAKE@Collateral?5Damage?$AA@
CONST	SEGMENT
??_C@_0BC@CAMCFAKE@Collateral?5Damage?$AA@ DB 'Collateral Damage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DCHCODGP@c?3?2matrix?5games?2dev?2stars45?2Miss@
CONST	SEGMENT
??_C@_0CG@DCHCODGP@c?3?2matrix?5games?2dev?2stars45?2Miss@ DB 'c:\matrix '
	DB	'games\dev\stars45\Mission.h', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EIEAPHAO@SimObserver?$AA@
CONST	SEGMENT
??_C@_0M@EIEAPHAO@SimObserver?$AA@ DB 'SimObserver', 00H ; `string'
	ORG $+18
_first_frame DB	01H
	ORG $+336
_PI	DQ	0400921fb54442d18r		; 3.14159
; Function compile flags: /Ogtp
; File c:\matrix games\dev\foundationex\list.inl
;	COMDAT ?resize@?$List@VAsteroid@@@@AAEXH@Z
_TEXT	SEGMENT
?resize@?$List@VAsteroid@@@@AAEXH@Z PROC		; List<Asteroid>::resize, COMDAT
; _this$ = esi
; _newsize$ = eax

; 125  :    if (newsize > extent) {

  00000	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00003	7e 68		 jle	 SHORT $LN7@resize

; 126  :       extent = 16 * (newsize/16 + 1);

  00005	99		 cdq
  00006	83 e2 0f	 and	 edx, 15			; 0000000fH
  00009	03 c2		 add	 eax, edx
  0000b	c1 f8 04	 sar	 eax, 4
  0000e	40		 inc	 eax
  0000f	c1 e0 04	 shl	 eax, 4

; 127  : 
; 128  : #ifdef MEM_DEBUG
; 129  :       T** v = new(__FILE__,__LINE__) PTR[extent];
; 130  : #else
; 131  :       T** v = new PTR[extent];

  00012	33 c9		 xor	 ecx, ecx
  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	ba 04 00 00 00	 mov	 edx, 4
  0001c	f7 e2		 mul	 edx
  0001e	0f 90 c1	 seto	 cl
  00021	57		 push	 edi
  00022	f7 d9		 neg	 ecx
  00024	0b c8		 or	 ecx, eax
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002c	8b f8		 mov	 edi, eax

; 132  : #endif
; 133  : 	  int i;
; 134  :       for (i = 0; i < items; i++)

  0002e	33 c0		 xor	 eax, eax
  00030	83 c4 04	 add	 esp, 4
  00033	39 06		 cmp	 DWORD PTR [esi], eax
  00035	7e 0e		 jle	 SHORT $LN4@resize
$LL6@resize:

; 135  :          v[i] = array[i];

  00037	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0003d	89 14 87	 mov	 DWORD PTR [edi+eax*4], edx
  00040	40		 inc	 eax
  00041	3b 06		 cmp	 eax, DWORD PTR [esi]
  00043	7c f2		 jl	 SHORT $LL6@resize
$LN4@resize:

; 136  : 
; 137  :       for (; i < extent; i++)

  00045	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00048	7d 13		 jge	 SHORT $LN1@resize
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL3@resize:

; 138  :          v[i] = 0;

  00050	c7 04 87 00 00
	00 00		 mov	 DWORD PTR [edi+eax*4], 0
  00057	40		 inc	 eax
  00058	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0005b	7c f3		 jl	 SHORT $LL3@resize
$LN1@resize:

; 139  : 
; 140  :       delete [] array;   

  0005d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00066	83 c4 04	 add	 esp, 4

; 141  :       array = v;

  00069	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0006c	5f		 pop	 edi
$LN7@resize:

; 142  :    }
; 143  : }

  0006d	c3		 ret	 0
?resize@?$List@VAsteroid@@@@AAEXH@Z ENDP		; List<Asteroid>::resize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize@?$List@VDebris@@@@AAEXH@Z
_TEXT	SEGMENT
?resize@?$List@VDebris@@@@AAEXH@Z PROC			; List<Debris>::resize, COMDAT
; _this$ = esi
; _newsize$ = eax

; 125  :    if (newsize > extent) {

  00000	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00003	7e 68		 jle	 SHORT $LN7@resize@2

; 126  :       extent = 16 * (newsize/16 + 1);

  00005	99		 cdq
  00006	83 e2 0f	 and	 edx, 15			; 0000000fH
  00009	03 c2		 add	 eax, edx
  0000b	c1 f8 04	 sar	 eax, 4
  0000e	40		 inc	 eax
  0000f	c1 e0 04	 shl	 eax, 4

; 127  : 
; 128  : #ifdef MEM_DEBUG
; 129  :       T** v = new(__FILE__,__LINE__) PTR[extent];
; 130  : #else
; 131  :       T** v = new PTR[extent];

  00012	33 c9		 xor	 ecx, ecx
  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	ba 04 00 00 00	 mov	 edx, 4
  0001c	f7 e2		 mul	 edx
  0001e	0f 90 c1	 seto	 cl
  00021	57		 push	 edi
  00022	f7 d9		 neg	 ecx
  00024	0b c8		 or	 ecx, eax
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002c	8b f8		 mov	 edi, eax

; 132  : #endif
; 133  : 	  int i;
; 134  :       for (i = 0; i < items; i++)

  0002e	33 c0		 xor	 eax, eax
  00030	83 c4 04	 add	 esp, 4
  00033	39 06		 cmp	 DWORD PTR [esi], eax
  00035	7e 0e		 jle	 SHORT $LN4@resize@2
$LL6@resize@2:

; 135  :          v[i] = array[i];

  00037	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0003d	89 14 87	 mov	 DWORD PTR [edi+eax*4], edx
  00040	40		 inc	 eax
  00041	3b 06		 cmp	 eax, DWORD PTR [esi]
  00043	7c f2		 jl	 SHORT $LL6@resize@2
$LN4@resize@2:

; 136  : 
; 137  :       for (; i < extent; i++)

  00045	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00048	7d 13		 jge	 SHORT $LN1@resize@2
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL3@resize@2:

; 138  :          v[i] = 0;

  00050	c7 04 87 00 00
	00 00		 mov	 DWORD PTR [edi+eax*4], 0
  00057	40		 inc	 eax
  00058	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0005b	7c f3		 jl	 SHORT $LL3@resize@2
$LN1@resize@2:

; 139  : 
; 140  :       delete [] array;   

  0005d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00066	83 c4 04	 add	 esp, 4

; 141  :       array = v;

  00069	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0006c	5f		 pop	 edi
$LN7@resize@2:

; 142  :    }
; 143  : }

  0006d	c3		 ret	 0
?resize@?$List@VDebris@@@@AAEXH@Z ENDP			; List<Debris>::resize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize@?$List@VExplosion@@@@AAEXH@Z
_TEXT	SEGMENT
?resize@?$List@VExplosion@@@@AAEXH@Z PROC		; List<Explosion>::resize, COMDAT
; _this$ = esi
; _newsize$ = eax

; 125  :    if (newsize > extent) {

  00000	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00003	7e 68		 jle	 SHORT $LN7@resize@3

; 126  :       extent = 16 * (newsize/16 + 1);

  00005	99		 cdq
  00006	83 e2 0f	 and	 edx, 15			; 0000000fH
  00009	03 c2		 add	 eax, edx
  0000b	c1 f8 04	 sar	 eax, 4
  0000e	40		 inc	 eax
  0000f	c1 e0 04	 shl	 eax, 4

; 127  : 
; 128  : #ifdef MEM_DEBUG
; 129  :       T** v = new(__FILE__,__LINE__) PTR[extent];
; 130  : #else
; 131  :       T** v = new PTR[extent];

  00012	33 c9		 xor	 ecx, ecx
  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	ba 04 00 00 00	 mov	 edx, 4
  0001c	f7 e2		 mul	 edx
  0001e	0f 90 c1	 seto	 cl
  00021	57		 push	 edi
  00022	f7 d9		 neg	 ecx
  00024	0b c8		 or	 ecx, eax
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002c	8b f8		 mov	 edi, eax

; 132  : #endif
; 133  : 	  int i;
; 134  :       for (i = 0; i < items; i++)

  0002e	33 c0		 xor	 eax, eax
  00030	83 c4 04	 add	 esp, 4
  00033	39 06		 cmp	 DWORD PTR [esi], eax
  00035	7e 0e		 jle	 SHORT $LN4@resize@3
$LL6@resize@3:

; 135  :          v[i] = array[i];

  00037	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0003d	89 14 87	 mov	 DWORD PTR [edi+eax*4], edx
  00040	40		 inc	 eax
  00041	3b 06		 cmp	 eax, DWORD PTR [esi]
  00043	7c f2		 jl	 SHORT $LL6@resize@3
$LN4@resize@3:

; 136  : 
; 137  :       for (; i < extent; i++)

  00045	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00048	7d 13		 jge	 SHORT $LN1@resize@3
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL3@resize@3:

; 138  :          v[i] = 0;

  00050	c7 04 87 00 00
	00 00		 mov	 DWORD PTR [edi+eax*4], 0
  00057	40		 inc	 eax
  00058	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0005b	7c f3		 jl	 SHORT $LL3@resize@3
$LN1@resize@3:

; 139  : 
; 140  :       delete [] array;   

  0005d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00066	83 c4 04	 add	 esp, 4

; 141  :       array = v;

  00069	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0006c	5f		 pop	 edi
$LN7@resize@3:

; 142  :    }
; 143  : }

  0006d	c3		 ret	 0
?resize@?$List@VExplosion@@@@AAEXH@Z ENDP		; List<Explosion>::resize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize@?$List@VDrone@@@@AAEXH@Z
_TEXT	SEGMENT
?resize@?$List@VDrone@@@@AAEXH@Z PROC			; List<Drone>::resize, COMDAT
; _this$ = esi
; _newsize$ = eax

; 125  :    if (newsize > extent) {

  00000	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00003	7e 68		 jle	 SHORT $LN7@resize@4

; 126  :       extent = 16 * (newsize/16 + 1);

  00005	99		 cdq
  00006	83 e2 0f	 and	 edx, 15			; 0000000fH
  00009	03 c2		 add	 eax, edx
  0000b	c1 f8 04	 sar	 eax, 4
  0000e	40		 inc	 eax
  0000f	c1 e0 04	 shl	 eax, 4

; 127  : 
; 128  : #ifdef MEM_DEBUG
; 129  :       T** v = new(__FILE__,__LINE__) PTR[extent];
; 130  : #else
; 131  :       T** v = new PTR[extent];

  00012	33 c9		 xor	 ecx, ecx
  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	ba 04 00 00 00	 mov	 edx, 4
  0001c	f7 e2		 mul	 edx
  0001e	0f 90 c1	 seto	 cl
  00021	57		 push	 edi
  00022	f7 d9		 neg	 ecx
  00024	0b c8		 or	 ecx, eax
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002c	8b f8		 mov	 edi, eax

; 132  : #endif
; 133  : 	  int i;
; 134  :       for (i = 0; i < items; i++)

  0002e	33 c0		 xor	 eax, eax
  00030	83 c4 04	 add	 esp, 4
  00033	39 06		 cmp	 DWORD PTR [esi], eax
  00035	7e 0e		 jle	 SHORT $LN4@resize@4
$LL6@resize@4:

; 135  :          v[i] = array[i];

  00037	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0003d	89 14 87	 mov	 DWORD PTR [edi+eax*4], edx
  00040	40		 inc	 eax
  00041	3b 06		 cmp	 eax, DWORD PTR [esi]
  00043	7c f2		 jl	 SHORT $LL6@resize@4
$LN4@resize@4:

; 136  : 
; 137  :       for (; i < extent; i++)

  00045	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00048	7d 13		 jge	 SHORT $LN1@resize@4
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL3@resize@4:

; 138  :          v[i] = 0;

  00050	c7 04 87 00 00
	00 00		 mov	 DWORD PTR [edi+eax*4], 0
  00057	40		 inc	 eax
  00058	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0005b	7c f3		 jl	 SHORT $LL3@resize@4
$LN1@resize@4:

; 139  : 
; 140  :       delete [] array;   

  0005d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00066	83 c4 04	 add	 esp, 4

; 141  :       array = v;

  00069	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0006c	5f		 pop	 edi
$LN7@resize@4:

; 142  :    }
; 143  : }

  0006d	c3		 ret	 0
?resize@?$List@VDrone@@@@AAEXH@Z ENDP			; List<Drone>::resize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize@?$List@VSimSplash@@@@AAEXH@Z
_TEXT	SEGMENT
?resize@?$List@VSimSplash@@@@AAEXH@Z PROC		; List<SimSplash>::resize, COMDAT
; _this$ = esi
; _newsize$ = eax

; 125  :    if (newsize > extent) {

  00000	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00003	7e 68		 jle	 SHORT $LN7@resize@5

; 126  :       extent = 16 * (newsize/16 + 1);

  00005	99		 cdq
  00006	83 e2 0f	 and	 edx, 15			; 0000000fH
  00009	03 c2		 add	 eax, edx
  0000b	c1 f8 04	 sar	 eax, 4
  0000e	40		 inc	 eax
  0000f	c1 e0 04	 shl	 eax, 4

; 127  : 
; 128  : #ifdef MEM_DEBUG
; 129  :       T** v = new(__FILE__,__LINE__) PTR[extent];
; 130  : #else
; 131  :       T** v = new PTR[extent];

  00012	33 c9		 xor	 ecx, ecx
  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	ba 04 00 00 00	 mov	 edx, 4
  0001c	f7 e2		 mul	 edx
  0001e	0f 90 c1	 seto	 cl
  00021	57		 push	 edi
  00022	f7 d9		 neg	 ecx
  00024	0b c8		 or	 ecx, eax
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002c	8b f8		 mov	 edi, eax

; 132  : #endif
; 133  : 	  int i;
; 134  :       for (i = 0; i < items; i++)

  0002e	33 c0		 xor	 eax, eax
  00030	83 c4 04	 add	 esp, 4
  00033	39 06		 cmp	 DWORD PTR [esi], eax
  00035	7e 0e		 jle	 SHORT $LN4@resize@5
$LL6@resize@5:

; 135  :          v[i] = array[i];

  00037	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0003d	89 14 87	 mov	 DWORD PTR [edi+eax*4], edx
  00040	40		 inc	 eax
  00041	3b 06		 cmp	 eax, DWORD PTR [esi]
  00043	7c f2		 jl	 SHORT $LL6@resize@5
$LN4@resize@5:

; 136  : 
; 137  :       for (; i < extent; i++)

  00045	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00048	7d 13		 jge	 SHORT $LN1@resize@5
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL3@resize@5:

; 138  :          v[i] = 0;

  00050	c7 04 87 00 00
	00 00		 mov	 DWORD PTR [edi+eax*4], 0
  00057	40		 inc	 eax
  00058	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0005b	7c f3		 jl	 SHORT $LL3@resize@5
$LN1@resize@5:

; 139  : 
; 140  :       delete [] array;   

  0005d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00066	83 c4 04	 add	 esp, 4

; 141  :       array = v;

  00069	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0006c	5f		 pop	 edi
$LN7@resize@5:

; 142  :    }
; 143  : }

  0006d	c3		 ret	 0
?resize@?$List@VSimSplash@@@@AAEXH@Z ENDP		; List<SimSplash>::resize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize@?$List@VSimHyper@@@@AAEXH@Z
_TEXT	SEGMENT
?resize@?$List@VSimHyper@@@@AAEXH@Z PROC		; List<SimHyper>::resize, COMDAT
; _this$ = esi
; _newsize$ = eax

; 125  :    if (newsize > extent) {

  00000	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00003	7e 68		 jle	 SHORT $LN7@resize@6

; 126  :       extent = 16 * (newsize/16 + 1);

  00005	99		 cdq
  00006	83 e2 0f	 and	 edx, 15			; 0000000fH
  00009	03 c2		 add	 eax, edx
  0000b	c1 f8 04	 sar	 eax, 4
  0000e	40		 inc	 eax
  0000f	c1 e0 04	 shl	 eax, 4

; 127  : 
; 128  : #ifdef MEM_DEBUG
; 129  :       T** v = new(__FILE__,__LINE__) PTR[extent];
; 130  : #else
; 131  :       T** v = new PTR[extent];

  00012	33 c9		 xor	 ecx, ecx
  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	ba 04 00 00 00	 mov	 edx, 4
  0001c	f7 e2		 mul	 edx
  0001e	0f 90 c1	 seto	 cl
  00021	57		 push	 edi
  00022	f7 d9		 neg	 ecx
  00024	0b c8		 or	 ecx, eax
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002c	8b f8		 mov	 edi, eax

; 132  : #endif
; 133  : 	  int i;
; 134  :       for (i = 0; i < items; i++)

  0002e	33 c0		 xor	 eax, eax
  00030	83 c4 04	 add	 esp, 4
  00033	39 06		 cmp	 DWORD PTR [esi], eax
  00035	7e 0e		 jle	 SHORT $LN4@resize@6
$LL6@resize@6:

; 135  :          v[i] = array[i];

  00037	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0003d	89 14 87	 mov	 DWORD PTR [edi+eax*4], edx
  00040	40		 inc	 eax
  00041	3b 06		 cmp	 eax, DWORD PTR [esi]
  00043	7c f2		 jl	 SHORT $LL6@resize@6
$LN4@resize@6:

; 136  : 
; 137  :       for (; i < extent; i++)

  00045	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00048	7d 13		 jge	 SHORT $LN1@resize@6
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL3@resize@6:

; 138  :          v[i] = 0;

  00050	c7 04 87 00 00
	00 00		 mov	 DWORD PTR [edi+eax*4], 0
  00057	40		 inc	 eax
  00058	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0005b	7c f3		 jl	 SHORT $LL3@resize@6
$LN1@resize@6:

; 139  : 
; 140  :       delete [] array;   

  0005d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00066	83 c4 04	 add	 esp, 4

; 141  :       array = v;

  00069	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0006c	5f		 pop	 edi
$LN7@resize@6:

; 142  :    }
; 143  : }

  0006d	c3		 ret	 0
?resize@?$List@VSimHyper@@@@AAEXH@Z ENDP		; List<SimHyper>::resize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1SimSplash@@QAE@XZ
_TEXT	SEGMENT
??1SimSplash@@QAE@XZ PROC				; SimSplash::~SimSplash, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
??1SimSplash@@QAE@XZ ENDP				; SimSplash::~SimSplash
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GSimSplash@@QAEPAXI@Z
_TEXT	SEGMENT
??_GSimSplash@@QAEPAXI@Z PROC				; SimSplash::`scalar deleting destructor', COMDAT
; _this$ = esi
  00000	8b ce		 mov	 ecx, esi
  00002	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	83 c4 04	 add	 esp, 4
  00010	8b c6		 mov	 eax, esi
  00012	c3		 ret	 0
??_GSimSplash@@QAEPAXI@Z ENDP				; SimSplash::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ
_TEXT	SEGMENT
?value@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ PROC ; ListIter<Explosion>::value, COMDAT
; _this$ = eax

; 382  :    if (list && step >= 0 && step < list->items)

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	85 c9		 test	 ecx, ecx
  00004	74 12		 je	 SHORT $LN1@value
  00006	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00009	85 c0		 test	 eax, eax
  0000b	78 0b		 js	 SHORT $LN1@value
  0000d	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000f	7d 07		 jge	 SHORT $LN1@value

; 383  :       return list->array[step];

  00011	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00014	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 386  : }

  00017	c3		 ret	 0
$LN1@value:

; 384  : 
; 385  :    return 0;

  00018	33 c0		 xor	 eax, eax

; 386  : }

  0001a	c3		 ret	 0
?value@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ENDP ; ListIter<Explosion>::value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ
_TEXT	SEGMENT
?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ PROC	; ListIter<Explosion>::next, COMDAT
; _this$ = edx

; 404  :    if (list && step >= -1 && step < list->items-1)

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 1c		 je	 SHORT $LN1@next
  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	7c 14		 jl	 SHORT $LN1@next
  0000e	56		 push	 esi
  0000f	8b 31		 mov	 esi, DWORD PTR [ecx]
  00011	4e		 dec	 esi
  00012	3b c6		 cmp	 eax, esi
  00014	5e		 pop	 esi
  00015	7d 0b		 jge	 SHORT $LN1@next

; 405  :       return list->array[++step];

  00017	40		 inc	 eax
  00018	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 408  : }

  00021	c3		 ret	 0
$LN1@next:

; 406  : 
; 407  :    return 0;

  00022	33 c0		 xor	 eax, eax

; 408  : }

  00024	c3		 ret	 0
?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ENDP	; ListIter<Explosion>::next
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ
_TEXT	SEGMENT
?value@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ PROC ; ListIter<SimSplash>::value, COMDAT
; _this$ = eax

; 382  :    if (list && step >= 0 && step < list->items)

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	85 c9		 test	 ecx, ecx
  00004	74 12		 je	 SHORT $LN1@value@2
  00006	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00009	85 c0		 test	 eax, eax
  0000b	78 0b		 js	 SHORT $LN1@value@2
  0000d	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000f	7d 07		 jge	 SHORT $LN1@value@2

; 383  :       return list->array[step];

  00011	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00014	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 386  : }

  00017	c3		 ret	 0
$LN1@value@2:

; 384  : 
; 385  :    return 0;

  00018	33 c0		 xor	 eax, eax

; 386  : }

  0001a	c3		 ret	 0
?value@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ ENDP ; ListIter<SimSplash>::value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?next@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ
_TEXT	SEGMENT
?next@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ PROC	; ListIter<SimSplash>::next, COMDAT
; _this$ = edx

; 404  :    if (list && step >= -1 && step < list->items-1)

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 1c		 je	 SHORT $LN1@next@2
  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	7c 14		 jl	 SHORT $LN1@next@2
  0000e	56		 push	 esi
  0000f	8b 31		 mov	 esi, DWORD PTR [ecx]
  00011	4e		 dec	 esi
  00012	3b c6		 cmp	 eax, esi
  00014	5e		 pop	 esi
  00015	7d 0b		 jge	 SHORT $LN1@next@2

; 405  :       return list->array[++step];

  00017	40		 inc	 eax
  00018	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 408  : }

  00021	c3		 ret	 0
$LN1@next@2:

; 406  : 
; 407  :    return 0;

  00022	33 c0		 xor	 eax, eax

; 408  : }

  00024	c3		 ret	 0
?next@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ ENDP	; ListIter<SimSplash>::next
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ
_TEXT	SEGMENT
?value@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ PROC	; ListIter<SimHyper>::value, COMDAT
; _this$ = eax

; 382  :    if (list && step >= 0 && step < list->items)

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	85 c9		 test	 ecx, ecx
  00004	74 12		 je	 SHORT $LN1@value@3
  00006	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00009	85 c0		 test	 eax, eax
  0000b	78 0b		 js	 SHORT $LN1@value@3
  0000d	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000f	7d 07		 jge	 SHORT $LN1@value@3

; 383  :       return list->array[step];

  00011	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00014	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 386  : }

  00017	c3		 ret	 0
$LN1@value@3:

; 384  : 
; 385  :    return 0;

  00018	33 c0		 xor	 eax, eax

; 386  : }

  0001a	c3		 ret	 0
?value@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ ENDP	; ListIter<SimHyper>::value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?next@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ
_TEXT	SEGMENT
?next@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ PROC	; ListIter<SimHyper>::next, COMDAT
; _this$ = edx

; 404  :    if (list && step >= -1 && step < list->items-1)

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 1c		 je	 SHORT $LN1@next@3
  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	7c 14		 jl	 SHORT $LN1@next@3
  0000e	56		 push	 esi
  0000f	8b 31		 mov	 esi, DWORD PTR [ecx]
  00011	4e		 dec	 esi
  00012	3b c6		 cmp	 eax, esi
  00014	5e		 pop	 esi
  00015	7d 0b		 jge	 SHORT $LN1@next@3

; 405  :       return list->array[++step];

  00017	40		 inc	 eax
  00018	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 408  : }

  00021	c3		 ret	 0
$LN1@next@3:

; 406  : 
; 407  :    return 0;

  00022	33 c0		 xor	 eax, eax

; 408  : }

  00024	c3		 ret	 0
?next@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ ENDP	; ListIter<SimHyper>::next
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$ListIter@VModel@@@@QAEPAVModel@@XZ
_TEXT	SEGMENT
?value@?$ListIter@VModel@@@@QAEPAVModel@@XZ PROC	; ListIter<Model>::value, COMDAT
; _this$ = eax

; 382  :    if (list && step >= 0 && step < list->items)

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	85 c9		 test	 ecx, ecx
  00004	74 12		 je	 SHORT $LN1@value@4
  00006	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00009	85 c0		 test	 eax, eax
  0000b	78 0b		 js	 SHORT $LN1@value@4
  0000d	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000f	7d 07		 jge	 SHORT $LN1@value@4

; 383  :       return list->array[step];

  00011	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00014	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 386  : }

  00017	c3		 ret	 0
$LN1@value@4:

; 384  : 
; 385  :    return 0;

  00018	33 c0		 xor	 eax, eax

; 386  : }

  0001a	c3		 ret	 0
?value@?$ListIter@VModel@@@@QAEPAVModel@@XZ ENDP	; ListIter<Model>::value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?next@?$ListIter@VModel@@@@QAEPAVModel@@XZ
_TEXT	SEGMENT
?next@?$ListIter@VModel@@@@QAEPAVModel@@XZ PROC		; ListIter<Model>::next, COMDAT
; _this$ = ecx

; 404  :    if (list && step >= -1 && step < list->items-1)

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	85 d2		 test	 edx, edx
  00004	74 1c		 je	 SHORT $LN1@next@4
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	7c 14		 jl	 SHORT $LN1@next@4
  0000e	56		 push	 esi
  0000f	8b 32		 mov	 esi, DWORD PTR [edx]
  00011	4e		 dec	 esi
  00012	3b c6		 cmp	 eax, esi
  00014	5e		 pop	 esi
  00015	7d 0b		 jge	 SHORT $LN1@next@4

; 405  :       return list->array[++step];

  00017	40		 inc	 eax
  00018	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001b	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 408  : }

  00021	c3		 ret	 0
$LN1@next@4:

; 406  : 
; 407  :    return 0;

  00022	33 c0		 xor	 eax, eax

; 408  : }

  00024	c3		 ret	 0
?next@?$ListIter@VModel@@@@QAEPAVModel@@XZ ENDP		; ListIter<Model>::next
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$List@VAsteroid@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$List@VAsteroid@@@@QAEXXZ PROC		; List<Asteroid>::destroy, COMDAT
; _this$ = esi

; 47   :    if (items) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	74 47		 je	 SHORT $LN4@destroy

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000e	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00011	7e 18		 jle	 SHORT $LN1@destroy
$LL3@destroy:

; 51   :          delete array[i];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN2@destroy
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	6a 01		 push	 1
  00023	ff d0		 call	 eax
$LN2@destroy:

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00025	47		 inc	 edi
  00026	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00029	7c e8		 jl	 SHORT $LL3@destroy
$LN1@destroy:

; 52   : 
; 53   :       delete [] array;

  0002b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00034	83 c4 04	 add	 esp, 4

; 54   :       items       = 0;

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 55   :       extent  = 0;

  0003d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 56   :       array       = 0;

  00044	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004b	5f		 pop	 edi
$LN4@destroy:

; 57   :    }
; 58   : }

  0004c	c3		 ret	 0
?destroy@?$List@VAsteroid@@@@QAEXXZ ENDP		; List<Asteroid>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?append@?$List@VAsteroid@@@@QAEXPBVAsteroid@@@Z
_TEXT	SEGMENT
?append@?$List@VAsteroid@@@@QAEXPBVAsteroid@@@Z PROC	; List<Asteroid>::append, COMDAT
; _this$ = eax
; _item$ = edi

; 149  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 150  :    if (item) {

  00003	85 ff		 test	 edi, edi
  00005	74 17		 je	 SHORT $LN2@append

; 151  :       if (items+1 > extent) resize(items+1);

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	40		 inc	 eax
  0000a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0000d	7e 05		 jle	 SHORT $LN1@append
  0000f	e8 00 00 00 00	 call	 ?resize@?$List@VAsteroid@@@@AAEXH@Z ; List<Asteroid>::resize
$LN1@append:

; 152  :       array[items++] = (T*)item;

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00019	89 3c 81	 mov	 DWORD PTR [ecx+eax*4], edi
  0001c	ff 06		 inc	 DWORD PTR [esi]
$LN2@append:
  0001e	5e		 pop	 esi

; 153  :    }
; 154  : }

  0001f	c3		 ret	 0
?append@?$List@VAsteroid@@@@QAEXPBVAsteroid@@@Z ENDP	; List<Asteroid>::append
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$List@VDebris@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$List@VDebris@@@@QAEXXZ PROC			; List<Debris>::destroy, COMDAT
; _this$ = esi

; 47   :    if (items) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	74 47		 je	 SHORT $LN4@destroy@2

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000e	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00011	7e 18		 jle	 SHORT $LN1@destroy@2
$LL3@destroy@2:

; 51   :          delete array[i];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN2@destroy@2
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	6a 01		 push	 1
  00023	ff d0		 call	 eax
$LN2@destroy@2:

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00025	47		 inc	 edi
  00026	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00029	7c e8		 jl	 SHORT $LL3@destroy@2
$LN1@destroy@2:

; 52   : 
; 53   :       delete [] array;

  0002b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00034	83 c4 04	 add	 esp, 4

; 54   :       items       = 0;

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 55   :       extent  = 0;

  0003d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 56   :       array       = 0;

  00044	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004b	5f		 pop	 edi
$LN4@destroy@2:

; 57   :    }
; 58   : }

  0004c	c3		 ret	 0
?destroy@?$List@VDebris@@@@QAEXXZ ENDP			; List<Debris>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?append@?$List@VDebris@@@@QAEXPBVDebris@@@Z
_TEXT	SEGMENT
?append@?$List@VDebris@@@@QAEXPBVDebris@@@Z PROC	; List<Debris>::append, COMDAT
; _this$ = eax
; _item$ = edi

; 149  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 150  :    if (item) {

  00003	85 ff		 test	 edi, edi
  00005	74 17		 je	 SHORT $LN2@append@2

; 151  :       if (items+1 > extent) resize(items+1);

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	40		 inc	 eax
  0000a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0000d	7e 05		 jle	 SHORT $LN1@append@2
  0000f	e8 00 00 00 00	 call	 ?resize@?$List@VDebris@@@@AAEXH@Z ; List<Debris>::resize
$LN1@append@2:

; 152  :       array[items++] = (T*)item;

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00019	89 3c 81	 mov	 DWORD PTR [ecx+eax*4], edi
  0001c	ff 06		 inc	 DWORD PTR [esi]
$LN2@append@2:
  0001e	5e		 pop	 esi

; 153  :    }
; 154  : }

  0001f	c3		 ret	 0
?append@?$List@VDebris@@@@QAEXPBVDebris@@@Z ENDP	; List<Debris>::append
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$List@VExplosion@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$List@VExplosion@@@@QAEXXZ PROC		; List<Explosion>::destroy, COMDAT
; _this$ = esi

; 47   :    if (items) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	74 47		 je	 SHORT $LN4@destroy@3

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000e	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00011	7e 18		 jle	 SHORT $LN1@destroy@3
$LL3@destroy@3:

; 51   :          delete array[i];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN2@destroy@3
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	6a 01		 push	 1
  00023	ff d0		 call	 eax
$LN2@destroy@3:

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00025	47		 inc	 edi
  00026	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00029	7c e8		 jl	 SHORT $LL3@destroy@3
$LN1@destroy@3:

; 52   : 
; 53   :       delete [] array;

  0002b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00034	83 c4 04	 add	 esp, 4

; 54   :       items       = 0;

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 55   :       extent  = 0;

  0003d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 56   :       array       = 0;

  00044	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004b	5f		 pop	 edi
$LN4@destroy@3:

; 57   :    }
; 58   : }

  0004c	c3		 ret	 0
?destroy@?$List@VExplosion@@@@QAEXXZ ENDP		; List<Explosion>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?append@?$List@VExplosion@@@@QAEXPBVExplosion@@@Z
_TEXT	SEGMENT
?append@?$List@VExplosion@@@@QAEXPBVExplosion@@@Z PROC	; List<Explosion>::append, COMDAT
; _this$ = eax
; _item$ = edi

; 149  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 150  :    if (item) {

  00003	85 ff		 test	 edi, edi
  00005	74 17		 je	 SHORT $LN2@append@3

; 151  :       if (items+1 > extent) resize(items+1);

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	40		 inc	 eax
  0000a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0000d	7e 05		 jle	 SHORT $LN1@append@3
  0000f	e8 00 00 00 00	 call	 ?resize@?$List@VExplosion@@@@AAEXH@Z ; List<Explosion>::resize
$LN1@append@3:

; 152  :       array[items++] = (T*)item;

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00019	89 3c 81	 mov	 DWORD PTR [ecx+eax*4], edi
  0001c	ff 06		 inc	 DWORD PTR [esi]
$LN2@append@3:
  0001e	5e		 pop	 esi

; 153  :    }
; 154  : }

  0001f	c3		 ret	 0
?append@?$List@VExplosion@@@@QAEXPBVExplosion@@@Z ENDP	; List<Explosion>::append
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?append@?$List@VDrone@@@@QAEXPBVDrone@@@Z
_TEXT	SEGMENT
?append@?$List@VDrone@@@@QAEXPBVDrone@@@Z PROC		; List<Drone>::append, COMDAT
; _this$ = eax
; _item$ = edi

; 149  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 150  :    if (item) {

  00003	85 ff		 test	 edi, edi
  00005	74 17		 je	 SHORT $LN2@append@4

; 151  :       if (items+1 > extent) resize(items+1);

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	40		 inc	 eax
  0000a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0000d	7e 05		 jle	 SHORT $LN1@append@4
  0000f	e8 00 00 00 00	 call	 ?resize@?$List@VDrone@@@@AAEXH@Z ; List<Drone>::resize
$LN1@append@4:

; 152  :       array[items++] = (T*)item;

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00019	89 3c 81	 mov	 DWORD PTR [ecx+eax*4], edi
  0001c	ff 06		 inc	 DWORD PTR [esi]
$LN2@append@4:
  0001e	5e		 pop	 esi

; 153  :    }
; 154  : }

  0001f	c3		 ret	 0
?append@?$List@VDrone@@@@QAEXPBVDrone@@@Z ENDP		; List<Drone>::append
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$List@VShot@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$List@VShot@@@@QAEXXZ PROC			; List<Shot>::destroy, COMDAT
; _this$ = esi

; 47   :    if (items) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	74 47		 je	 SHORT $LN4@destroy@4

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000e	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00011	7e 18		 jle	 SHORT $LN1@destroy@4
$LL3@destroy@4:

; 51   :          delete array[i];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN2@destroy@4
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	6a 01		 push	 1
  00023	ff d0		 call	 eax
$LN2@destroy@4:

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00025	47		 inc	 edi
  00026	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00029	7c e8		 jl	 SHORT $LL3@destroy@4
$LN1@destroy@4:

; 52   : 
; 53   :       delete [] array;

  0002b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00034	83 c4 04	 add	 esp, 4

; 54   :       items       = 0;

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 55   :       extent  = 0;

  0003d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 56   :       array       = 0;

  00044	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004b	5f		 pop	 edi
$LN4@destroy@4:

; 57   :    }
; 58   : }

  0004c	c3		 ret	 0
?destroy@?$List@VShot@@@@QAEXXZ ENDP			; List<Shot>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$List@VShip@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$List@VShip@@@@QAEXXZ PROC			; List<Ship>::destroy, COMDAT
; _this$ = esi

; 47   :    if (items) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	74 47		 je	 SHORT $LN4@destroy@5

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000e	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00011	7e 18		 jle	 SHORT $LN1@destroy@5
$LL3@destroy@5:

; 51   :          delete array[i];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN2@destroy@5
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	6a 01		 push	 1
  00023	ff d0		 call	 eax
$LN2@destroy@5:

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00025	47		 inc	 edi
  00026	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00029	7c e8		 jl	 SHORT $LL3@destroy@5
$LN1@destroy@5:

; 52   : 
; 53   :       delete [] array;

  0002b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00034	83 c4 04	 add	 esp, 4

; 54   :       items       = 0;

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 55   :       extent  = 0;

  0003d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 56   :       array       = 0;

  00044	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004b	5f		 pop	 edi
$LN4@destroy@5:

; 57   :    }
; 58   : }

  0004c	c3		 ret	 0
?destroy@?$List@VShip@@@@QAEXXZ ENDP			; List<Ship>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$List@VElement@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$List@VElement@@@@QAEXXZ PROC			; List<Element>::destroy, COMDAT
; _this$ = esi

; 47   :    if (items) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	74 47		 je	 SHORT $LN4@destroy@6

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000e	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00011	7e 18		 jle	 SHORT $LN1@destroy@6
$LL3@destroy@6:

; 51   :          delete array[i];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN2@destroy@6
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	6a 01		 push	 1
  00023	ff d0		 call	 eax
$LN2@destroy@6:

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00025	47		 inc	 edi
  00026	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00029	7c e8		 jl	 SHORT $LL3@destroy@6
$LN1@destroy@6:

; 52   : 
; 53   :       delete [] array;

  0002b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00034	83 c4 04	 add	 esp, 4

; 54   :       items       = 0;

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 55   :       extent  = 0;

  0003d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 56   :       array       = 0;

  00044	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004b	5f		 pop	 edi
$LN4@destroy@6:

; 57   :    }
; 58   : }

  0004c	c3		 ret	 0
?destroy@?$List@VElement@@@@QAEXXZ ENDP			; List<Element>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$List@VSimSplash@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$List@VSimSplash@@@@QAEXXZ PROC		; List<SimSplash>::destroy, COMDAT
; _this$ = esi

; 47   :    if (items) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	74 47		 je	 SHORT $LN4@destroy@7

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000e	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00011	7e 22		 jle	 SHORT $LN1@destroy@7
  00013	53		 push	 ebx
$LL3@destroy@7:

; 51   :          delete array[i];

  00014	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00017	8b 1c b8	 mov	 ebx, DWORD PTR [eax+edi*4]
  0001a	85 db		 test	 ebx, ebx
  0001c	74 10		 je	 SHORT $LN2@destroy@7
  0001e	8b cb		 mov	 ecx, ebx
  00020	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  00025	53		 push	 ebx
  00026	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002b	83 c4 04	 add	 esp, 4
$LN2@destroy@7:

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  0002e	47		 inc	 edi
  0002f	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00032	7c e0		 jl	 SHORT $LL3@destroy@7
  00034	5b		 pop	 ebx
$LN1@destroy@7:

; 52   : 
; 53   :       delete [] array;

  00035	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0003e	83 c4 04	 add	 esp, 4

; 54   :       items       = 0;

  00041	33 c0		 xor	 eax, eax
  00043	89 06		 mov	 DWORD PTR [esi], eax

; 55   :       extent  = 0;

  00045	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 56   :       array       = 0;

  00048	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004b	5f		 pop	 edi
$LN4@destroy@7:

; 57   :    }
; 58   : }

  0004c	c3		 ret	 0
?destroy@?$List@VSimSplash@@@@QAEXXZ ENDP		; List<SimSplash>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?append@?$List@VSimSplash@@@@QAEXPBVSimSplash@@@Z
_TEXT	SEGMENT
?append@?$List@VSimSplash@@@@QAEXPBVSimSplash@@@Z PROC	; List<SimSplash>::append, COMDAT
; _this$ = eax
; _item$ = edi

; 149  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 150  :    if (item) {

  00003	85 ff		 test	 edi, edi
  00005	74 17		 je	 SHORT $LN2@append@5

; 151  :       if (items+1 > extent) resize(items+1);

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	40		 inc	 eax
  0000a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0000d	7e 05		 jle	 SHORT $LN1@append@5
  0000f	e8 00 00 00 00	 call	 ?resize@?$List@VSimSplash@@@@AAEXH@Z ; List<SimSplash>::resize
$LN1@append@5:

; 152  :       array[items++] = (T*)item;

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00019	89 3c 81	 mov	 DWORD PTR [ecx+eax*4], edi
  0001c	ff 06		 inc	 DWORD PTR [esi]
$LN2@append@5:
  0001e	5e		 pop	 esi

; 153  :    }
; 154  : }

  0001f	c3		 ret	 0
?append@?$List@VSimSplash@@@@QAEXPBVSimSplash@@@Z ENDP	; List<SimSplash>::append
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$List@VSimHyper@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$List@VSimHyper@@@@QAEXXZ PROC		; List<SimHyper>::destroy, COMDAT
; _this$ = esi

; 47   :    if (items) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	74 44		 je	 SHORT $LN4@destroy@8

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000e	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00011	7e 15		 jle	 SHORT $LN1@destroy@8
$LL3@destroy@8:

; 51   :          delete array[i];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	47		 inc	 edi
  00020	83 c4 04	 add	 esp, 4
  00023	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00026	7c eb		 jl	 SHORT $LL3@destroy@8
$LN1@destroy@8:

; 52   : 
; 53   :       delete [] array;

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00031	83 c4 04	 add	 esp, 4

; 54   :       items       = 0;

  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 55   :       extent  = 0;

  0003a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 56   :       array       = 0;

  00041	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00048	5f		 pop	 edi
$LN4@destroy@8:

; 57   :    }
; 58   : }

  00049	c3		 ret	 0
?destroy@?$List@VSimHyper@@@@QAEXXZ ENDP		; List<SimHyper>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?append@?$List@VSimHyper@@@@QAEXPBVSimHyper@@@Z
_TEXT	SEGMENT
?append@?$List@VSimHyper@@@@QAEXPBVSimHyper@@@Z PROC	; List<SimHyper>::append, COMDAT
; _this$ = eax
; _item$ = edi

; 149  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 150  :    if (item) {

  00003	85 ff		 test	 edi, edi
  00005	74 17		 je	 SHORT $LN2@append@6

; 151  :       if (items+1 > extent) resize(items+1);

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	40		 inc	 eax
  0000a	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0000d	7e 05		 jle	 SHORT $LN1@append@6
  0000f	e8 00 00 00 00	 call	 ?resize@?$List@VSimHyper@@@@AAEXH@Z ; List<SimHyper>::resize
$LN1@append@6:

; 152  :       array[items++] = (T*)item;

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00019	89 3c 81	 mov	 DWORD PTR [ecx+eax*4], edi
  0001c	ff 06		 inc	 DWORD PTR [esi]
$LN2@append@6:
  0001e	5e		 pop	 esi

; 153  :    }
; 154  : }

  0001f	c3		 ret	 0
?append@?$List@VSimHyper@@@@QAEXPBVSimHyper@@@Z ENDP	; List<SimHyper>::append
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$List@VSimRegion@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$List@VSimRegion@@@@QAEXXZ PROC		; List<SimRegion>::destroy, COMDAT
; _this$ = esi

; 47   :    if (items) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	74 47		 je	 SHORT $LN4@destroy@9

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000e	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00011	7e 18		 jle	 SHORT $LN1@destroy@9
$LL3@destroy@9:

; 51   :          delete array[i];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN2@destroy@9
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	6a 01		 push	 1
  00023	ff d0		 call	 eax
$LN2@destroy@9:

; 48   :       items = 0;  // prevent dangerous re-entrancy
; 49   : 
; 50   :       for (int i = 0; i < extent; i++)

  00025	47		 inc	 edi
  00026	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00029	7c e8		 jl	 SHORT $LL3@destroy@9
$LN1@destroy@9:

; 52   : 
; 53   :       delete [] array;

  0002b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00034	83 c4 04	 add	 esp, 4

; 54   :       items       = 0;

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 55   :       extent  = 0;

  0003d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 56   :       array       = 0;

  00044	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004b	5f		 pop	 edi
$LN4@destroy@9:

; 57   :    }
; 58   : }

  0004c	c3		 ret	 0
?destroy@?$List@VSimRegion@@@@QAEXXZ ENDP		; List<SimRegion>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?clear@?$List@VSimRegion@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$List@VSimRegion@@@@QAEXXZ PROC			; List<SimRegion>::clear, COMDAT
; _this$ = esi

; 38   :    delete [] array;

  00000	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 39   :    items       = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	83 c4 04	 add	 esp, 4
  0000e	89 06		 mov	 DWORD PTR [esi], eax

; 40   :    extent  = 0;

  00010	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 41   :    array       = 0;

  00013	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 42   : }

  00016	c3		 ret	 0
?clear@?$List@VSimRegion@@@@QAEXXZ ENDP			; List<SimRegion>::clear
; Function compile flags: /Ogtp
; File c:\matrix games\dev\foundationex\list.h
_TEXT	ENDS
;	COMDAT ??C?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ
_TEXT	SEGMENT
??C?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ PROC	; ListIter<Explosion>::operator->, COMDAT
; _this$ = eax

; 86   :    T*  operator->() { return value();     }

  00000	e9 00 00 00 00	 jmp	 ?value@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::value
??C?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ENDP	; ListIter<Explosion>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$ListIter@VExplosion@@@@QAEHXZ
_TEXT	SEGMENT
??E?$ListIter@VExplosion@@@@QAEHXZ PROC			; ListIter<Explosion>::operator++, COMDAT
; _this$ = edx

; 84   :    int operator++() { return next() != 0; }

  00000	e8 00 00 00 00	 call	 ?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::next
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	f7 d8		 neg	 eax
  0000b	c3		 ret	 0
??E?$ListIter@VExplosion@@@@QAEHXZ ENDP			; ListIter<Explosion>::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$ListIter@VExplosion@@@@QAE@AAV?$List@VExplosion@@@@@Z
_TEXT	SEGMENT
??0?$ListIter@VExplosion@@@@QAE@AAV?$List@VExplosion@@@@@Z PROC ; ListIter<Explosion>::ListIter<Explosion>, COMDAT
; _this$ = eax
; _l$ = ecx

; 82   :    ListIter(List<T>& l)             : list(&l),     step(-1)      { }

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00009	c3		 ret	 0
??0?$ListIter@VExplosion@@@@QAE@AAV?$List@VExplosion@@@@@Z ENDP ; ListIter<Explosion>::ListIter<Explosion>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$ListIter@VSimSplash@@@@QAEHXZ
_TEXT	SEGMENT
??E?$ListIter@VSimSplash@@@@QAEHXZ PROC			; ListIter<SimSplash>::operator++, COMDAT
; _this$ = edx

; 84   :    int operator++() { return next() != 0; }

  00000	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ ; ListIter<SimSplash>::next
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	f7 d8		 neg	 eax
  0000b	c3		 ret	 0
??E?$ListIter@VSimSplash@@@@QAEHXZ ENDP			; ListIter<SimSplash>::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$ListIter@VSimSplash@@@@QAE@AAV?$List@VSimSplash@@@@@Z
_TEXT	SEGMENT
??0?$ListIter@VSimSplash@@@@QAE@AAV?$List@VSimSplash@@@@@Z PROC ; ListIter<SimSplash>::ListIter<SimSplash>, COMDAT
; _this$ = eax
; _l$ = ecx

; 82   :    ListIter(List<T>& l)             : list(&l),     step(-1)      { }

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00009	c3		 ret	 0
??0?$ListIter@VSimSplash@@@@QAE@AAV?$List@VSimSplash@@@@@Z ENDP ; ListIter<SimSplash>::ListIter<SimSplash>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$ListIter@VSimHyper@@@@QAEHXZ
_TEXT	SEGMENT
??E?$ListIter@VSimHyper@@@@QAEHXZ PROC			; ListIter<SimHyper>::operator++, COMDAT
; _this$ = edx

; 84   :    int operator++() { return next() != 0; }

  00000	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ ; ListIter<SimHyper>::next
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	f7 d8		 neg	 eax
  0000b	c3		 ret	 0
??E?$ListIter@VSimHyper@@@@QAEHXZ ENDP			; ListIter<SimHyper>::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$ListIter@VSimHyper@@@@QAE@AAV?$List@VSimHyper@@@@@Z
_TEXT	SEGMENT
??0?$ListIter@VSimHyper@@@@QAE@AAV?$List@VSimHyper@@@@@Z PROC ; ListIter<SimHyper>::ListIter<SimHyper>, COMDAT
; _this$ = eax
; _l$ = ecx

; 82   :    ListIter(List<T>& l)             : list(&l),     step(-1)      { }

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00009	c3		 ret	 0
??0?$ListIter@VSimHyper@@@@QAE@AAV?$List@VSimHyper@@@@@Z ENDP ; ListIter<SimHyper>::ListIter<SimHyper>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$ListIter@VModel@@@@QAEHXZ
_TEXT	SEGMENT
??E?$ListIter@VModel@@@@QAEHXZ PROC			; ListIter<Model>::operator++, COMDAT
; _this$ = ecx

; 84   :    int operator++() { return next() != 0; }

  00000	e8 00 00 00 00	 call	 ?next@?$ListIter@VModel@@@@QAEPAVModel@@XZ ; ListIter<Model>::next
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	f7 d8		 neg	 eax
  0000b	c3		 ret	 0
??E?$ListIter@VModel@@@@QAEHXZ ENDP			; ListIter<Model>::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$ListIter@VModel@@@@QAE@AAV?$List@VModel@@@@@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??0?$ListIter@VModel@@@@QAE@AAV?$List@VModel@@@@@Z PROC	; ListIter<Model>::ListIter<Model>, COMDAT
; _this$ = ecx

; 82   :    ListIter(List<T>& l)             : list(&l),     step(-1)      { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0?$ListIter@VModel@@@@QAE@AAV?$List@VModel@@@@@Z ENDP	; ListIter<Model>::ListIter<Model>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$List@VAsteroid@@@@QAE@XZ
_TEXT	SEGMENT
??1?$List@VAsteroid@@@@QAE@XZ PROC			; List<Asteroid>::~List<Asteroid>, COMDAT
; _this$ = eax

; 30   :    ~List()  { delete [] array; }

  00000	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
??1?$List@VAsteroid@@@@QAE@XZ ENDP			; List<Asteroid>::~List<Asteroid>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$List@VAsteroid@@@@QAE@XZ
_TEXT	SEGMENT
??0?$List@VAsteroid@@@@QAE@XZ PROC			; List<Asteroid>::List<Asteroid>, COMDAT
; _this$ = eax

; 28   :    List()   : items(0), extent(0), array(0) { }

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	c3		 ret	 0
??0?$List@VAsteroid@@@@QAE@XZ ENDP			; List<Asteroid>::List<Asteroid>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$List@VDebris@@@@QBEHXZ
_TEXT	SEGMENT
?size@?$List@VDebris@@@@QBEHXZ PROC			; List<Debris>::size, COMDAT
; _this$ = eax

; 50   :    int      size()    const      { return items;  }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	c3		 ret	 0
?size@?$List@VDebris@@@@QBEHXZ ENDP			; List<Debris>::size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$List@VDebris@@@@QAE@XZ
_TEXT	SEGMENT
??1?$List@VDebris@@@@QAE@XZ PROC			; List<Debris>::~List<Debris>, COMDAT
; _this$ = eax

; 30   :    ~List()  { delete [] array; }

  00000	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
??1?$List@VDebris@@@@QAE@XZ ENDP			; List<Debris>::~List<Debris>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$List@VDebris@@@@QAE@XZ
_TEXT	SEGMENT
??0?$List@VDebris@@@@QAE@XZ PROC			; List<Debris>::List<Debris>, COMDAT
; _this$ = eax

; 28   :    List()   : items(0), extent(0), array(0) { }

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	c3		 ret	 0
??0?$List@VDebris@@@@QAE@XZ ENDP			; List<Debris>::List<Debris>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$List@VExplosion@@@@QAE@XZ
_TEXT	SEGMENT
??1?$List@VExplosion@@@@QAE@XZ PROC			; List<Explosion>::~List<Explosion>, COMDAT
; _this$ = eax

; 30   :    ~List()  { delete [] array; }

  00000	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
??1?$List@VExplosion@@@@QAE@XZ ENDP			; List<Explosion>::~List<Explosion>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$List@VExplosion@@@@QAE@XZ
_TEXT	SEGMENT
??0?$List@VExplosion@@@@QAE@XZ PROC			; List<Explosion>::List<Explosion>, COMDAT
; _this$ = eax

; 28   :    List()   : items(0), extent(0), array(0) { }

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	c3		 ret	 0
??0?$List@VExplosion@@@@QAE@XZ ENDP			; List<Explosion>::List<Explosion>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$List@VDrone@@@@QAE@XZ
_TEXT	SEGMENT
??1?$List@VDrone@@@@QAE@XZ PROC				; List<Drone>::~List<Drone>, COMDAT
; _this$ = eax

; 30   :    ~List()  { delete [] array; }

  00000	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
??1?$List@VDrone@@@@QAE@XZ ENDP				; List<Drone>::~List<Drone>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$List@VDrone@@@@QAE@XZ
_TEXT	SEGMENT
??0?$List@VDrone@@@@QAE@XZ PROC				; List<Drone>::List<Drone>, COMDAT
; _this$ = eax

; 28   :    List()   : items(0), extent(0), array(0) { }

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	c3		 ret	 0
??0?$List@VDrone@@@@QAE@XZ ENDP				; List<Drone>::List<Drone>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$List@VSimSplash@@@@QBEHXZ
_TEXT	SEGMENT
?size@?$List@VSimSplash@@@@QBEHXZ PROC			; List<SimSplash>::size, COMDAT
; _this$ = eax

; 50   :    int      size()    const      { return items;  }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	c3		 ret	 0
?size@?$List@VSimSplash@@@@QBEHXZ ENDP			; List<SimSplash>::size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$List@VSimSplash@@@@QAE@XZ
_TEXT	SEGMENT
??1?$List@VSimSplash@@@@QAE@XZ PROC			; List<SimSplash>::~List<SimSplash>, COMDAT
; _this$ = eax

; 30   :    ~List()  { delete [] array; }

  00000	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
??1?$List@VSimSplash@@@@QAE@XZ ENDP			; List<SimSplash>::~List<SimSplash>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$List@VSimSplash@@@@QAE@XZ
_TEXT	SEGMENT
??0?$List@VSimSplash@@@@QAE@XZ PROC			; List<SimSplash>::List<SimSplash>, COMDAT
; _this$ = eax

; 28   :    List()   : items(0), extent(0), array(0) { }

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	c3		 ret	 0
??0?$List@VSimSplash@@@@QAE@XZ ENDP			; List<SimSplash>::List<SimSplash>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$List@VSimHyper@@@@QBEHXZ
_TEXT	SEGMENT
?size@?$List@VSimHyper@@@@QBEHXZ PROC			; List<SimHyper>::size, COMDAT
; _this$ = eax

; 50   :    int      size()    const      { return items;  }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	c3		 ret	 0
?size@?$List@VSimHyper@@@@QBEHXZ ENDP			; List<SimHyper>::size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$List@VSimHyper@@@@QAE@XZ
_TEXT	SEGMENT
??1?$List@VSimHyper@@@@QAE@XZ PROC			; List<SimHyper>::~List<SimHyper>, COMDAT
; _this$ = eax

; 30   :    ~List()  { delete [] array; }

  00000	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
??1?$List@VSimHyper@@@@QAE@XZ ENDP			; List<SimHyper>::~List<SimHyper>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$List@VSimHyper@@@@QAE@XZ
_TEXT	SEGMENT
??0?$List@VSimHyper@@@@QAE@XZ PROC			; List<SimHyper>::List<SimHyper>, COMDAT
; _this$ = eax

; 28   :    List()   : items(0), extent(0), array(0) { }

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	c3		 ret	 0
??0?$List@VSimHyper@@@@QAE@XZ ENDP			; List<SimHyper>::List<SimHyper>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?isEmpty@?$List@VSimRegion@@@@QBE_NXZ
_TEXT	SEGMENT
?isEmpty@?$List@VSimRegion@@@@QBE_NXZ PROC		; List<SimRegion>::isEmpty, COMDAT
; _this$ = ecx

; 51   :    bool     isEmpty() const      { return !items; }

  00000	33 c0		 xor	 eax, eax
  00002	39 01		 cmp	 DWORD PTR [ecx], eax
  00004	0f 94 c0	 sete	 al
  00007	c3		 ret	 0
?isEmpty@?$List@VSimRegion@@@@QBE_NXZ ENDP		; List<SimRegion>::isEmpty
_TEXT	ENDS
PUBLIC	?NetDockShip@SimRegion@@IAEXPAVShip@@0PAVFlightDeck@@@Z ; SimRegion::NetDockShip
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
;	COMDAT ?NetDockShip@SimRegion@@IAEXPAVShip@@0PAVFlightDeck@@@Z
_TEXT	SEGMENT
_carrier$ = 8						; size = 4
?NetDockShip@SimRegion@@IAEXPAVShip@@0PAVFlightDeck@@@Z PROC ; SimRegion::NetDockShip, COMDAT
; _ship$ = eax
; _deck$ = ecx

; 3270 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3271 : 	if (!ship || !carrier || !deck) return;

  00003	85 c0		 test	 eax, eax
  00005	74 12		 je	 SHORT $LN1@NetDockShi
  00007	83 7d 08 00	 cmp	 DWORD PTR _carrier$[ebp], 0
  0000b	74 0c		 je	 SHORT $LN1@NetDockShi
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 08		 je	 SHORT $LN1@NetDockShi

; 3272 : 
; 3273 : 	deck->Dock(ship);

  00011	8b 11		 mov	 edx, DWORD PTR [ecx]
  00013	50		 push	 eax
  00014	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00017	ff d0		 call	 eax
$LN1@NetDockShi:

; 3274 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?NetDockShip@SimRegion@@IAEXPAVShip@@0PAVFlightDeck@@@Z ENDP ; SimRegion::NetDockShip
_TEXT	ENDS
PUBLIC	?ShowGrid@SimRegion@@QAEXH@Z			; SimRegion::ShowGrid
; Function compile flags: /Ogtp
;	COMDAT ?ShowGrid@SimRegion@@QAEXH@Z
_TEXT	SEGMENT
_show$ = 8						; size = 4
?ShowGrid@SimRegion@@QAEXH@Z PROC			; SimRegion::ShowGrid, COMDAT
; _this$ = eax

; 2566 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2567 : 	if (grid) {

  00003	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00007	74 19		 je	 SHORT $LN1@ShowGrid

; 2568 : 		if (show)

  00009	83 7d 08 00	 cmp	 DWORD PTR _show$[ebp], 0

; 2569 : 		grid->Show();

  0000d	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	74 09		 je	 SHORT $LN2@ShowGrid
  00014	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]

; 2570 : 		else
; 2571 : 		grid->Hide();

  00017	ff d2		 call	 edx

; 2572 : 	}
; 2573 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN2@ShowGrid:

; 2570 : 		else
; 2571 : 		grid->Hide();

  0001d	8b 50 48	 mov	 edx, DWORD PTR [eax+72]
  00020	ff d2		 call	 edx
$LN1@ShowGrid:

; 2572 : 	}
; 2573 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?ShowGrid@SimRegion@@QAEXH@Z ENDP			; SimRegion::ShowGrid
_TEXT	ENDS
PUBLIC	__real@408f400000000000
PUBLIC	__real@41f0000000000000
PUBLIC	?MissionClock@Sim@@QBENXZ			; Sim::MissionClock
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?MissionClock@Sim@@QBENXZ
_TEXT	SEGMENT
tv131 = 8						; size = 4
_this$ = 8						; size = 4
?MissionClock@Sim@@QBENXZ PROC				; Sim::MissionClock, COMDAT

; 1898 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1899 : 	return (Game::GameTime() - start_time) / 1000.0;

  00003	e8 00 00 00 00	 call	 ?GameTime@Game@@SAKXZ	; Game::GameTime
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	2b 81 c8 00 00
	00		 sub	 eax, DWORD PTR [ecx+200]
  00011	89 45 08	 mov	 DWORD PTR tv131[ebp], eax
  00014	db 45 08	 fild	 DWORD PTR tv131[ebp]
  00017	79 06		 jns	 SHORT $LN3@MissionClo
  00019	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN3@MissionClo:
  0001f	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@408f400000000000

; 1900 : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?MissionClock@Sim@@QBENXZ ENDP				; Sim::MissionClock
_TEXT	ENDS
PUBLIC	?GridShown@Sim@@QBE_NXZ				; Sim::GridShown
; Function compile flags: /Ogtp
;	COMDAT ?GridShown@Sim@@QBE_NXZ
_TEXT	SEGMENT
?GridShown@Sim@@QBE_NXZ PROC				; Sim::GridShown, COMDAT
; _this$ = eax

; 1233 : 	return grid_shown;

  00000	8a 80 bd 00 00
	00		 mov	 al, BYTE PTR [eax+189]

; 1234 : }

  00006	c3		 ret	 0
?GridShown@Sim@@QBE_NXZ ENDP				; Sim::GridShown
_TEXT	ENDS
PUBLIC	?NetDockShip@Sim@@QAEXPAVShip@@0PAVFlightDeck@@@Z ; Sim::NetDockShip
; Function compile flags: /Ogtp
;	COMDAT ?NetDockShip@Sim@@QAEXPAVShip@@0PAVFlightDeck@@@Z
_TEXT	SEGMENT
_carrier$ = 8						; size = 4
_deck$ = 12						; size = 4
?NetDockShip@Sim@@QAEXPAVShip@@0PAVFlightDeck@@@Z PROC	; Sim::NetDockShip, COMDAT
; _ship$ = esi

; 1045 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1046 : 	SimRegion* rgn = ship->GetRegion();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  0000b	8b ce		 mov	 ecx, esi
  0000d	ff d2		 call	 edx

; 1047 : 	if (rgn)

  0000f	85 c0		 test	 eax, eax
  00011	74 0e		 je	 SHORT $LN1@NetDockShi@2

; 1048 : 	rgn->NetDockShip(ship, carrier, deck);

  00013	8b 45 08	 mov	 eax, DWORD PTR _carrier$[ebp]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _deck$[ebp]
  00019	50		 push	 eax
  0001a	8b c6		 mov	 eax, esi
  0001c	e8 00 00 00 00	 call	 ?NetDockShip@SimRegion@@IAEXPAVShip@@0PAVFlightDeck@@@Z ; SimRegion::NetDockShip
$LN1@NetDockShi@2:

; 1049 : }

  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?NetDockShip@Sim@@QAEXPAVShip@@0PAVFlightDeck@@@Z ENDP	; Sim::NetDockShip
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GResource@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GResource@@UAEPAXI@Z PROC				; Resource::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1Resource@@UAE@XZ	; Resource::~Resource
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GResource@@UAEPAXI@Z ENDP				; Resource::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0Resource@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0Resource@@QAE@ABV0@@Z PROC				; Resource::Resource, COMDAT
; _this$ = eax
; ___that$ = ecx
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Resource@@6B@
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000c	c3		 ret	 0
??0Resource@@QAE@ABV0@@Z ENDP				; Resource::Resource
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GBitmap@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GBitmap@@UAEPAXI@Z PROC				; Bitmap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1Bitmap@@UAE@XZ	; Bitmap::~Bitmap
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GBitmap@@UAEPAXI@Z ENDP				; Bitmap::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0Bitmap@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0Bitmap@@QAE@ABV0@@Z PROC				; Bitmap::Bitmap, COMDAT
; _this$ = eax
; ___that$ = ecx
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Resource@@6B@
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Bitmap@@6B@
  00012	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00015	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00018	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0001b	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0001e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00021	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00024	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00027	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0002a	0f b6 51 18	 movzx	 edx, BYTE PTR [ecx+24]
  0002e	88 50 18	 mov	 BYTE PTR [eax+24], dl
  00031	0f b6 51 19	 movzx	 edx, BYTE PTR [ecx+25]
  00035	88 50 19	 mov	 BYTE PTR [eax+25], dl
  00038	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  0003c	88 50 1a	 mov	 BYTE PTR [eax+26], dl
  0003f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00042	56		 push	 esi
  00043	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  00046	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00049	57		 push	 edi
  0004a	89 50 20	 mov	 DWORD PTR [eax+32], edx
  0004d	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00050	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00053	8d 78 28	 lea	 edi, DWORD PTR [eax+40]
  00056	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0005b	89 50 24	 mov	 DWORD PTR [eax+36], edx
  0005e	f3 a5		 rep movsd
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	c3		 ret	 0
??0Bitmap@@QAE@ABV0@@Z ENDP				; Bitmap::Bitmap
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MissionEvent@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$5
__ehfuncinfo$??0MissionEvent@@QAE@ABV0@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0MissionEvent@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0MissionEvent@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___that$ = 12						; size = 4
??0MissionEvent@@QAE@ABV0@@Z PROC			; MissionEvent::MissionEvent, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0MissionEvent@@QAE@ABV0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00028	8b 75 0c	 mov	 esi, DWORD PTR ___that$[ebp]
  0002b	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7MissionEvent@@6B@
  00031	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00034	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00037	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0003a	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  0003d	dd 46 10	 fld	 QWORD PTR [esi+16]
  00040	dd 5b 10	 fstp	 QWORD PTR [ebx+16]
  00043	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00046	dd 46 18	 fld	 QWORD PTR [esi+24]
  00049	50		 push	 eax
  0004a	dd 5b 18	 fstp	 QWORD PTR [ebx+24]
  0004d	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00050	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  00053	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  00056	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  0005b	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  0005e	51		 push	 ecx
  0005f	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00069	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  0006e	8d 56 34	 lea	 edx, DWORD PTR [esi+52]
  00071	52		 push	 edx
  00072	8d 4b 34	 lea	 ecx, DWORD PTR [ebx+52]
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00079	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  0007e	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  00081	50		 push	 eax
  00082	8d 4b 3c	 lea	 ecx, DWORD PTR [ebx+60]
  00085	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00089	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  0008e	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  00091	51		 push	 ecx
  00092	8d 4b 44	 lea	 ecx, DWORD PTR [ebx+68]
  00095	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00099	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  0009e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000a2	f3 0f 7e 46 4c	 movq	 xmm0, QWORD PTR [esi+76]
  000a7	66 0f d6 43 4c	 movq	 QWORD PTR [ebx+76], xmm0
  000ac	f3 0f 7e 46 54	 movq	 xmm0, QWORD PTR [esi+84]
  000b1	66 0f d6 43 54	 movq	 QWORD PTR [ebx+84], xmm0
  000b6	f3 0f 7e 46 5c	 movq	 xmm0, QWORD PTR [esi+92]
  000bb	66 0f d6 43 5c	 movq	 QWORD PTR [ebx+92], xmm0
  000c0	f3 0f 7e 46 64	 movq	 xmm0, QWORD PTR [esi+100]
  000c5	66 0f d6 43 64	 movq	 QWORD PTR [ebx+100], xmm0
  000ca	f3 0f 7e 46 6c	 movq	 xmm0, QWORD PTR [esi+108]
  000cf	66 0f d6 43 6c	 movq	 QWORD PTR [ebx+108], xmm0
  000d4	8b 56 74	 mov	 edx, DWORD PTR [esi+116]
  000d7	89 53 74	 mov	 DWORD PTR [ebx+116], edx
  000da	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  000dd	89 43 78	 mov	 DWORD PTR [ebx+120], eax
  000e0	f3 0f 7e 46 7c	 movq	 xmm0, QWORD PTR [esi+124]
  000e5	66 0f d6 43 7c	 movq	 QWORD PTR [ebx+124], xmm0
  000ea	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  000f0	89 8b 84 00 00
	00		 mov	 DWORD PTR [ebx+132], ecx
  000f6	f3 0f 7e 86 88
	00 00 00	 movq	 xmm0, QWORD PTR [esi+136]
  000fe	66 0f d6 83 88
	00 00 00	 movq	 QWORD PTR [ebx+136], xmm0
  00106	f3 0f 7e 86 90
	00 00 00	 movq	 xmm0, QWORD PTR [esi+144]
  0010e	66 0f d6 83 90
	00 00 00	 movq	 QWORD PTR [ebx+144], xmm0
  00116	8b 96 98 00 00
	00		 mov	 edx, DWORD PTR [esi+152]
  0011c	8d 86 9c 00 00
	00		 lea	 eax, DWORD PTR [esi+156]
  00122	50		 push	 eax
  00123	8d 8b 9c 00 00
	00		 lea	 ecx, DWORD PTR [ebx+156]
  00129	89 93 98 00 00
	00		 mov	 DWORD PTR [ebx+152], edx
  0012f	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  00134	8d 8e a4 00 00
	00		 lea	 ecx, DWORD PTR [esi+164]
  0013a	51		 push	 ecx
  0013b	8d 8b a4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+164]
  00141	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00145	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  0014a	f3 0f 7e 86 ac
	00 00 00	 movq	 xmm0, QWORD PTR [esi+172]
  00152	66 0f d6 83 ac
	00 00 00	 movq	 QWORD PTR [ebx+172], xmm0
  0015a	f3 0f 7e 86 b4
	00 00 00	 movq	 xmm0, QWORD PTR [esi+180]
  00162	66 0f d6 83 b4
	00 00 00	 movq	 QWORD PTR [ebx+180], xmm0
  0016a	f3 0f 7e 86 bc
	00 00 00	 movq	 xmm0, QWORD PTR [esi+188]
  00172	66 0f d6 83 bc
	00 00 00	 movq	 QWORD PTR [ebx+188], xmm0
  0017a	f3 0f 7e 86 c4
	00 00 00	 movq	 xmm0, QWORD PTR [esi+196]
  00182	66 0f d6 83 c4
	00 00 00	 movq	 QWORD PTR [ebx+196], xmm0
  0018a	f3 0f 7e 86 cc
	00 00 00	 movq	 xmm0, QWORD PTR [esi+204]
  00192	66 0f d6 83 cc
	00 00 00	 movq	 QWORD PTR [ebx+204], xmm0
  0019a	8b 96 d4 00 00
	00		 mov	 edx, DWORD PTR [esi+212]
  001a0	89 93 d4 00 00
	00		 mov	 DWORD PTR [ebx+212], edx
  001a6	c7 83 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+216], OFFSET ??_7Resource@@6B@
  001b0	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  001b6	89 83 dc 00 00
	00		 mov	 DWORD PTR [ebx+220], eax
  001bc	c7 83 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+216], OFFSET ??_7Bitmap@@6B@
  001c6	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  001cc	89 8b e0 00 00
	00		 mov	 DWORD PTR [ebx+224], ecx
  001d2	8b 96 e4 00 00
	00		 mov	 edx, DWORD PTR [esi+228]
  001d8	89 93 e4 00 00
	00		 mov	 DWORD PTR [ebx+228], edx
  001de	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  001e4	89 83 e8 00 00
	00		 mov	 DWORD PTR [ebx+232], eax
  001ea	8b 8e ec 00 00
	00		 mov	 ecx, DWORD PTR [esi+236]
  001f0	89 8b ec 00 00
	00		 mov	 DWORD PTR [ebx+236], ecx
  001f6	8a 96 f0 00 00
	00		 mov	 dl, BYTE PTR [esi+240]
  001fc	88 93 f0 00 00
	00		 mov	 BYTE PTR [ebx+240], dl
  00202	8a 86 f1 00 00
	00		 mov	 al, BYTE PTR [esi+241]
  00208	88 83 f1 00 00
	00		 mov	 BYTE PTR [ebx+241], al
  0020e	8a 8e f2 00 00
	00		 mov	 cl, BYTE PTR [esi+242]
  00214	88 8b f2 00 00
	00		 mov	 BYTE PTR [ebx+242], cl
  0021a	8b 96 f4 00 00
	00		 mov	 edx, DWORD PTR [esi+244]
  00220	89 93 f4 00 00
	00		 mov	 DWORD PTR [ebx+244], edx
  00226	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  0022c	8b 55 0c	 mov	 edx, DWORD PTR ___that$[ebp]
  0022f	89 83 f8 00 00
	00		 mov	 DWORD PTR [ebx+248], eax
  00235	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0023b	89 8b fc 00 00
	00		 mov	 DWORD PTR [ebx+252], ecx
  00241	81 c6 00 01 00
	00		 add	 esi, 256		; 00000100H
  00247	8d bb 00 01 00
	00		 lea	 edi, DWORD PTR [ebx+256]
  0024d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00252	f3 a5		 rep movsd
  00254	8b 82 40 01 00
	00		 mov	 eax, DWORD PTR [edx+320]
  0025a	89 83 40 01 00
	00		 mov	 DWORD PTR [ebx+320], eax
  00260	8b c3		 mov	 eax, ebx
  00262	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00265	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026c	59		 pop	 ecx
  0026d	5f		 pop	 edi
  0026e	5e		 pop	 esi
  0026f	5b		 pop	 ebx
  00270	8b e5		 mov	 esp, ebp
  00272	5d		 pop	 ebp
  00273	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$0:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 24	 add	 ecx, 36			; 00000024H
  00006	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$1:
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00011	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$2:
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 34	 add	 ecx, 52			; 00000034H
  0001c	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$3:
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00027	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$4:
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 44	 add	 ecx, 68			; 00000044H
  00032	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$??0MissionEvent@@QAE@ABV0@@Z$5:
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  00040	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__ehhandler$??0MissionEvent@@QAE@ABV0@@Z:
  00045	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00049	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004c	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0MissionEvent@@QAE@ABV0@@Z
  0005b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0MissionEvent@@QAE@ABV0@@Z ENDP			; MissionEvent::MissionEvent
;	COMDAT xdata$x
; File c:\matrix games\dev\stars45\combatgroup.h
xdata$x	SEGMENT
__unwindtable$?SetRegion@CombatGroup@@QAEXVText@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetRegion@CombatGroup@@QAEXVText@@@Z$0
__ehfuncinfo$?SetRegion@CombatGroup@@QAEXVText@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetRegion@CombatGroup@@QAEXVText@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?SetRegion@CombatGroup@@QAEXVText@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_rgn$ = 8						; size = 8
?SetRegion@CombatGroup@@QAEXVText@@@Z PROC		; CombatGroup::SetRegion, COMDAT
; _this$ = ecx

; 136  : 	void           SetRegion(Text rgn)                 { region = rgn;      }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetRegion@CombatGroup@@QAEXVText@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8d 45 08	 lea	 eax, DWORD PTR _rgn$[ebp]
  00025	50		 push	 eax
  00026	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@ABV0@@Z ; Text::operator=
  00035	8d 4d 08	 lea	 ecx, DWORD PTR _rgn$[ebp]
  00038	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0003f	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	59		 pop	 ecx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetRegion@CombatGroup@@QAEXVText@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _rgn$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__ehhandler$?SetRegion@CombatGroup@@QAEXVText@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetRegion@CombatGroup@@QAEXVText@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetRegion@CombatGroup@@QAEXVText@@@Z ENDP		; CombatGroup::SetRegion
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\missionevent.h
;	COMDAT ?IsActive@MissionEvent@@QBE_NXZ
_TEXT	SEGMENT
?IsActive@MissionEvent@@QBE_NXZ PROC			; MissionEvent::IsActive, COMDAT
; _this$ = ecx

; 101  : 	bool                 IsActive()        const { return status == ACTIVE;   }

  00000	33 c0		 xor	 eax, eax
  00002	83 79 0c 01	 cmp	 DWORD PTR [ecx+12], 1
  00006	0f 94 c0	 sete	 al
  00009	c3		 ret	 0
?IsActive@MissionEvent@@QBE_NXZ ENDP			; MissionEvent::IsActive
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?IsPending@MissionEvent@@QBE_NXZ
_TEXT	SEGMENT
?IsPending@MissionEvent@@QBE_NXZ PROC			; MissionEvent::IsPending, COMDAT
; _this$ = ecx

; 100  : 	bool                 IsPending()       const { return status == PENDING;  }

  00000	33 c0		 xor	 eax, eax
  00002	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00005	0f 94 c0	 sete	 al
  00008	c3		 ret	 0
?IsPending@MissionEvent@@QBE_NXZ ENDP			; MissionEvent::IsPending
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\mission.h
_TEXT	ENDS
;	COMDAT ?SetProbes@MissionShip@@QAEXH@Z
_TEXT	SEGMENT
?SetProbes@MissionShip@@QAEXH@Z PROC			; MissionShip::SetProbes, COMDAT
; _this$ = eax
; _p$ = ecx

; 405  : 	void              SetProbes(int p)              { probes = p;        }

  00000	89 48 6c	 mov	 DWORD PTR [eax+108], ecx
  00003	c3		 ret	 0
?SetProbes@MissionShip@@QAEXH@Z ENDP			; MissionShip::SetProbes
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetDecoys@MissionShip@@QAEXH@Z
_TEXT	SEGMENT
?SetDecoys@MissionShip@@QAEXH@Z PROC			; MissionShip::SetDecoys, COMDAT
; _this$ = eax
; _d$ = ecx

; 404  : 	void              SetDecoys(int d)              { decoys = d;        }

  00000	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00003	c3		 ret	 0
?SetDecoys@MissionShip@@QAEXH@Z ENDP			; MissionShip::SetDecoys
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetSkin@MissionShip@@QBEPBVSkin@@XZ
_TEXT	SEGMENT
?GetSkin@MissionShip@@QBEPBVSkin@@XZ PROC		; MissionShip::GetSkin, COMDAT
; _this$ = eax

; 384  : 	const Skin*       GetSkin()               const { return skin;       }

  00000	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00003	c3		 ret	 0
?GetSkin@MissionShip@@QBEPBVSkin@@XZ ENDP		; MissionShip::GetSkin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetZoneLock@MissionElement@@QAEXH@Z
_TEXT	SEGMENT
?SetZoneLock@MissionElement@@QAEXH@Z PROC		; MissionElement::SetZoneLock, COMDAT
; _this$ = eax
; _z$ = ecx

; 286  : 	void              SetZoneLock(int z)            { zone_lock = z;     }

  00000	89 48 58	 mov	 DWORD PTR [eax+88], ecx
  00003	c3		 ret	 0
?SetZoneLock@MissionElement@@QAEXH@Z ENDP		; MissionElement::SetZoneLock
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetRogue@MissionElement@@QAEX_N@Z
_TEXT	SEGMENT
?SetRogue@MissionElement@@QAEX_N@Z PROC			; MissionElement::SetRogue, COMDAT
; _this$ = eax
; _r$ = ecx

; 276  : 	void              SetRogue(bool r)              { rogue = r;         }

  00000	88 48 66	 mov	 BYTE PTR [eax+102], cl
  00003	c3		 ret	 0
?SetRogue@MissionElement@@QAEX_N@Z ENDP			; MissionElement::SetRogue
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetPath@MissionElement@@QAEXPBD@Z
_TEXT	SEGMENT
?SetPath@MissionElement@@QAEXPBD@Z PROC			; MissionElement::SetPath, COMDAT
; _this$ = ecx
; _p$ = eax

; 264  : 	void              SetPath(const char* p)        { path = p;          }

  00000	50		 push	 eax
  00001	83 c1 24	 add	 ecx, 36			; 00000024H
  00004	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=
  00009	c3		 ret	 0
?SetPath@MissionElement@@QAEXPBD@Z ENDP			; MissionElement::SetPath
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?IsInvulnerable@MissionElement@@QBE_NXZ
_TEXT	SEGMENT
?IsInvulnerable@MissionElement@@QBE_NXZ PROC		; MissionElement::IsInvulnerable, COMDAT
; _this$ = eax

; 240  : 	bool              IsInvulnerable() const { return invulnerable; }

  00000	8a 40 67	 mov	 al, BYTE PTR [eax+103]
  00003	c3		 ret	 0
?IsInvulnerable@MissionElement@@QBE_NXZ ENDP		; MissionElement::IsInvulnerable
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?IsRogue@MissionElement@@QBE_NXZ
_TEXT	SEGMENT
?IsRogue@MissionElement@@QBE_NXZ PROC			; MissionElement::IsRogue, COMDAT
; _this$ = eax

; 239  : 	bool              IsRogue()      const { return rogue;         }

  00000	8a 40 66	 mov	 al, BYTE PTR [eax+102]
  00003	c3		 ret	 0
?IsRogue@MissionElement@@QBE_NXZ ENDP			; MissionElement::IsRogue
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Stardate@Mission@@QBENXZ
_TEXT	SEGMENT
?Stardate@Mission@@QBENXZ PROC				; Mission::Stardate, COMDAT
; _this$ = eax

; 108  : 	double               Stardate()      const { return stardate;     }

  00000	f2 0f 10 80 b0
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+176]
  00008	c3		 ret	 0
?Stardate@Mission@@QBENXZ ENDP				; Mission::Stardate
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\explosion.h
_TEXT	ENDS
;	COMDAT ?TYPENAME@Explosion@@SAPBDXZ
_TEXT	SEGMENT
?TYPENAME@Explosion@@SAPBDXZ PROC			; Explosion::TYPENAME, COMDAT

; 35   : 	static const char* TYPENAME() { return "Explosion"; }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09HGNANIIM@Explosion?$AA@
  00005	c3		 ret	 0
?TYPENAME@Explosion@@SAPBDXZ ENDP			; Explosion::TYPENAME
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\drone.h
_TEXT	ENDS
;	COMDAT ?SetLife@Drone@@QAEXH@Z
_TEXT	SEGMENT
?SetLife@Drone@@QAEXH@Z PROC				; Drone::SetLife, COMDAT
; _this$ = eax

; 59   : 	void        SetLife(int seconds) { life = seconds; }

  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	f2 0f 11 80 a8
	01 00 00	 movsd	 QWORD PTR [eax+424], xmm0
  0000b	c3		 ret	 0
?SetLife@Drone@@QAEXH@Z ENDP				; Drone::SetLife
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?TYPENAME@Drone@@SAPBDXZ
_TEXT	SEGMENT
?TYPENAME@Drone@@SAPBDXZ PROC				; Drone::TYPENAME, COMDAT

; 37   : 	static const char* TYPENAME() { return "Drone"; }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05GAGADLBE@Drone?$AA@
  00005	c3		 ret	 0
?TYPENAME@Drone@@SAPBDXZ ENDP				; Drone::TYPENAME
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\shot.h
_TEXT	ENDS
;	COMDAT ?SetHitTarget@Shot@@QAEX_N@Z
_TEXT	SEGMENT
?SetHitTarget@Shot@@QAEX_N@Z PROC			; Shot::SetHitTarget, COMDAT
; _this$ = eax

; 68   : 	void              SetHitTarget(bool h) { hit_target = h;    }

  00000	c6 80 0f 02 00
	00 01		 mov	 BYTE PTR [eax+527], 1
  00007	c3		 ret	 0
?SetHitTarget@Shot@@QAEX_N@Z ENDP			; Shot::SetHitTarget
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\element.h
_TEXT	ENDS
;	COMDAT ?SetCount@Element@@QAEXH@Z
_TEXT	SEGMENT
?SetCount@Element@@QAEXH@Z PROC				; Element::SetCount, COMDAT
; _this$ = eax
; _n$ = ecx

; 134  : 	void              SetCount(int n)                  { count = n;         }

  00000	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  00003	c3		 ret	 0
?SetCount@Element@@QAEXH@Z ENDP				; Element::SetCount
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetCount@Element@@QBEHXZ
_TEXT	SEGMENT
?GetCount@Element@@QBEHXZ PROC				; Element::GetCount, COMDAT
; _this$ = eax

; 133  : 	int               GetCount()                 const { return count;      }

  00000	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00003	c3		 ret	 0
?GetCount@Element@@QBEHXZ ENDP				; Element::GetCount
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetSquadron@Element@@QBEABVText@@XZ
_TEXT	SEGMENT
?GetSquadron@Element@@QBEABVText@@XZ PROC		; Element::GetSquadron, COMDAT
; _this$ = eax

; 123  : 	const Text&       GetSquadron()              const { return squadron;   }

  00000	83 e8 80	 sub	 eax, -128		; ffffff80H
  00003	c3		 ret	 0
?GetSquadron@Element@@QBEABVText@@XZ ENDP		; Element::GetSquadron
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetCommandAILevel@Element@@QAEXH@Z
_TEXT	SEGMENT
?SetCommandAILevel@Element@@QAEXH@Z PROC		; Element::SetCommandAILevel, COMDAT
; _this$ = eax
; _n$ = ecx

; 122  : 	void              SetCommandAILevel(int n)         { command_ai = n;    }

  00000	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00003	c3		 ret	 0
?SetCommandAILevel@Element@@QAEXH@Z ENDP		; Element::SetCommandAILevel
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetCommandAILevel@Element@@QBEHXZ
_TEXT	SEGMENT
?GetCommandAILevel@Element@@QBEHXZ PROC			; Element::GetCommandAILevel, COMDAT
; _this$ = eax

; 121  : 	int               GetCommandAILevel()        const { return command_ai; }

  00000	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00003	c3		 ret	 0
?GetCommandAILevel@Element@@QBEHXZ ENDP			; Element::GetCommandAILevel
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetAssignment@Element@@QBEPAV1@XZ
_TEXT	SEGMENT
?GetAssignment@Element@@QBEPAV1@XZ PROC			; Element::GetAssignment, COMDAT
; _this$ = eax

; 115  : 	Element*          GetAssignment()            const { return assignment; }

  00000	8b 40 78	 mov	 eax, DWORD PTR [eax+120]
  00003	c3		 ret	 0
?GetAssignment@Element@@QBEPAV1@XZ ENDP			; Element::GetAssignment
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetPlayable@Element@@QAEX_N@Z
_TEXT	SEGMENT
?SetPlayable@Element@@QAEX_N@Z PROC			; Element::SetPlayable, COMDAT
; _this$ = eax
; _p$ = ecx

; 78   : 	void              SetPlayable(bool p)     { playable = p;            }

  00000	88 88 a1 00 00
	00		 mov	 BYTE PTR [eax+161], cl
  00006	c3		 ret	 0
?SetPlayable@Element@@QAEX_N@Z ENDP			; Element::SetPlayable
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetRogue@Element@@QAEX_N@Z
_TEXT	SEGMENT
?SetRogue@Element@@QAEX_N@Z PROC			; Element::SetRogue, COMDAT
; _this$ = eax
; _r$ = ecx

; 77   : 	void              SetRogue(bool r)        { rogue = r;               }

  00000	88 88 a0 00 00
	00		 mov	 BYTE PTR [eax+160], cl
  00006	c3		 ret	 0
?SetRogue@Element@@QAEX_N@Z ENDP			; Element::SetRogue
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?IsPlayable@Element@@QBE_NXZ
_TEXT	SEGMENT
?IsPlayable@Element@@QBE_NXZ PROC			; Element::IsPlayable, COMDAT
; _this$ = eax

; 74   : 	bool              IsPlayable()      const { return playable;         }

  00000	8a 80 a1 00 00
	00		 mov	 al, BYTE PTR [eax+161]
  00006	c3		 ret	 0
?IsPlayable@Element@@QBE_NXZ ENDP			; Element::IsPlayable
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?IsRogue@Element@@QBE_NXZ
_TEXT	SEGMENT
?IsRogue@Element@@QBE_NXZ PROC				; Element::IsRogue, COMDAT
; _this$ = eax

; 73   : 	bool              IsRogue()         const { return rogue;            }

  00000	8a 80 a0 00 00
	00		 mov	 al, BYTE PTR [eax+160]
  00006	c3		 ret	 0
?IsRogue@Element@@QBE_NXZ ENDP				; Element::IsRogue
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetPlayer@Element@@QAEXH@Z
_TEXT	SEGMENT
?SetPlayer@Element@@QAEXH@Z PROC			; Element::SetPlayer, COMDAT
; _this$ = eax
; _p$ = ecx

; 51   : 	void              SetPlayer(int p)        { player = p;              }

  00000	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00003	c3		 ret	 0
?SetPlayer@Element@@QAEXH@Z ENDP			; Element::SetPlayer
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Player@Element@@QBEHXZ
_TEXT	SEGMENT
?Player@Element@@QBEHXZ PROC				; Element::Player, COMDAT
; _this$ = eax

; 50   : 	int               Player()          const { return player;           }

  00000	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00003	c3		 ret	 0
?Player@Element@@QBEHXZ ENDP				; Element::Player
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\ship.h
_TEXT	ENDS
;	COMDAT ?RespawnLoc@Ship@@QBEABUPoint@@XZ
_TEXT	SEGMENT
?RespawnLoc@Ship@@QBEABUPoint@@XZ PROC			; Ship::RespawnLoc, COMDAT
; _this$ = eax

; 374  : 	const Point&      RespawnLoc()      const    { return respawn_loc;   }

  00000	05 80 04 00 00	 add	 eax, 1152		; 00000480H
  00005	c3		 ret	 0
?RespawnLoc@Ship@@QBEABUPoint@@XZ ENDP			; Ship::RespawnLoc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?UseSkin@Ship@@QAEXPBVSkin@@@Z
_TEXT	SEGMENT
?UseSkin@Ship@@QAEXPBVSkin@@@Z PROC			; Ship::UseSkin, COMDAT
; _this$ = eax
; _s$ = ecx

; 367  : 	void              UseSkin(const Skin* s)     { skin = s;             }

  00000	89 88 2c 03 00
	00		 mov	 DWORD PTR [eax+812], ecx
  00006	c3		 ret	 0
?UseSkin@Ship@@QAEXPBVSkin@@@Z ENDP			; Ship::UseSkin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Registry@Ship@@QBEPBDXZ
_TEXT	SEGMENT
?Registry@Ship@@QBEPBDXZ PROC				; Ship::Registry, COMDAT
; _this$ = eax

; 338  : 	const char*       Registry()        const    { return regnum;        }

  00000	05 f0 01 00 00	 add	 eax, 496		; 000001f0H
  00005	c3		 ret	 0
?Registry@Ship@@QBEPBDXZ ENDP				; Ship::Registry
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetCarrier@Ship@@QBEPAV1@XZ
_TEXT	SEGMENT
?GetCarrier@Ship@@QBEPAV1@XZ PROC			; Ship::GetCarrier, COMDAT
; _this$ = eax

; 186  : 	Ship*             GetCarrier()       const { return carrier;       }

  00000	8b 80 2c 04 00
	00		 mov	 eax, DWORD PTR [eax+1068]
  00006	c3		 ret	 0
?GetCarrier@Ship@@QBEPAV1@XZ ENDP			; Ship::GetCarrier
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetInvulnerable@Ship@@QAEX_N@Z
_TEXT	SEGMENT
?SetInvulnerable@Ship@@QAEX_N@Z PROC			; Ship::SetInvulnerable, COMDAT
; _this$ = eax
; _n$ = ecx

; 164  : 	void              SetInvulnerable(bool n)          { invulnerable = n;         }

  00000	88 88 22 04 00
	00		 mov	 BYTE PTR [eax+1058], cl
  00006	c3		 ret	 0
?SetInvulnerable@Ship@@QAEX_N@Z ENDP			; Ship::SetInvulnerable
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetAIMode@Ship@@QAEXH@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
?SetAIMode@Ship@@QAEXH@Z PROC				; Ship::SetAIMode, COMDAT
; _this$ = eax

; 154  : 	void              SetAIMode(int n)                 { ai_mode = (BYTE) n; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 4d 08	 mov	 cl, BYTE PTR _n$[ebp]
  00006	88 88 14 04 00
	00		 mov	 BYTE PTR [eax+1044], cl
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetAIMode@Ship@@QAEXH@Z ENDP				; Ship::SetAIMode
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\starsystem.h
_TEXT	ENDS
;	COMDAT ?Links@OrbitalRegion@@QAEAAV?$List@VText@@@@XZ
_TEXT	SEGMENT
?Links@OrbitalRegion@@QAEAAV?$List@VText@@@@XZ PROC	; OrbitalRegion::Links, COMDAT
; _this$ = eax

; 312  : 	List<Text>&       Links()                 { return links;         }

  00000	05 14 01 00 00	 add	 eax, 276		; 00000114H
  00005	c3		 ret	 0
?Links@OrbitalRegion@@QAEAAV?$List@VText@@@@XZ ENDP	; OrbitalRegion::Links
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Asteroids@OrbitalRegion@@QBEHXZ
_TEXT	SEGMENT
?Asteroids@OrbitalRegion@@QBEHXZ PROC			; OrbitalRegion::Asteroids, COMDAT
; _this$ = eax

; 311  : 	int               Asteroids()       const { return asteroids;     }

  00000	8b 80 10 01 00
	00		 mov	 eax, DWORD PTR [eax+272]
  00006	c3		 ret	 0
?Asteroids@OrbitalRegion@@QBEHXZ ENDP			; OrbitalRegion::Asteroids
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?System@Orbital@@QBEPAVStarSystem@@XZ
_TEXT	SEGMENT
?System@Orbital@@QBEPAVStarSystem@@XZ PROC		; Orbital::System, COMDAT
; _this$ = eax

; 218  : 	StarSystem*       System()       const { return system;     }

  00000	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [eax+232]
  00006	c3		 ret	 0
?System@Orbital@@QBEPAVStarSystem@@XZ ENDP		; Orbital::System
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?NumDust@StarSystem@@QBEHXZ
_TEXT	SEGMENT
?NumDust@StarSystem@@QBEHXZ PROC			; StarSystem::NumDust, COMDAT
; _this$ = eax

; 68   : 	int               NumDust()      const { return sky_dust;  }

  00000	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [eax+152]
  00006	c3		 ret	 0
?NumDust@StarSystem@@QBEHXZ ENDP			; StarSystem::NumDust
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\solid.h
_TEXT	ENDS
;	COMDAT ??8Model@@QBEHABV0@@Z
_TEXT	SEGMENT
_that$ = 8						; size = 4
??8Model@@QBEHABV0@@Z PROC				; Model::operator==, COMDAT
; _this$ = ecx

; 121  : 	int operator == (const Model& that) const { return this == &that; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	33 c0		 xor	 eax, eax
  00005	3b 4d 08	 cmp	 ecx, DWORD PTR _that$[ebp]
  00008	0f 94 c0	 sete	 al
  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??8Model@@QBEHABV0@@Z ENDP				; Model::operator==
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\starshatter.h
_TEXT	ENDS
;	COMDAT ?Dust@Starshatter@@QAEHXZ
_TEXT	SEGMENT
?Dust@Starshatter@@QAEHXZ PROC				; Starshatter::Dust, COMDAT
; _this$ = eax

; 105  : 	int               Dust()               { return dust;          }

  00000	8b 80 e8 a5 00
	00		 mov	 eax, DWORD PTR [eax+42472]
  00006	c3		 ret	 0
?Dust@Starshatter@@QAEHXZ ENDP				; Starshatter::Dust
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\game.h
_TEXT	ENDS
;	COMDAT ?GetMaxFrameLength@Game@@SANXZ
_TEXT	SEGMENT
?GetMaxFrameLength@Game@@SANXZ PROC			; Game::GetMaxFrameLength, COMDAT

; 100  : 	static double     GetMaxFrameLength()               { return max_frame_length;    }

  00000	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?max_frame_length@Game@@1NA
  00008	c3		 ret	 0
?GetMaxFrameLength@Game@@SANXZ ENDP			; Game::GetMaxFrameLength
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\simobject.h
_TEXT	ENDS
;	COMDAT ?TYPENAME@SimObserver@@SAPBDXZ
_TEXT	SEGMENT
?TYPENAME@SimObserver@@SAPBDXZ PROC			; SimObserver::TYPENAME, COMDAT

; 81   : 	static const char* TYPENAME() { return "SimObserver"; }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@EIEAPHAO@SimObserver?$AA@
  00005	c3		 ret	 0
?TYPENAME@SimObserver@@SAPBDXZ ENDP			; SimObserver::TYPENAME
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\simevent.h
_TEXT	ENDS
;	COMDAT ?AddCommandPoints@ShipStats@@QAEXH@Z
_TEXT	SEGMENT
?AddCommandPoints@ShipStats@@QAEXH@Z PROC		; ShipStats::AddCommandPoints, COMDAT
; _this$ = eax
; _p$ = ecx

; 132  : 	void           AddCommandPoints(int p) { cmd_points += p;      }

  00000	01 48 5c	 add	 DWORD PTR [eax+92], ecx
  00003	c3		 ret	 0
?AddCommandPoints@ShipStats@@QAEXH@Z ENDP		; ShipStats::AddCommandPoints
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetShipClass@ShipStats@@QAEXH@Z
_TEXT	SEGMENT
?SetShipClass@ShipStats@@QAEXH@Z PROC			; ShipStats::SetShipClass, COMDAT
; _this$ = eax
; _c$ = ecx

; 117  : 	void           SetShipClass(int c)     { ship_class = c;       }

  00000	89 48 30	 mov	 DWORD PTR [eax+48], ecx
  00003	c3		 ret	 0
?SetShipClass@ShipStats@@QAEXH@Z ENDP			; ShipStats::SetShipClass
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?IsPlayer@ShipStats@@QBE_NXZ
_TEXT	SEGMENT
?IsPlayer@ShipStats@@QBE_NXZ PROC			; ShipStats::IsPlayer, COMDAT
; _this$ = eax

; 109  : 	bool           IsPlayer()        const { return player;        }

  00000	8a 40 28	 mov	 al, BYTE PTR [eax+40]
  00003	c3		 ret	 0
?IsPlayer@ShipStats@@QBE_NXZ ENDP			; ShipStats::IsPlayer
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetElementIndex@ShipStats@@QBEHXZ
_TEXT	SEGMENT
?GetElementIndex@ShipStats@@QBEHXZ PROC			; ShipStats::GetElementIndex, COMDAT
; _this$ = eax

; 94   : 	int            GetElementIndex() const { return elem_index;    }

  00000	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  00003	c3		 ret	 0
?GetElementIndex@ShipStats@@QBEHXZ ENDP			; ShipStats::GetElementIndex
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetCombatGroup@ShipStats@@QBEPAVCombatGroup@@XZ
_TEXT	SEGMENT
?GetCombatGroup@ShipStats@@QBEPAVCombatGroup@@XZ PROC	; ShipStats::GetCombatGroup, COMDAT
; _this$ = eax

; 92   : 	CombatGroup*   GetCombatGroup()  const { return combat_group;  }

  00000	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00003	c3		 ret	 0
?GetCombatGroup@ShipStats@@QBEPAVCombatGroup@@XZ ENDP	; ShipStats::GetCombatGroup
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.h
_TEXT	ENDS
;	COMDAT ?GetPlayerShip@SimRegion@@QAEPAVShip@@XZ
_TEXT	SEGMENT
?GetPlayerShip@SimRegion@@QAEPAVShip@@XZ PROC		; SimRegion::GetPlayerShip, COMDAT
; _this$ = eax

; 238  : 	Ship*                GetPlayerShip() { return player_ship; }

  00000	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00003	c3		 ret	 0
?GetPlayerShip@SimRegion@@QAEPAVShip@@XZ ENDP		; SimRegion::GetPlayerShip
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?IsTestMode@Sim@@QBE_NXZ
_TEXT	SEGMENT
?IsTestMode@Sim@@QBE_NXZ PROC				; Sim::IsTestMode, COMDAT
; _this$ = eax

; 150  : 	bool                 IsTestMode()   const { return test_mode;        }

  00000	8a 80 bc 00 00
	00		 mov	 al, BYTE PTR [eax+188]
  00006	c3		 ret	 0
?IsTestMode@Sim@@QBE_NXZ ENDP				; Sim::IsTestMode
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\physical.h
_TEXT	ENDS
;	COMDAT ?Yaw@Physical@@QBENXZ
_TEXT	SEGMENT
?Yaw@Physical@@QBENXZ PROC				; Physical::Yaw, COMDAT
; _this$ = eax

; 95   : 	double            Yaw()       const { return yaw;        }

  00000	f3 0f 10 80 0c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+268]
  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	c3		 ret	 0
?Yaw@Physical@@QBENXZ ENDP				; Physical::Yaw
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Pitch@Physical@@QBENXZ
_TEXT	SEGMENT
?Pitch@Physical@@QBENXZ PROC				; Physical::Pitch, COMDAT
; _this$ = eax

; 94   : 	double            Pitch()     const { return pitch;      }

  00000	f3 0f 10 80 08
	01 00 00	 movss	 xmm0, DWORD PTR [eax+264]
  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	c3		 ret	 0
?Pitch@Physical@@QBENXZ ENDP				; Physical::Pitch
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Roll@Physical@@QBENXZ
_TEXT	SEGMENT
?Roll@Physical@@QBENXZ PROC				; Physical::Roll, COMDAT
; _this$ = eax

; 93   : 	double            Roll()      const { return roll;       }

  00000	f3 0f 10 80 04
	01 00 00	 movss	 xmm0, DWORD PTR [eax+260]
  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	c3		 ret	 0
?Roll@Physical@@QBENXZ ENDP				; Physical::Roll
; Function compile flags: /Ogtp
; File c:\matrix games\dev\ngenex\universe.h
_TEXT	ENDS
;	COMDAT ?ExecFrame@Universe@@UAEXN@Z
_TEXT	SEGMENT
_seconds$ = 8						; size = 8
?ExecFrame@Universe@@UAEXN@Z PROC			; Universe::ExecFrame, COMDAT
; _this$ = ecx

; 28   : 	virtual void   ExecFrame(double seconds) { }

  00000	c2 08 00	 ret	 8
?ExecFrame@Universe@@UAEXN@Z ENDP			; Universe::ExecFrame
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1Universe@@UAE@XZ
_TEXT	SEGMENT
??1Universe@@UAE@XZ PROC				; Universe::~Universe, COMDAT
; _this$ = ecx

; 26   : 	virtual ~Universe()  { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Universe@@6B@
  00006	c3		 ret	 0
??1Universe@@UAE@XZ ENDP				; Universe::~Universe
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0Universe@@QAE@XZ
_TEXT	SEGMENT
??0Universe@@QAE@XZ PROC				; Universe::Universe, COMDAT
; _this$ = eax

; 25   : 	Universe()           { }

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Universe@@6B@
  00006	c3		 ret	 0
??0Universe@@QAE@XZ ENDP				; Universe::Universe
; Function compile flags: /Ogtp
; File c:\matrix games\dev\foundationex\list.inl
;	COMDAT ?check@?$List@VAsteroid@@@@ABE_NAAH@Z
_TEXT	SEGMENT
?check@?$List@VAsteroid@@@@ABE_NAAH@Z PROC		; List<Asteroid>::check, COMDAT
; _this$ = esi
; _index$ = edi

; 65   :    if (index < 0) {

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	79 1c		 jns	 SHORT $LN3@check

; 66   :       Print("Bounds error in List(%08x) T=%s index=%d min=0\n", (int)this, T::TYPENAME(), index);

  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_09NMLPCCMA@SimObject?$AA@
  0000c	56		 push	 esi
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HIKLCBIP@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00012	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00017	83 c4 10	 add	 esp, 16			; 00000010H

; 67   :       index = 0;

  0001a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00020	eb 26		 jmp	 SHORT $LN12@check
$LN3@check:

; 68   :    }
; 69   : 
; 70   :    else if (index >= items) {

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	3b c1		 cmp	 eax, ecx
  00026	7c 1b		 jl	 SHORT $LN1@check

; 71   :       Print("Bounds error in List(%08x) T=%s index=%d max=%d\n", (int)this, T::TYPENAME(), index, items-1);

  00028	49		 dec	 ecx
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_09NMLPCCMA@SimObject?$AA@
  00030	56		 push	 esi
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@EEHODDHM@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00036	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 72   :       index = items-1;

  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	83 c4 14	 add	 esp, 20			; 00000014H
  00040	48		 dec	 eax
  00041	89 07		 mov	 DWORD PTR [edi], eax
$LN1@check:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00043	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00046	7c 0c		 jl	 SHORT $LN6@check
$LN12@check:
  00048	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0004a	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  0004c	7d 06		 jge	 SHORT $LN6@check
  0004e	b8 01 00 00 00	 mov	 eax, 1

; 76   : }

  00053	c3		 ret	 0
$LN6@check:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00054	33 c0		 xor	 eax, eax

; 76   : }

  00056	c3		 ret	 0
?check@?$List@VAsteroid@@@@ABE_NAAH@Z ENDP		; List<Asteroid>::check
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?check@?$List@VDebris@@@@ABE_NAAH@Z
_TEXT	SEGMENT
?check@?$List@VDebris@@@@ABE_NAAH@Z PROC		; List<Debris>::check, COMDAT
; _this$ = esi
; _index$ = edi

; 65   :    if (index < 0) {

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	79 1c		 jns	 SHORT $LN3@check@2

; 66   :       Print("Bounds error in List(%08x) T=%s index=%d min=0\n", (int)this, T::TYPENAME(), index);

  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_09NMLPCCMA@SimObject?$AA@
  0000c	56		 push	 esi
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HIKLCBIP@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00012	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00017	83 c4 10	 add	 esp, 16			; 00000010H

; 67   :       index = 0;

  0001a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00020	eb 26		 jmp	 SHORT $LN12@check@2
$LN3@check@2:

; 68   :    }
; 69   : 
; 70   :    else if (index >= items) {

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	3b c1		 cmp	 eax, ecx
  00026	7c 1b		 jl	 SHORT $LN1@check@2

; 71   :       Print("Bounds error in List(%08x) T=%s index=%d max=%d\n", (int)this, T::TYPENAME(), index, items-1);

  00028	49		 dec	 ecx
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_09NMLPCCMA@SimObject?$AA@
  00030	56		 push	 esi
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@EEHODDHM@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00036	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 72   :       index = items-1;

  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	83 c4 14	 add	 esp, 20			; 00000014H
  00040	48		 dec	 eax
  00041	89 07		 mov	 DWORD PTR [edi], eax
$LN1@check@2:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00043	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00046	7c 0c		 jl	 SHORT $LN6@check@2
$LN12@check@2:
  00048	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0004a	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  0004c	7d 06		 jge	 SHORT $LN6@check@2
  0004e	b8 01 00 00 00	 mov	 eax, 1

; 76   : }

  00053	c3		 ret	 0
$LN6@check@2:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00054	33 c0		 xor	 eax, eax

; 76   : }

  00056	c3		 ret	 0
?check@?$List@VDebris@@@@ABE_NAAH@Z ENDP		; List<Debris>::check
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?check@?$List@VExplosion@@@@ABE_NAAH@Z
_TEXT	SEGMENT
?check@?$List@VExplosion@@@@ABE_NAAH@Z PROC		; List<Explosion>::check, COMDAT
; _this$ = esi
; _index$ = edi

; 65   :    if (index < 0) {

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	79 1c		 jns	 SHORT $LN3@check@3

; 66   :       Print("Bounds error in List(%08x) T=%s index=%d min=0\n", (int)this, T::TYPENAME(), index);

  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_09HGNANIIM@Explosion?$AA@
  0000c	56		 push	 esi
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HIKLCBIP@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00012	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00017	83 c4 10	 add	 esp, 16			; 00000010H

; 67   :       index = 0;

  0001a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00020	eb 26		 jmp	 SHORT $LN12@check@3
$LN3@check@3:

; 68   :    }
; 69   : 
; 70   :    else if (index >= items) {

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	3b c1		 cmp	 eax, ecx
  00026	7c 1b		 jl	 SHORT $LN1@check@3

; 71   :       Print("Bounds error in List(%08x) T=%s index=%d max=%d\n", (int)this, T::TYPENAME(), index, items-1);

  00028	49		 dec	 ecx
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_09HGNANIIM@Explosion?$AA@
  00030	56		 push	 esi
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@EEHODDHM@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00036	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 72   :       index = items-1;

  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	83 c4 14	 add	 esp, 20			; 00000014H
  00040	48		 dec	 eax
  00041	89 07		 mov	 DWORD PTR [edi], eax
$LN1@check@3:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00043	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00046	7c 0c		 jl	 SHORT $LN6@check@3
$LN12@check@3:
  00048	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0004a	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  0004c	7d 06		 jge	 SHORT $LN6@check@3
  0004e	b8 01 00 00 00	 mov	 eax, 1

; 76   : }

  00053	c3		 ret	 0
$LN6@check@3:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00054	33 c0		 xor	 eax, eax

; 76   : }

  00056	c3		 ret	 0
?check@?$List@VExplosion@@@@ABE_NAAH@Z ENDP		; List<Explosion>::check
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?check@?$List@VDrone@@@@ABE_NAAH@Z
_TEXT	SEGMENT
?check@?$List@VDrone@@@@ABE_NAAH@Z PROC			; List<Drone>::check, COMDAT
; _this$ = esi
; _index$ = edi

; 65   :    if (index < 0) {

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	79 1c		 jns	 SHORT $LN3@check@4

; 66   :       Print("Bounds error in List(%08x) T=%s index=%d min=0\n", (int)this, T::TYPENAME(), index);

  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_05GAGADLBE@Drone?$AA@
  0000c	56		 push	 esi
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HIKLCBIP@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00012	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00017	83 c4 10	 add	 esp, 16			; 00000010H

; 67   :       index = 0;

  0001a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00020	eb 26		 jmp	 SHORT $LN12@check@4
$LN3@check@4:

; 68   :    }
; 69   : 
; 70   :    else if (index >= items) {

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	3b c1		 cmp	 eax, ecx
  00026	7c 1b		 jl	 SHORT $LN1@check@4

; 71   :       Print("Bounds error in List(%08x) T=%s index=%d max=%d\n", (int)this, T::TYPENAME(), index, items-1);

  00028	49		 dec	 ecx
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_05GAGADLBE@Drone?$AA@
  00030	56		 push	 esi
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@EEHODDHM@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00036	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 72   :       index = items-1;

  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	83 c4 14	 add	 esp, 20			; 00000014H
  00040	48		 dec	 eax
  00041	89 07		 mov	 DWORD PTR [edi], eax
$LN1@check@4:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00043	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00046	7c 0c		 jl	 SHORT $LN6@check@4
$LN12@check@4:
  00048	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0004a	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  0004c	7d 06		 jge	 SHORT $LN6@check@4
  0004e	b8 01 00 00 00	 mov	 eax, 1

; 76   : }

  00053	c3		 ret	 0
$LN6@check@4:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00054	33 c0		 xor	 eax, eax

; 76   : }

  00056	c3		 ret	 0
?check@?$List@VDrone@@@@ABE_NAAH@Z ENDP			; List<Drone>::check
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?index@?$List@VModel@@@@QBEHPBVModel@@@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?index@?$List@VModel@@@@QBEHPBVModel@@@Z PROC		; List<Model>::index, COMDAT
; _this$ = ecx

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 275  :    if (val) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _val$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 1c		 je	 SHORT $LN2@index

; 276  :       for (int i = 0; i < items; i++) {

  0000b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000d	33 c0		 xor	 eax, eax
  0000f	85 d2		 test	 edx, edx
  00011	7e 14		 jle	 SHORT $LN2@index
  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$LL4@index:

; 277  :          if (array[i] && ((*array[i])==(*val)))

  00016	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00019	74 04		 je	 SHORT $LN3@index
  0001b	39 31		 cmp	 DWORD PTR [ecx], esi
  0001d	74 0b		 je	 SHORT $LN6@index
$LN3@index:

; 276  :       for (int i = 0; i < items; i++) {

  0001f	40		 inc	 eax
  00020	83 c1 04	 add	 ecx, 4
  00023	3b c2		 cmp	 eax, edx
  00025	7c ef		 jl	 SHORT $LL4@index
$LN2@index:

; 278  :             return i;
; 279  :       }
; 280  :    }
; 281  : 
; 282  :    return -1;

  00027	83 c8 ff	 or	 eax, -1
$LN6@index:
  0002a	5e		 pop	 esi

; 283  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?index@?$List@VModel@@@@QBEHPBVModel@@@Z ENDP		; List<Model>::index
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?removeIndex@?$List@VAsteroid@@@@QAEPAVAsteroid@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?removeIndex@?$List@VAsteroid@@@@QAEPAVAsteroid@@H@Z PROC ; List<Asteroid>::removeIndex, COMDAT
; _this$ = eax

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f0		 mov	 esi, eax

; 223  :    if (!check(index))

  00007	8d 7d 08	 lea	 edi, DWORD PTR _index$[ebp]
  0000a	e8 00 00 00 00	 call	 ?check@?$List@VAsteroid@@@@ABE_NAAH@Z ; List<Asteroid>::check
  0000f	84 c0		 test	 al, al
  00011	75 08		 jne	 SHORT $LN4@removeInde

; 224  :       return 0;

  00013	5f		 pop	 edi
  00014	33 c0		 xor	 eax, eax
  00016	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN4@removeInde:

; 225  : 
; 226  :    T* tmp = array[index];

  0001b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00021	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00024	8b 02		 mov	 eax, DWORD PTR [edx]

; 227  :    array[index] = 0;

  00026	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 228  : 
; 229  :    // slide left:
; 230  :    for (int i = index; i < items-1; i++)

  0002c	8b 16		 mov	 edx, DWORD PTR [esi]
  0002e	4a		 dec	 edx
  0002f	3b ca		 cmp	 ecx, edx
  00031	7d 14		 jge	 SHORT $LN1@removeInde
$LL3@removeInde:
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 231  :       array[i] = array[i+1];

  00036	8b 7c 8a 04	 mov	 edi, DWORD PTR [edx+ecx*4+4]
  0003a	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  0003d	89 3a		 mov	 DWORD PTR [edx], edi
  0003f	8b 16		 mov	 edx, DWORD PTR [esi]
  00041	41		 inc	 ecx
  00042	4a		 dec	 edx
  00043	3b ca		 cmp	 ecx, edx
  00045	7c ec		 jl	 SHORT $LL3@removeInde
$LN1@removeInde:

; 232  : 
; 233  :    // blank out the hole we just created:
; 234  :    array[items-1] = 0;

  00047	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00049	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004c	c7 44 8a fc 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4-4], 0

; 235  : 
; 236  :    items--;

  00054	ff 0e		 dec	 DWORD PTR [esi]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?removeIndex@?$List@VAsteroid@@@@QAEPAVAsteroid@@H@Z ENDP ; List<Asteroid>::removeIndex
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?removeIndex@?$List@VDebris@@@@QAEPAVDebris@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?removeIndex@?$List@VDebris@@@@QAEPAVDebris@@H@Z PROC	; List<Debris>::removeIndex, COMDAT
; _this$ = eax

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f0		 mov	 esi, eax

; 223  :    if (!check(index))

  00007	8d 7d 08	 lea	 edi, DWORD PTR _index$[ebp]
  0000a	e8 00 00 00 00	 call	 ?check@?$List@VDebris@@@@ABE_NAAH@Z ; List<Debris>::check
  0000f	84 c0		 test	 al, al
  00011	75 08		 jne	 SHORT $LN4@removeInde@2

; 224  :       return 0;

  00013	5f		 pop	 edi
  00014	33 c0		 xor	 eax, eax
  00016	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN4@removeInde@2:

; 225  : 
; 226  :    T* tmp = array[index];

  0001b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00021	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00024	8b 02		 mov	 eax, DWORD PTR [edx]

; 227  :    array[index] = 0;

  00026	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 228  : 
; 229  :    // slide left:
; 230  :    for (int i = index; i < items-1; i++)

  0002c	8b 16		 mov	 edx, DWORD PTR [esi]
  0002e	4a		 dec	 edx
  0002f	3b ca		 cmp	 ecx, edx
  00031	7d 14		 jge	 SHORT $LN1@removeInde@2
$LL3@removeInde@2:
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 231  :       array[i] = array[i+1];

  00036	8b 7c 8a 04	 mov	 edi, DWORD PTR [edx+ecx*4+4]
  0003a	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  0003d	89 3a		 mov	 DWORD PTR [edx], edi
  0003f	8b 16		 mov	 edx, DWORD PTR [esi]
  00041	41		 inc	 ecx
  00042	4a		 dec	 edx
  00043	3b ca		 cmp	 ecx, edx
  00045	7c ec		 jl	 SHORT $LL3@removeInde@2
$LN1@removeInde@2:

; 232  : 
; 233  :    // blank out the hole we just created:
; 234  :    array[items-1] = 0;

  00047	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00049	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004c	c7 44 8a fc 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4-4], 0

; 235  : 
; 236  :    items--;

  00054	ff 0e		 dec	 DWORD PTR [esi]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?removeIndex@?$List@VDebris@@@@QAEPAVDebris@@H@Z ENDP	; List<Debris>::removeIndex
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?removeIndex@?$List@VExplosion@@@@QAEPAVExplosion@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?removeIndex@?$List@VExplosion@@@@QAEPAVExplosion@@H@Z PROC ; List<Explosion>::removeIndex, COMDAT
; _this$ = eax

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f0		 mov	 esi, eax

; 223  :    if (!check(index))

  00007	8d 7d 08	 lea	 edi, DWORD PTR _index$[ebp]
  0000a	e8 00 00 00 00	 call	 ?check@?$List@VExplosion@@@@ABE_NAAH@Z ; List<Explosion>::check
  0000f	84 c0		 test	 al, al
  00011	75 08		 jne	 SHORT $LN4@removeInde@3

; 224  :       return 0;

  00013	5f		 pop	 edi
  00014	33 c0		 xor	 eax, eax
  00016	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN4@removeInde@3:

; 225  : 
; 226  :    T* tmp = array[index];

  0001b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00021	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00024	8b 02		 mov	 eax, DWORD PTR [edx]

; 227  :    array[index] = 0;

  00026	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 228  : 
; 229  :    // slide left:
; 230  :    for (int i = index; i < items-1; i++)

  0002c	8b 16		 mov	 edx, DWORD PTR [esi]
  0002e	4a		 dec	 edx
  0002f	3b ca		 cmp	 ecx, edx
  00031	7d 14		 jge	 SHORT $LN1@removeInde@3
$LL3@removeInde@3:
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 231  :       array[i] = array[i+1];

  00036	8b 7c 8a 04	 mov	 edi, DWORD PTR [edx+ecx*4+4]
  0003a	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  0003d	89 3a		 mov	 DWORD PTR [edx], edi
  0003f	8b 16		 mov	 edx, DWORD PTR [esi]
  00041	41		 inc	 ecx
  00042	4a		 dec	 edx
  00043	3b ca		 cmp	 ecx, edx
  00045	7c ec		 jl	 SHORT $LL3@removeInde@3
$LN1@removeInde@3:

; 232  : 
; 233  :    // blank out the hole we just created:
; 234  :    array[items-1] = 0;

  00047	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00049	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004c	c7 44 8a fc 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4-4], 0

; 235  : 
; 236  :    items--;

  00054	ff 0e		 dec	 DWORD PTR [esi]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?removeIndex@?$List@VExplosion@@@@QAEPAVExplosion@@H@Z ENDP ; List<Explosion>::removeIndex
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?removeIndex@?$List@VDrone@@@@QAEPAVDrone@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?removeIndex@?$List@VDrone@@@@QAEPAVDrone@@H@Z PROC	; List<Drone>::removeIndex, COMDAT
; _this$ = eax

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f0		 mov	 esi, eax

; 223  :    if (!check(index))

  00007	8d 7d 08	 lea	 edi, DWORD PTR _index$[ebp]
  0000a	e8 00 00 00 00	 call	 ?check@?$List@VDrone@@@@ABE_NAAH@Z ; List<Drone>::check
  0000f	84 c0		 test	 al, al
  00011	75 08		 jne	 SHORT $LN4@removeInde@4

; 224  :       return 0;

  00013	5f		 pop	 edi
  00014	33 c0		 xor	 eax, eax
  00016	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN4@removeInde@4:

; 225  : 
; 226  :    T* tmp = array[index];

  0001b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00021	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00024	8b 02		 mov	 eax, DWORD PTR [edx]

; 227  :    array[index] = 0;

  00026	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 228  : 
; 229  :    // slide left:
; 230  :    for (int i = index; i < items-1; i++)

  0002c	8b 16		 mov	 edx, DWORD PTR [esi]
  0002e	4a		 dec	 edx
  0002f	3b ca		 cmp	 ecx, edx
  00031	7d 14		 jge	 SHORT $LN1@removeInde@4
$LL3@removeInde@4:
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 231  :       array[i] = array[i+1];

  00036	8b 7c 8a 04	 mov	 edi, DWORD PTR [edx+ecx*4+4]
  0003a	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  0003d	89 3a		 mov	 DWORD PTR [edx], edi
  0003f	8b 16		 mov	 edx, DWORD PTR [esi]
  00041	41		 inc	 ecx
  00042	4a		 dec	 edx
  00043	3b ca		 cmp	 ecx, edx
  00045	7c ec		 jl	 SHORT $LL3@removeInde@4
$LN1@removeInde@4:

; 232  : 
; 233  :    // blank out the hole we just created:
; 234  :    array[items-1] = 0;

  00047	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00049	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004c	c7 44 8a fc 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4-4], 0

; 235  : 
; 236  :    items--;

  00054	ff 0e		 dec	 DWORD PTR [esi]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?removeIndex@?$List@VDrone@@@@QAEPAVDrone@@H@Z ENDP	; List<Drone>::removeIndex
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?check@?$List@VElement@@@@ABE_NAAH@Z
_TEXT	SEGMENT
?check@?$List@VElement@@@@ABE_NAAH@Z PROC		; List<Element>::check, COMDAT
; _this$ = esi
; _index$ = edi

; 65   :    if (index < 0) {

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	79 1c		 jns	 SHORT $LN3@check@5

; 66   :       Print("Bounds error in List(%08x) T=%s index=%d min=0\n", (int)this, T::TYPENAME(), index);

  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EIEAPHAO@SimObserver?$AA@
  0000c	56		 push	 esi
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HIKLCBIP@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00012	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00017	83 c4 10	 add	 esp, 16			; 00000010H

; 67   :       index = 0;

  0001a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00020	eb 26		 jmp	 SHORT $LN12@check@5
$LN3@check@5:

; 68   :    }
; 69   : 
; 70   :    else if (index >= items) {

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	3b c1		 cmp	 eax, ecx
  00026	7c 1b		 jl	 SHORT $LN1@check@5

; 71   :       Print("Bounds error in List(%08x) T=%s index=%d max=%d\n", (int)this, T::TYPENAME(), index, items-1);

  00028	49		 dec	 ecx
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EIEAPHAO@SimObserver?$AA@
  00030	56		 push	 esi
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@EEHODDHM@Bounds?5error?5in?5List?$CI?$CF08x?$CJ?5T?$DN?$CFs?5@
  00036	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 72   :       index = items-1;

  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	83 c4 14	 add	 esp, 20			; 00000014H
  00040	48		 dec	 eax
  00041	89 07		 mov	 DWORD PTR [edi], eax
$LN1@check@5:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00043	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00046	7c 0c		 jl	 SHORT $LN6@check@5
$LN12@check@5:
  00048	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0004a	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  0004c	7d 06		 jge	 SHORT $LN6@check@5
  0004e	b8 01 00 00 00	 mov	 eax, 1

; 76   : }

  00053	c3		 ret	 0
$LN6@check@5:

; 73   :    }
; 74   : 
; 75   :    return (index >= 0 && index < items);

  00054	33 c0		 xor	 eax, eax

; 76   : }

  00056	c3		 ret	 0
?check@?$List@VElement@@@@ABE_NAAH@Z ENDP		; List<Element>::check
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?removeIndex@?$List@VElement@@@@QAEPAVElement@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?removeIndex@?$List@VElement@@@@QAEPAVElement@@H@Z PROC	; List<Element>::removeIndex, COMDAT
; _this$ = eax

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f0		 mov	 esi, eax

; 223  :    if (!check(index))

  00007	8d 7d 08	 lea	 edi, DWORD PTR _index$[ebp]
  0000a	e8 00 00 00 00	 call	 ?check@?$List@VElement@@@@ABE_NAAH@Z ; List<Element>::check
  0000f	84 c0		 test	 al, al
  00011	75 08		 jne	 SHORT $LN4@removeInde@5

; 224  :       return 0;

  00013	5f		 pop	 edi
  00014	33 c0		 xor	 eax, eax
  00016	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN4@removeInde@5:

; 225  : 
; 226  :    T* tmp = array[index];

  0001b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00021	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00024	8b 02		 mov	 eax, DWORD PTR [edx]

; 227  :    array[index] = 0;

  00026	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 228  : 
; 229  :    // slide left:
; 230  :    for (int i = index; i < items-1; i++)

  0002c	8b 16		 mov	 edx, DWORD PTR [esi]
  0002e	4a		 dec	 edx
  0002f	3b ca		 cmp	 ecx, edx
  00031	7d 14		 jge	 SHORT $LN1@removeInde@5
$LL3@removeInde@5:
  00033	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 231  :       array[i] = array[i+1];

  00036	8b 7c 8a 04	 mov	 edi, DWORD PTR [edx+ecx*4+4]
  0003a	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  0003d	89 3a		 mov	 DWORD PTR [edx], edi
  0003f	8b 16		 mov	 edx, DWORD PTR [esi]
  00041	41		 inc	 ecx
  00042	4a		 dec	 edx
  00043	3b ca		 cmp	 ecx, edx
  00045	7c ec		 jl	 SHORT $LL3@removeInde@5
$LN1@removeInde@5:

; 232  : 
; 233  :    // blank out the hole we just created:
; 234  :    array[items-1] = 0;

  00047	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00049	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004c	c7 44 8a fc 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4-4], 0

; 235  : 
; 236  :    items--;

  00054	ff 0e		 dec	 DWORD PTR [esi]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?removeIndex@?$List@VElement@@@@QAEPAVElement@@H@Z ENDP	; List<Element>::removeIndex
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?removeItem@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ
_TEXT	SEGMENT
?removeItem@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ PROC	; ListIter<Debris>::removeItem, COMDAT
; _this$ = edx

; 393  :    if (list && step >= 0 && step < list->items)

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	85 c0		 test	 eax, eax
  00004	74 1a		 je	 SHORT $LN1@removeItem
  00006	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00009	85 c9		 test	 ecx, ecx
  0000b	78 13		 js	 SHORT $LN1@removeItem
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	7d 0f		 jge	 SHORT $LN1@removeItem

; 394  :       return list->removeIndex(step--);

  00011	56		 push	 esi
  00012	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  00015	51		 push	 ecx
  00016	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00019	e8 00 00 00 00	 call	 ?removeIndex@?$List@VDebris@@@@QAEPAVDebris@@H@Z ; List<Debris>::removeIndex
  0001e	5e		 pop	 esi

; 397  : }

  0001f	c3		 ret	 0
$LN1@removeItem:

; 395  : 
; 396  :    return 0;

  00020	33 c0		 xor	 eax, eax

; 397  : }

  00022	c3		 ret	 0
?removeItem@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ENDP	; ListIter<Debris>::removeItem
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?removeItem@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ
_TEXT	SEGMENT
?removeItem@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ PROC ; ListIter<Explosion>::removeItem, COMDAT
; _this$ = edx

; 393  :    if (list && step >= 0 && step < list->items)

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	85 c0		 test	 eax, eax
  00004	74 1a		 je	 SHORT $LN1@removeItem@2
  00006	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00009	85 c9		 test	 ecx, ecx
  0000b	78 13		 js	 SHORT $LN1@removeItem@2
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	7d 0f		 jge	 SHORT $LN1@removeItem@2

; 394  :       return list->removeIndex(step--);

  00011	56		 push	 esi
  00012	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  00015	51		 push	 ecx
  00016	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00019	e8 00 00 00 00	 call	 ?removeIndex@?$List@VExplosion@@@@QAEPAVExplosion@@H@Z ; List<Explosion>::removeIndex
  0001e	5e		 pop	 esi

; 397  : }

  0001f	c3		 ret	 0
$LN1@removeItem@2:

; 395  : 
; 396  :    return 0;

  00020	33 c0		 xor	 eax, eax

; 397  : }

  00022	c3		 ret	 0
?removeItem@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ENDP ; ListIter<Explosion>::removeItem
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?removeItem@?$ListIter@VElement@@@@QAEPAVElement@@XZ
_TEXT	SEGMENT
?removeItem@?$ListIter@VElement@@@@QAEPAVElement@@XZ PROC ; ListIter<Element>::removeItem, COMDAT
; _this$ = edx

; 393  :    if (list && step >= 0 && step < list->items)

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	85 c0		 test	 eax, eax
  00004	74 1a		 je	 SHORT $LN1@removeItem@3
  00006	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00009	85 c9		 test	 ecx, ecx
  0000b	78 13		 js	 SHORT $LN1@removeItem@3
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	7d 0f		 jge	 SHORT $LN1@removeItem@3

; 394  :       return list->removeIndex(step--);

  00011	56		 push	 esi
  00012	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  00015	51		 push	 ecx
  00016	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00019	e8 00 00 00 00	 call	 ?removeIndex@?$List@VElement@@@@QAEPAVElement@@H@Z ; List<Element>::removeIndex
  0001e	5e		 pop	 esi

; 397  : }

  0001f	c3		 ret	 0
$LN1@removeItem@3:

; 395  : 
; 396  :    return 0;

  00020	33 c0		 xor	 eax, eax

; 397  : }

  00022	c3		 ret	 0
?removeItem@?$ListIter@VElement@@@@QAEPAVElement@@XZ ENDP ; ListIter<Element>::removeItem
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?contains@?$List@VModel@@@@QBE_NPBVModel@@@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?contains@?$List@VModel@@@@QBE_NPBVModel@@@Z PROC	; List<Model>::contains, COMDAT
; _this$ = ecx

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :    if (val) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _val$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 11		 je	 SHORT $LN1@contains

; 246  :       if (index(val) != -1)

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?index@?$List@VModel@@@@QBEHPBVModel@@@Z ; List<Model>::index
  00010	83 f8 ff	 cmp	 eax, -1
  00013	74 06		 je	 SHORT $LN1@contains

; 247  : 		  return true;

  00015	b0 01		 mov	 al, 1

; 251  : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN1@contains:

; 248  :    }
; 249  : 
; 250  :    return false;

  0001b	32 c0		 xor	 al, al

; 251  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?contains@?$List@VModel@@@@QBE_NPBVModel@@@Z ENDP	; List<Model>::contains
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?remove@?$List@VAsteroid@@@@QAEPAVAsteroid@@PBV2@@Z
_TEXT	SEGMENT
?remove@?$List@VAsteroid@@@@QAEPAVAsteroid@@PBV2@@Z PROC ; List<Asteroid>::remove, COMDAT
; _this$ = eax
; _val$ = edi

; 206  :    if (items == 0 || val == 0)

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	85 d2		 test	 edx, edx
  00004	74 26		 je	 SHORT $LN5@remove
  00006	85 ff		 test	 edi, edi
  00008	74 22		 je	 SHORT $LN5@remove

; 208  : 
; 209  :    for (int i = 0; i < items; i++) {

  0000a	33 c9		 xor	 ecx, ecx
  0000c	56		 push	 esi
  0000d	85 d2		 test	 edx, edx
  0000f	7e 0f		 jle	 SHORT $LN2@remove
  00011	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
$LL4@remove:

; 210  :       if (array[i] == val) {

  00014	39 3e		 cmp	 DWORD PTR [esi], edi
  00016	74 0c		 je	 SHORT $LN10@remove

; 208  : 
; 209  :    for (int i = 0; i < items; i++) {

  00018	41		 inc	 ecx
  00019	83 c6 04	 add	 esi, 4
  0001c	3b ca		 cmp	 ecx, edx
  0001e	7c f4		 jl	 SHORT $LL4@remove
$LN2@remove:

; 212  :       }
; 213  :    }
; 214  :    
; 215  :    return 0;

  00020	33 c0		 xor	 eax, eax
  00022	5e		 pop	 esi

; 216  : }

  00023	c3		 ret	 0
$LN10@remove:

; 211  :          return removeIndex(i);

  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?removeIndex@?$List@VAsteroid@@@@QAEPAVAsteroid@@H@Z ; List<Asteroid>::removeIndex
  0002a	5e		 pop	 esi

; 216  : }

  0002b	c3		 ret	 0
$LN5@remove:

; 207  :       return 0;

  0002c	33 c0		 xor	 eax, eax

; 216  : }

  0002e	c3		 ret	 0
?remove@?$List@VAsteroid@@@@QAEPAVAsteroid@@PBV2@@Z ENDP ; List<Asteroid>::remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?remove@?$List@VDebris@@@@QAEPAVDebris@@PBV2@@Z
_TEXT	SEGMENT
?remove@?$List@VDebris@@@@QAEPAVDebris@@PBV2@@Z PROC	; List<Debris>::remove, COMDAT
; _this$ = eax
; _val$ = edi

; 206  :    if (items == 0 || val == 0)

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	85 d2		 test	 edx, edx
  00004	74 26		 je	 SHORT $LN5@remove@2
  00006	85 ff		 test	 edi, edi
  00008	74 22		 je	 SHORT $LN5@remove@2

; 208  : 
; 209  :    for (int i = 0; i < items; i++) {

  0000a	33 c9		 xor	 ecx, ecx
  0000c	56		 push	 esi
  0000d	85 d2		 test	 edx, edx
  0000f	7e 0f		 jle	 SHORT $LN2@remove@2
  00011	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
$LL4@remove@2:

; 210  :       if (array[i] == val) {

  00014	39 3e		 cmp	 DWORD PTR [esi], edi
  00016	74 0c		 je	 SHORT $LN10@remove@2

; 208  : 
; 209  :    for (int i = 0; i < items; i++) {

  00018	41		 inc	 ecx
  00019	83 c6 04	 add	 esi, 4
  0001c	3b ca		 cmp	 ecx, edx
  0001e	7c f4		 jl	 SHORT $LL4@remove@2
$LN2@remove@2:

; 212  :       }
; 213  :    }
; 214  :    
; 215  :    return 0;

  00020	33 c0		 xor	 eax, eax
  00022	5e		 pop	 esi

; 216  : }

  00023	c3		 ret	 0
$LN10@remove@2:

; 211  :          return removeIndex(i);

  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?removeIndex@?$List@VDebris@@@@QAEPAVDebris@@H@Z ; List<Debris>::removeIndex
  0002a	5e		 pop	 esi

; 216  : }

  0002b	c3		 ret	 0
$LN5@remove@2:

; 207  :       return 0;

  0002c	33 c0		 xor	 eax, eax

; 216  : }

  0002e	c3		 ret	 0
?remove@?$List@VDebris@@@@QAEPAVDebris@@PBV2@@Z ENDP	; List<Debris>::remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?remove@?$List@VExplosion@@@@QAEPAVExplosion@@PBV2@@Z
_TEXT	SEGMENT
?remove@?$List@VExplosion@@@@QAEPAVExplosion@@PBV2@@Z PROC ; List<Explosion>::remove, COMDAT
; _this$ = eax
; _val$ = edi

; 206  :    if (items == 0 || val == 0)

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	85 d2		 test	 edx, edx
  00004	74 26		 je	 SHORT $LN5@remove@3
  00006	85 ff		 test	 edi, edi
  00008	74 22		 je	 SHORT $LN5@remove@3

; 208  : 
; 209  :    for (int i = 0; i < items; i++) {

  0000a	33 c9		 xor	 ecx, ecx
  0000c	56		 push	 esi
  0000d	85 d2		 test	 edx, edx
  0000f	7e 0f		 jle	 SHORT $LN2@remove@3
  00011	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
$LL4@remove@3:

; 210  :       if (array[i] == val) {

  00014	39 3e		 cmp	 DWORD PTR [esi], edi
  00016	74 0c		 je	 SHORT $LN10@remove@3

; 208  : 
; 209  :    for (int i = 0; i < items; i++) {

  00018	41		 inc	 ecx
  00019	83 c6 04	 add	 esi, 4
  0001c	3b ca		 cmp	 ecx, edx
  0001e	7c f4		 jl	 SHORT $LL4@remove@3
$LN2@remove@3:

; 212  :       }
; 213  :    }
; 214  :    
; 215  :    return 0;

  00020	33 c0		 xor	 eax, eax
  00022	5e		 pop	 esi

; 216  : }

  00023	c3		 ret	 0
$LN10@remove@3:

; 211  :          return removeIndex(i);

  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?removeIndex@?$List@VExplosion@@@@QAEPAVExplosion@@H@Z ; List<Explosion>::removeIndex
  0002a	5e		 pop	 esi

; 216  : }

  0002b	c3		 ret	 0
$LN5@remove@3:

; 207  :       return 0;

  0002c	33 c0		 xor	 eax, eax

; 216  : }

  0002e	c3		 ret	 0
?remove@?$List@VExplosion@@@@QAEPAVExplosion@@PBV2@@Z ENDP ; List<Explosion>::remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?remove@?$List@VDrone@@@@QAEPAVDrone@@PBV2@@Z
_TEXT	SEGMENT
?remove@?$List@VDrone@@@@QAEPAVDrone@@PBV2@@Z PROC	; List<Drone>::remove, COMDAT
; _this$ = eax
; _val$ = edi

; 206  :    if (items == 0 || val == 0)

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	85 d2		 test	 edx, edx
  00004	74 26		 je	 SHORT $LN5@remove@4
  00006	85 ff		 test	 edi, edi
  00008	74 22		 je	 SHORT $LN5@remove@4

; 208  : 
; 209  :    for (int i = 0; i < items; i++) {

  0000a	33 c9		 xor	 ecx, ecx
  0000c	56		 push	 esi
  0000d	85 d2		 test	 edx, edx
  0000f	7e 0f		 jle	 SHORT $LN2@remove@4
  00011	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
$LL4@remove@4:

; 210  :       if (array[i] == val) {

  00014	39 3e		 cmp	 DWORD PTR [esi], edi
  00016	74 0c		 je	 SHORT $LN10@remove@4

; 208  : 
; 209  :    for (int i = 0; i < items; i++) {

  00018	41		 inc	 ecx
  00019	83 c6 04	 add	 esi, 4
  0001c	3b ca		 cmp	 ecx, edx
  0001e	7c f4		 jl	 SHORT $LL4@remove@4
$LN2@remove@4:

; 212  :       }
; 213  :    }
; 214  :    
; 215  :    return 0;

  00020	33 c0		 xor	 eax, eax
  00022	5e		 pop	 esi

; 216  : }

  00023	c3		 ret	 0
$LN10@remove@4:

; 211  :          return removeIndex(i);

  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?removeIndex@?$List@VDrone@@@@QAEPAVDrone@@H@Z ; List<Drone>::removeIndex
  0002a	5e		 pop	 esi

; 216  : }

  0002b	c3		 ret	 0
$LN5@remove@4:

; 207  :       return 0;

  0002c	33 c0		 xor	 eax, eax

; 216  : }

  0002e	c3		 ret	 0
?remove@?$List@VDrone@@@@QAEPAVDrone@@PBV2@@Z ENDP	; List<Drone>::remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?remove@?$List@VElement@@@@QAEPAVElement@@PBV2@@Z
_TEXT	SEGMENT
?remove@?$List@VElement@@@@QAEPAVElement@@PBV2@@Z PROC	; List<Element>::remove, COMDAT
; _this$ = eax
; _val$ = edi

; 206  :    if (items == 0 || val == 0)

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	85 d2		 test	 edx, edx
  00004	74 26		 je	 SHORT $LN5@remove@5
  00006	85 ff		 test	 edi, edi
  00008	74 22		 je	 SHORT $LN5@remove@5

; 208  : 
; 209  :    for (int i = 0; i < items; i++) {

  0000a	33 c9		 xor	 ecx, ecx
  0000c	56		 push	 esi
  0000d	85 d2		 test	 edx, edx
  0000f	7e 0f		 jle	 SHORT $LN2@remove@5
  00011	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
$LL4@remove@5:

; 210  :       if (array[i] == val) {

  00014	39 3e		 cmp	 DWORD PTR [esi], edi
  00016	74 0c		 je	 SHORT $LN10@remove@5

; 208  : 
; 209  :    for (int i = 0; i < items; i++) {

  00018	41		 inc	 ecx
  00019	83 c6 04	 add	 esi, 4
  0001c	3b ca		 cmp	 ecx, edx
  0001e	7c f4		 jl	 SHORT $LL4@remove@5
$LN2@remove@5:

; 212  :       }
; 213  :    }
; 214  :    
; 215  :    return 0;

  00020	33 c0		 xor	 eax, eax
  00022	5e		 pop	 esi

; 216  : }

  00023	c3		 ret	 0
$LN10@remove@5:

; 211  :          return removeIndex(i);

  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?removeIndex@?$List@VElement@@@@QAEPAVElement@@H@Z ; List<Element>::removeIndex
  0002a	5e		 pop	 esi

; 216  : }

  0002b	c3		 ret	 0
$LN5@remove@5:

; 207  :       return 0;

  0002c	33 c0		 xor	 eax, eax

; 216  : }

  0002e	c3		 ret	 0
?remove@?$List@VElement@@@@QAEPAVElement@@PBV2@@Z ENDP	; List<Element>::remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?at@?$List@VElement@@@@QAEAAPAVElement@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?at@?$List@VElement@@@@QAEAAPAVElement@@H@Z PROC	; List<Element>::at, COMDAT
; _this$ = eax

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f0		 mov	 esi, eax

; 103  :    if (check(index))

  00007	8d 7d 08	 lea	 edi, DWORD PTR _index$[ebp]
  0000a	e8 00 00 00 00	 call	 ?check@?$List@VElement@@@@ABE_NAAH@Z ; List<Element>::check
  0000f	84 c0		 test	 al, al
  00011	74 0f		 je	 SHORT $LN3@at

; 104  :       return array[index];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00019	5f		 pop	 edi
  0001a	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0001d	5e		 pop	 esi

; 110  : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN3@at:

; 105  : 
; 106  :    if (!array || !extent)

  00022	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00026	74 06		 je	 SHORT $LN1@at
  00028	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0002c	75 0a		 jne	 SHORT $LN2@at
$LN1@at:

; 107  :       resize(1);

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	e8 00 00 00 00	 call	 ?resize@?$List@VElement@@@@AAEXH@Z ; List<Element>::resize
$LN2@at:

; 108  : 
; 109  :    return array[0];

  00038	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi

; 110  : }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?at@?$List@VElement@@@@QAEAAPAVElement@@H@Z ENDP	; List<Element>::at
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$List@VElement@@@@QAEAAPAVElement@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
??A?$List@VElement@@@@QAEAAPAVElement@@H@Z PROC		; List<Element>::operator[], COMDAT
; _this$ = eax

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f0		 mov	 esi, eax

; 83   :    if (check(index))

  00007	8d 7d 08	 lea	 edi, DWORD PTR _index$[ebp]
  0000a	e8 00 00 00 00	 call	 ?check@?$List@VElement@@@@ABE_NAAH@Z ; List<Element>::check
  0000f	84 c0		 test	 al, al
  00011	74 0f		 je	 SHORT $LN3@operator

; 84   :       return array[index];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00019	5f		 pop	 edi
  0001a	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0001d	5e		 pop	 esi

; 90   : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN3@operator:

; 85   : 
; 86   :    if (!array || !extent)

  00022	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00026	74 06		 je	 SHORT $LN1@operator
  00028	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0002c	75 0a		 jne	 SHORT $LN2@operator
$LN1@operator:

; 87   :       resize(1);

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	e8 00 00 00 00	 call	 ?resize@?$List@VElement@@@@AAEXH@Z ; List<Element>::resize
$LN2@operator:

; 88   : 
; 89   :    return array[0];

  00038	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi

; 90   : }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??A?$List@VElement@@@@QAEAAPAVElement@@H@Z ENDP		; List<Element>::operator[]
; Function compile flags: /Ogtp
; File c:\matrix games\dev\foundationex\list.h
_TEXT	ENDS
;	COMDAT ??C?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ
_TEXT	SEGMENT
??C?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ PROC	; ListIter<Asteroid>::operator->, COMDAT
; _this$ = eax

; 86   :    T*  operator->() { return value();     }

  00000	e9 00 00 00 00	 jmp	 ?value@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::value
??C?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ENDP	; ListIter<Asteroid>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??C?$ListIter@VDebris@@@@QAEPAVDebris@@XZ
_TEXT	SEGMENT
??C?$ListIter@VDebris@@@@QAEPAVDebris@@XZ PROC		; ListIter<Debris>::operator->, COMDAT
; _this$ = eax

; 86   :    T*  operator->() { return value();     }

  00000	e9 00 00 00 00	 jmp	 ?value@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::value
??C?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ENDP		; ListIter<Debris>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$ListIter@VText@@@@QAEAAVText@@XZ
_TEXT	SEGMENT
??D?$ListIter@VText@@@@QAEAAVText@@XZ PROC		; ListIter<Text>::operator*, COMDAT
; _this$ = ecx

; 87   :    T&  operator* () { return *value();    }

  00000	e9 00 00 00 00	 jmp	 ?value@?$ListIter@VText@@@@QAEPAVText@@XZ ; ListIter<Text>::value
??D?$ListIter@VText@@@@QAEAAVText@@XZ ENDP		; ListIter<Text>::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??C?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ
_TEXT	SEGMENT
??C?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ PROC	; ListIter<SimRegion>::operator->, COMDAT
; _this$ = eax

; 86   :    T*  operator->() { return value();     }

  00000	e9 00 00 00 00	 jmp	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
??C?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ENDP	; ListIter<SimRegion>::operator->
_TEXT	ENDS
PUBLIC	?FormatGameTime@@YAPBDXZ			; FormatGameTime
;	COMDAT ?txt@?1??FormatGameTime@@YAPBDXZ@4PADA
; File c:\matrix games\dev\stars45\sim.cpp
_BSS	SEGMENT
?txt@?1??FormatGameTime@@YAPBDXZ@4PADA DB 040H DUP (?)	; `FormatGameTime'::`2'::txt
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT ?FormatGameTime@@YAPBDXZ
_TEXT	SEGMENT
?FormatGameTime@@YAPBDXZ PROC				; FormatGameTime, COMDAT

; 3800 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 3801 : 	static char txt[64];
; 3802 : 
; 3803 : 	int t = Game::GameTime();

  00003	e8 00 00 00 00	 call	 ?GameTime@Game@@SAKXZ	; Game::GameTime
  00008	8b f0		 mov	 esi, eax

; 3804 : 
; 3805 : 	int h = ( t                        / 3600000);

  0000a	b8 59 be 90 4a	 mov	 eax, 1250999897		; 4a90be59H
  0000f	f7 ee		 imul	 esi
  00011	c1 fa 14	 sar	 edx, 20			; 00000014H
  00014	8b ca		 mov	 ecx, edx
  00016	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00019	03 ca		 add	 ecx, edx

; 3806 : 	int m = ((t - h*3600000)           /   60000);

  0001b	8b c1		 mov	 eax, ecx
  0001d	69 c0 80 ee 36
	00		 imul	 eax, 3600000		; 0036ee80H
  00023	8b d6		 mov	 edx, esi
  00025	2b d0		 sub	 edx, eax
  00027	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  0002c	f7 ea		 imul	 edx
  0002e	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00031	8b fa		 mov	 edi, edx
  00033	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00036	03 fa		 add	 edi, edx

; 3807 : 	int s = ((t - h*3600000 - m*60000) /    1000);

  00038	8b d1		 mov	 edx, ecx
  0003a	c1 e2 04	 shl	 edx, 4
  0003d	2b d1		 sub	 edx, ecx
  0003f	8d 1c 97	 lea	 ebx, DWORD PTR [edi+edx*4]
  00042	8b c3		 mov	 eax, ebx
  00044	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  0004a	8b d6		 mov	 edx, esi
  0004c	2b d0		 sub	 edx, eax
  0004e	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00053	f7 ea		 imul	 edx
  00055	c1 fa 06	 sar	 edx, 6
  00058	8b c2		 mov	 eax, edx
  0005a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005d	03 c2		 add	 eax, edx

; 3808 : 	int e = ( t - h*3600000 - m*60000 - s*1000);

  0005f	8b d3		 mov	 edx, ebx
  00061	c1 e2 04	 shl	 edx, 4
  00064	2b d3		 sub	 edx, ebx
  00066	8d 14 90	 lea	 edx, DWORD PTR [eax+edx*4]
  00069	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  0006f	2b f2		 sub	 esi, edx

; 3809 : 
; 3810 : 	if (h > 0)
; 3811 : 	sprintf_s(txt, "%02d:%02d:%02d.%03d", h,m,s,e);

  00071	56		 push	 esi
  00072	50		 push	 eax
  00073	57		 push	 edi
  00074	85 c9		 test	 ecx, ecx
  00076	7e 1c		 jle	 SHORT $LN2@FormatGame
  00078	51		 push	 ecx
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MNIJIMLO@?$CF02d?3?$CF02d?3?$CF02d?4?$CF03d?$AA@
  0007e	68 00 00 00 00	 push	 OFFSET ?txt@?1??FormatGameTime@@YAPBDXZ@4PADA
  00083	e8 00 00 00 00	 call	 ??$sprintf_s@$0EA@@@YAHAAY0EA@DPBDZZ ; sprintf_s<64>
  00088	83 c4 18	 add	 esp, 24			; 00000018H
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi

; 3814 : 
; 3815 : 	return txt;

  0008d	b8 00 00 00 00	 mov	 eax, OFFSET ?txt@?1??FormatGameTime@@YAPBDXZ@4PADA
  00092	5b		 pop	 ebx

; 3816 : }

  00093	c3		 ret	 0
$LN2@FormatGame:

; 3812 : 	else
; 3813 : 	sprintf_s(txt, "%02d:%02d.%03d", m,s,e);

  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GCEINJHL@?$CF02d?3?$CF02d?4?$CF03d?$AA@
  00099	68 00 00 00 00	 push	 OFFSET ?txt@?1??FormatGameTime@@YAPBDXZ@4PADA
  0009e	e8 00 00 00 00	 call	 ??$sprintf_s@$0EA@@@YAHAAY0EA@DPBDZZ ; sprintf_s<64>
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi

; 3814 : 
; 3815 : 	return txt;

  000a8	b8 00 00 00 00	 mov	 eax, OFFSET ?txt@?1??FormatGameTime@@YAPBDXZ@4PADA
  000ad	5b		 pop	 ebx

; 3816 : }

  000ae	c3		 ret	 0
?FormatGameTime@@YAPBDXZ ENDP				; FormatGameTime
_TEXT	ENDS
PUBLIC	?TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z ; SimRegion::TrackList
;	COMDAT ?empty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4V3@A
; File c:\matrix games\dev\foundationex\list.h
_BSS	SEGMENT
?empty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4V3@A DB 0cH DUP (?) ; `SimRegion::TrackList'::`4'::empty
_BSS	ENDS
;	COMDAT ?$S3@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4IA
_BSS	SEGMENT
?$S3@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4IA DD 01H DUP (?) ; `SimRegion::TrackList'::`4'::$S3
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
_BSS	ENDS
;	COMDAT ?TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z
_TEXT	SEGMENT
?TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z PROC	; SimRegion::TrackList, COMDAT
; _this$ = ecx
; _iff$ = eax

; 3538 : 	if (iff >= 0 && iff < 5)

  00000	83 f8 04	 cmp	 eax, 4
  00003	77 0b		 ja	 SHORT $LN2@TrackList

; 3539 : 	return track_database[iff];

  00005	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00008	8d 84 81 b8 00
	00 00		 lea	 eax, DWORD PTR [ecx+eax*4+184]

; 3543 : }

  0000f	c3		 ret	 0
$LN2@TrackList:

; 3540 : 
; 3541 : 	static List<Contact> empty;

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	84 05 00 00 00
	00		 test	 BYTE PTR ?$S3@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4IA, al
  0001b	75 24		 jne	 SHORT $LN1@TrackList
  0001d	09 05 00 00 00
	00		 or	 DWORD PTR ?$S3@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4IA, eax
  00023	33 c0		 xor	 eax, eax
  00025	68 00 00 00 00	 push	 OFFSET ??__Fempty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@YAXXZ ; `SimRegion::TrackList'::`4'::`dynamic atexit destructor for 'empty''
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?empty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4V3@A, eax
  0002f	a3 04 00 00 00	 mov	 DWORD PTR ?empty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4V3@A+4, eax
  00034	a3 08 00 00 00	 mov	 DWORD PTR ?empty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4V3@A+8, eax
  00039	e8 00 00 00 00	 call	 _atexit
  0003e	83 c4 04	 add	 esp, 4
$LN1@TrackList:

; 3542 : 	return empty;

  00041	b8 00 00 00 00	 mov	 eax, OFFSET ?empty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4V3@A

; 3543 : }

  00046	c3		 ret	 0
?TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z ENDP	; SimRegion::TrackList
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?FindShotByObjID@SimRegion@@UAEPAVShot@@K@Z
_TEXT	SEGMENT
_drone_iter$121116 = -8					; size = 8
_shot_iter$ = -8					; size = 8
_objid$ = 8						; size = 4
?FindShotByObjID@SimRegion@@UAEPAVShot@@K@Z PROC	; SimRegion::FindShotByObjID, COMDAT
; _this$ = ecx

; 3324 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b d9		 mov	 ebx, ecx

; 3325 : 	Shot* shot = 0;
; 3326 : 
; 3327 : 	ListIter<Shot> shot_iter = shots;

  0000d	8d 43 7c	 lea	 eax, DWORD PTR [ebx+124]
  00010	57		 push	 edi

; 3328 : 	while (++shot_iter && !shot) {

  00011	8d 54 24 10	 lea	 edx, DWORD PTR _shot_iter$[esp+24]
  00015	33 f6		 xor	 esi, esi
  00017	89 44 24 10	 mov	 DWORD PTR _shot_iter$[esp+24], eax
  0001b	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _shot_iter$[esp+28], -1
  00023	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  00028	85 c0		 test	 eax, eax
  0002a	74 32		 je	 SHORT $LN20@FindShotBy
$LN7@FindShotBy:
  0002c	85 f6		 test	 esi, esi
  0002e	75 7b		 jne	 SHORT $LN24@FindShotBy

; 3329 : 		Shot* test = shot_iter.value();

  00030	8d 44 24 10	 lea	 eax, DWORD PTR _shot_iter$[esp+24]
  00034	e8 00 00 00 00	 call	 ?value@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::value
  00039	8b f8		 mov	 edi, eax

; 3330 : 		if (test->GetObjID() == objid)

  0003b	8b 17		 mov	 edx, DWORD PTR [edi]
  0003d	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  00043	8b cf		 mov	 ecx, edi
  00045	ff d0		 call	 eax
  00047	3b 45 08	 cmp	 eax, DWORD PTR _objid$[ebp]
  0004a	8d 54 24 10	 lea	 edx, DWORD PTR _shot_iter$[esp+24]

; 3331 : 		shot = test;

  0004e	0f 44 f7	 cmove	 esi, edi
  00051	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  00056	85 c0		 test	 eax, eax
  00058	75 d2		 jne	 SHORT $LN7@FindShotBy

; 3332 : 	}
; 3333 : 
; 3334 : 	if (!shot) {

  0005a	85 f6		 test	 esi, esi
  0005c	75 4d		 jne	 SHORT $LN24@FindShotBy
$LN20@FindShotBy:

; 3335 : 		ListIter<Drone> drone_iter = drones;

  0005e	81 c3 88 00 00
	00		 add	 ebx, 136		; 00000088H

; 3336 : 		while (++drone_iter && !shot) {

  00064	8d 54 24 10	 lea	 edx, DWORD PTR _drone_iter$121116[esp+24]
  00068	89 5c 24 10	 mov	 DWORD PTR _drone_iter$121116[esp+24], ebx
  0006c	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _drone_iter$121116[esp+28], -1
  00074	e8 00 00 00 00	 call	 ?next@?$ListIter@VDrone@@@@QAEPAVDrone@@XZ ; ListIter<Drone>::next
  00079	85 c0		 test	 eax, eax
  0007b	74 2e		 je	 SHORT $LN24@FindShotBy
$LN3@FindShotBy:
  0007d	85 f6		 test	 esi, esi
  0007f	75 2a		 jne	 SHORT $LN24@FindShotBy

; 3337 : 			Drone* test = drone_iter.value();

  00081	8d 44 24 10	 lea	 eax, DWORD PTR _drone_iter$121116[esp+24]
  00085	e8 00 00 00 00	 call	 ?value@?$ListIter@VDrone@@@@QAEPAVDrone@@XZ ; ListIter<Drone>::value
  0008a	8b f8		 mov	 edi, eax

; 3338 : 			if (test->GetObjID() == objid)

  0008c	8b 17		 mov	 edx, DWORD PTR [edi]
  0008e	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  00094	8b cf		 mov	 ecx, edi
  00096	ff d0		 call	 eax
  00098	3b 45 08	 cmp	 eax, DWORD PTR _objid$[ebp]
  0009b	8d 54 24 10	 lea	 edx, DWORD PTR _drone_iter$121116[esp+24]

; 3339 : 			shot = test;

  0009f	0f 44 f7	 cmove	 esi, edi
  000a2	e8 00 00 00 00	 call	 ?next@?$ListIter@VDrone@@@@QAEPAVDrone@@XZ ; ListIter<Drone>::next
  000a7	85 c0		 test	 eax, eax
  000a9	75 d2		 jne	 SHORT $LN3@FindShotBy
$LN24@FindShotBy:

; 3340 : 		}
; 3341 : 	}
; 3342 : 
; 3343 : 	return shot;
; 3344 : }

  000ab	5f		 pop	 edi
  000ac	8b c6		 mov	 eax, esi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
?FindShotByObjID@SimRegion@@UAEPAVShot@@K@Z ENDP	; SimRegion::FindShotByObjID
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?FindShipByObjID@SimRegion@@UAEPAVShip@@K@Z
_TEXT	SEGMENT
_ship_iter$ = -8					; size = 8
_objid$ = 8						; size = 4
?FindShipByObjID@SimRegion@@UAEPAVShip@@K@Z PROC	; SimRegion::FindShipByObjID, COMDAT
; _this$ = ecx

; 3309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 3310 : 	Ship* ship = 0;
; 3311 : 
; 3312 : 	ListIter<Ship> ship_iter = ships;

  0000b	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0000e	57		 push	 edi

; 3313 : 	while (++ship_iter && !ship) {

  0000f	8d 54 24 10	 lea	 edx, DWORD PTR _ship_iter$[esp+24]
  00013	33 ff		 xor	 edi, edi
  00015	89 4c 24 10	 mov	 DWORD PTR _ship_iter$[esp+24], ecx
  00019	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _ship_iter$[esp+28], -1
  00021	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00026	85 c0		 test	 eax, eax
  00028	74 30		 je	 SHORT $LN12@FindShipBy
  0002a	8b 5d 08	 mov	 ebx, DWORD PTR _objid$[ebp]
$LN3@FindShipBy:
  0002d	85 ff		 test	 edi, edi
  0002f	75 29		 jne	 SHORT $LN12@FindShipBy

; 3314 : 		Ship* test = ship_iter.value();

  00031	8d 44 24 10	 lea	 eax, DWORD PTR _ship_iter$[esp+24]
  00035	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  0003a	8b f0		 mov	 esi, eax

; 3315 : 		if (test->GetObjID() == objid)

  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  00044	8b ce		 mov	 ecx, esi
  00046	ff d2		 call	 edx
  00048	3b c3		 cmp	 eax, ebx
  0004a	8d 54 24 10	 lea	 edx, DWORD PTR _ship_iter$[esp+24]

; 3316 : 		ship = test;

  0004e	0f 44 fe	 cmove	 edi, esi
  00051	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00056	85 c0		 test	 eax, eax
  00058	75 d3		 jne	 SHORT $LN3@FindShipBy
$LN12@FindShipBy:

; 3317 : 	}
; 3318 : 
; 3319 : 	return ship;

  0005a	8b c7		 mov	 eax, edi

; 3320 : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?FindShipByObjID@SimRegion@@UAEPAVShip@@K@Z ENDP	; SimRegion::FindShipByObjID
_TEXT	ENDS
PUBLIC	?FindShip@SimRegion@@QAEPAVShip@@PBD@Z		; SimRegion::FindShip
; Function compile flags: /Ogtp
;	COMDAT ?FindShip@SimRegion@@QAEPAVShip@@PBD@Z
_TEXT	SEGMENT
_ship_iter$121082 = -12					; size = 8
_ship$ = -4						; size = 4
_this$ = 8						; size = 4
_ship_name$ = 12					; size = 4
?FindShip@SimRegion@@QAEPAVShip@@PBD@Z PROC		; SimRegion::FindShip, COMDAT

; 3280 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3281 : 	Ship* ship = 0;
; 3282 : 
; 3283 : 	if (ship_name && *ship_name) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR _ship_name$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	33 f6		 xor	 esi, esi
  0000d	57		 push	 edi
  0000e	89 75 fc	 mov	 DWORD PTR _ship$[ebp], esi
  00011	85 c0		 test	 eax, eax
  00013	74 32		 je	 SHORT $LN25@FindShip
  00015	80 38 00	 cmp	 BYTE PTR [eax], 0
  00018	74 2d		 je	 SHORT $LN25@FindShip

; 3284 : 		int   name_len = strlen(ship_name);

  0001a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001d	8d 49 00	 npad	 3
$LL20@FindShip:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL20@FindShip
  00027	2b c2		 sub	 eax, edx
  00029	8b d8		 mov	 ebx, eax

; 3285 : 
; 3286 : 		ListIter<Ship> ship_iter = ships;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c0 4c	 add	 eax, 76			; 0000004cH

; 3287 : 		while (++ship_iter && !ship) {

  00031	8d 55 f4	 lea	 edx, DWORD PTR _ship_iter$121082[ebp]
  00034	89 45 f4	 mov	 DWORD PTR _ship_iter$121082[ebp], eax
  00037	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _ship_iter$121082[ebp+4], -1
  0003e	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00043	85 c0		 test	 eax, eax
  00045	75 0e		 jne	 SHORT $LN4@FindShip
$LN25@FindShip:

; 3300 : 			}
; 3301 : 		}
; 3302 : 	}
; 3303 : 
; 3304 : 	return ship;

  00047	8b c6		 mov	 eax, esi

; 3305 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
$LL26@FindShip:

; 3287 : 		while (++ship_iter && !ship) {

  00052	8b 75 fc	 mov	 esi, DWORD PTR _ship$[ebp]
$LN4@FindShip:
  00055	85 f6		 test	 esi, esi
  00057	75 ee		 jne	 SHORT $LN25@FindShip

; 3288 : 			Ship* test = ship_iter.value();

  00059	8d 45 f4	 lea	 eax, DWORD PTR _ship_iter$121082[ebp]
  0005c	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value

; 3289 : 			if (!strncmp(test->Name(), ship_name, name_len)) {

  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _ship_name$[ebp]
  00064	8b f8		 mov	 edi, eax
  00066	53		 push	 ebx
  00067	51		 push	 ecx
  00068	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  0006b	56		 push	 esi
  0006c	e8 00 00 00 00	 call	 _strncmp
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	85 c0		 test	 eax, eax
  00076	75 1f		 jne	 SHORT $LN2@FindShip

; 3290 : 				int test_len = strlen(test->Name());

  00078	8b c6		 mov	 eax, esi
  0007a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0007d	8d 49 00	 npad	 3
$LL21@FindShip:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	40		 inc	 eax
  00083	84 c9		 test	 cl, cl
  00085	75 f9		 jne	 SHORT $LL21@FindShip
  00087	2b c2		 sub	 eax, edx

; 3291 : 
; 3292 : 				// The only fuzzy match is for element indices.
; 3293 : 				// The desired name "Alpha" matches "Alpha 1" and "Alpha 2"
; 3294 : 				// but not "Alpha-Centauri"
; 3295 : 
; 3296 : 				if (test_len > name_len && test->Name()[name_len] != ' ')

  00089	3b c3		 cmp	 eax, ebx
  0008b	7e 07		 jle	 SHORT $LN1@FindShip
  0008d	80 7c 1f 10 20	 cmp	 BYTE PTR [edi+ebx+16], 32 ; 00000020H
  00092	75 03		 jne	 SHORT $LN2@FindShip
$LN1@FindShip:

; 3297 : 				continue;
; 3298 : 
; 3299 : 				ship = test;

  00094	89 7d fc	 mov	 DWORD PTR _ship$[ebp], edi
$LN2@FindShip:

; 3287 : 		while (++ship_iter && !ship) {

  00097	8d 55 f4	 lea	 edx, DWORD PTR _ship_iter$121082[ebp]
  0009a	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  0009f	85 c0		 test	 eax, eax
  000a1	75 af		 jne	 SHORT $LL26@FindShip

; 3300 : 			}
; 3301 : 		}
; 3302 : 	}
; 3303 : 
; 3304 : 	return ship;

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _ship$[ebp]

; 3305 : }

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8
?FindShip@SimRegion@@QAEPAVShip@@PBD@Z ENDP		; SimRegion::FindShip
_TEXT	ENDS
PUBLIC	?UpdateExplosions@SimRegion@@IAEXN@Z		; SimRegion::UpdateExplosions
; Function compile flags: /Ogtp
;	COMDAT ?UpdateExplosions@SimRegion@@IAEXN@Z
_TEXT	SEGMENT
_debris_iter$ = -8					; size = 8
_exp_iter$ = -8						; size = 8
_seconds$ = 8						; size = 8
?UpdateExplosions@SimRegion@@IAEXN@Z PROC		; SimRegion::UpdateExplosions, COMDAT
; _this$ = eax

; 2667 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax

; 2668 : 	ListIter<Explosion> exp_iter = explosions;

  0000a	8d 87 94 00 00
	00		 lea	 eax, DWORD PTR [edi+148]

; 2669 : 	while (++exp_iter) {

  00010	8d 55 f8	 lea	 edx, DWORD PTR _exp_iter$[ebp]
  00013	89 45 f8	 mov	 DWORD PTR _exp_iter$[ebp], eax
  00016	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _exp_iter$[ebp+4], -1
  0001d	e8 00 00 00 00	 call	 ?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::next
  00022	85 c0		 test	 eax, eax
  00024	74 50		 je	 SHORT $LN5@UpdateExpl
$LL6@UpdateExpl:

; 2670 : 		Explosion* exp = exp_iter.value();

  00026	8d 45 f8	 lea	 eax, DWORD PTR _exp_iter$[ebp]
  00029	e8 00 00 00 00	 call	 ?value@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::value

; 2671 : 		exp->ExecFrame(seconds);

  0002e	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  00033	8b f0		 mov	 esi, eax
  00035	8b 16		 mov	 edx, DWORD PTR [esi]
  00037	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003a	83 ec 08	 sub	 esp, 8
  0003d	8b ce		 mov	 ecx, esi
  0003f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00044	ff d0		 call	 eax

; 2672 : 
; 2673 : 		if (exp->Life() < 0.01) {  // died of old age

  00046	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f847ae147ae147b
  0004e	66 0f 2f 86 a8
	01 00 00	 comisd	 xmm0, QWORD PTR [esi+424]
  00056	76 12		 jbe	 SHORT $LN9@UpdateExpl

; 2674 : 			exp_iter.removeItem();

  00058	8d 55 f8	 lea	 edx, DWORD PTR _exp_iter$[ebp]
  0005b	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::removeItem

; 2675 : 			delete exp;

  00060	8b 16		 mov	 edx, DWORD PTR [esi]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	6a 01		 push	 1
  00066	8b ce		 mov	 ecx, esi
  00068	ff d0		 call	 eax
$LN9@UpdateExpl:

; 2669 : 	while (++exp_iter) {

  0006a	8d 55 f8	 lea	 edx, DWORD PTR _exp_iter$[ebp]
  0006d	e8 00 00 00 00	 call	 ?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::next
  00072	85 c0		 test	 eax, eax
  00074	75 b0		 jne	 SHORT $LL6@UpdateExpl
$LN5@UpdateExpl:

; 2676 : 		}
; 2677 : 	}
; 2678 : 
; 2679 : 	ListIter<Debris> debris_iter = debris;

  00076	81 c7 a0 00 00
	00		 add	 edi, 160		; 000000a0H

; 2680 : 	while (++debris_iter) {

  0007c	8d 55 f8	 lea	 edx, DWORD PTR _debris_iter$[ebp]
  0007f	89 7d f8	 mov	 DWORD PTR _debris_iter$[ebp], edi
  00082	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _debris_iter$[ebp+4], -1
  00089	e8 00 00 00 00	 call	 ?next@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::next
  0008e	85 c0		 test	 eax, eax
  00090	74 50		 je	 SHORT $LN2@UpdateExpl
$LL3@UpdateExpl:

; 2681 : 		Debris* d = debris_iter.value();

  00092	8d 45 f8	 lea	 eax, DWORD PTR _debris_iter$[ebp]
  00095	e8 00 00 00 00	 call	 ?value@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::value

; 2682 : 		d->ExecFrame(seconds);

  0009a	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  0009f	8b f0		 mov	 esi, eax
  000a1	8b 16		 mov	 edx, DWORD PTR [esi]
  000a3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a6	83 ec 08	 sub	 esp, 8
  000a9	8b ce		 mov	 ecx, esi
  000ab	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000b0	ff d0		 call	 eax

; 2683 : 
; 2684 : 		if (d->Life() < 0.01) {  // died of old age

  000b2	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f847ae147ae147b
  000ba	66 0f 2f 86 a8
	01 00 00	 comisd	 xmm0, QWORD PTR [esi+424]
  000c2	76 12		 jbe	 SHORT $LN11@UpdateExpl

; 2685 : 			debris_iter.removeItem();

  000c4	8d 55 f8	 lea	 edx, DWORD PTR _debris_iter$[ebp]
  000c7	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::removeItem

; 2686 : 			delete d;

  000cc	8b 16		 mov	 edx, DWORD PTR [esi]
  000ce	8b 02		 mov	 eax, DWORD PTR [edx]
  000d0	6a 01		 push	 1
  000d2	8b ce		 mov	 ecx, esi
  000d4	ff d0		 call	 eax
$LN11@UpdateExpl:

; 2680 : 	while (++debris_iter) {

  000d6	8d 55 f8	 lea	 edx, DWORD PTR _debris_iter$[ebp]
  000d9	e8 00 00 00 00	 call	 ?next@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::next
  000de	85 c0		 test	 eax, eax
  000e0	75 b0		 jne	 SHORT $LL3@UpdateExpl
$LN2@UpdateExpl:

; 2687 : 		}
; 2688 : 	}
; 2689 : }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
?UpdateExplosions@SimRegion@@IAEXN@Z ENDP		; SimRegion::UpdateExplosions
_TEXT	ENDS
PUBLIC	?UpdateShips@SimRegion@@IAEXN@Z			; SimRegion::UpdateShips
; Function compile flags: /Ogtp
;	COMDAT ?UpdateShips@SimRegion@@IAEXN@Z
_TEXT	SEGMENT
_ship_iter$ = -8					; size = 8
_seconds$ = 8						; size = 8
?UpdateShips@SimRegion@@IAEXN@Z PROC			; SimRegion::UpdateShips, COMDAT
; _this$ = esi

; 2608 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2609 : 	int ship_index = 0;
; 2610 : 	if (ai_index > ships.size())

  00003	8b 8e 04 01 00
	00		 mov	 ecx, DWORD PTR [esi+260]
  00009	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000c	57		 push	 edi
  0000d	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  00010	33 ff		 xor	 edi, edi
  00012	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00014	7e 06		 jle	 SHORT $LN6@UpdateShip

; 2611 : 	ai_index = 0;

  00016	89 be 04 01 00
	00		 mov	 DWORD PTR [esi+260], edi
$LN6@UpdateShip:

; 2612 : 
; 2613 : 	ListIter<Ship> ship_iter = ships;
; 2614 : 	Ship* ship = 0;
; 2615 : 
; 2616 : 	while (++ship_iter) {

  0001c	8d 55 f8	 lea	 edx, DWORD PTR _ship_iter$[ebp]
  0001f	89 45 f8	 mov	 DWORD PTR _ship_iter$[ebp], eax
  00022	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ship_iter$[ebp+4], -1
  00029	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  0002e	85 c0		 test	 eax, eax
  00030	74 48		 je	 SHORT $LN21@UpdateShip
$LL5@UpdateShip:

; 2617 : 		ship = ship_iter.value();

  00032	8d 45 f8	 lea	 eax, DWORD PTR _ship_iter$[ebp]
  00035	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value

; 2618 : 		
; 2619 : 		if (ship_index == ai_index || ship == player_ship)

  0003a	3b be 04 01 00
	00		 cmp	 edi, DWORD PTR [esi+260]
  00040	74 0e		 je	 SHORT $LN2@UpdateShip
  00042	3b 46 44	 cmp	 eax, DWORD PTR [esi+68]
  00045	74 09		 je	 SHORT $LN2@UpdateShip

; 2621 : 		else
; 2622 : 		ship->SetAIMode(1);

  00047	c6 80 14 04 00
	00 01		 mov	 BYTE PTR [eax+1044], 1
  0004e	eb 07		 jmp	 SHORT $LN17@UpdateShip
$LN2@UpdateShip:

; 2620 : 		ship->SetAIMode(2);

  00050	c6 80 14 04 00
	00 02		 mov	 BYTE PTR [eax+1044], 2

; 2621 : 		else
; 2622 : 		ship->SetAIMode(1);

$LN17@UpdateShip:

; 2623 : 
; 2624 : 		ship->ExecFrame(seconds);

  00057	8b 10		 mov	 edx, DWORD PTR [eax]
  00059	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  0005e	83 ec 08	 sub	 esp, 8
  00061	8b c8		 mov	 ecx, eax
  00063	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00066	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0006b	ff d0		 call	 eax
  0006d	8d 55 f8	 lea	 edx, DWORD PTR _ship_iter$[ebp]

; 2625 : 		ship_index++;

  00070	47		 inc	 edi
  00071	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00076	85 c0		 test	 eax, eax
  00078	75 b8		 jne	 SHORT $LL5@UpdateShip
$LN21@UpdateShip:

; 2626 : 	}
; 2627 : 
; 2628 : 	ai_index++;

  0007a	ff 86 04 01 00
	00		 inc	 DWORD PTR [esi+260]

; 2629 : }

  00080	5f		 pop	 edi
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
?UpdateShips@SimRegion@@IAEXN@Z ENDP			; SimRegion::UpdateShips
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Deactivate@SimRegion@@UAEXXZ
_TEXT	SEGMENT
_a$ = -8						; size = 8
_deb$ = -8						; size = 8
_exp$ = -8						; size = 8
_shot$ = -8						; size = 8
_ship$ = -8						; size = 8
?Deactivate@SimRegion@@UAEXXZ PROC			; SimRegion::Deactivate, COMDAT
; _this$ = ecx

; 2467 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 2468 : 	if (!sim) return;

  0000c	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00010	57		 push	 edi
  00011	0f 84 a4 01 00
	00		 je	 $LN1@Deactivate

; 2469 : 
; 2470 : 	ListIter<Ship> ship = ships;

  00017	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  0001a	83 cf ff	 or	 edi, -1

; 2471 : 	while (++ship)

  0001d	8d 54 24 08	 lea	 edx, DWORD PTR _ship$[esp+16]
  00021	89 44 24 08	 mov	 DWORD PTR _ship$[esp+16], eax
  00025	89 7c 24 0c	 mov	 DWORD PTR _ship$[esp+20], edi
  00029	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  0002e	85 c0		 test	 eax, eax
  00030	74 29		 je	 SHORT $LN14@Deactivate
$LL15@Deactivate:

; 2472 : 	ship->Deactivate(sim->scene);

  00032	8d 44 24 08	 lea	 eax, DWORD PTR _ship$[esp+16]
  00036	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	8b 10		 mov	 edx, DWORD PTR [eax]
  00040	8b 92 a8 00 00
	00		 mov	 edx, DWORD PTR [edx+168]
  00046	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00049	51		 push	 ecx
  0004a	8b c8		 mov	 ecx, eax
  0004c	ff d2		 call	 edx
  0004e	8d 54 24 08	 lea	 edx, DWORD PTR _ship$[esp+16]
  00052	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00057	85 c0		 test	 eax, eax
  00059	75 d7		 jne	 SHORT $LL15@Deactivate
$LN14@Deactivate:

; 2473 : 
; 2474 : 	ListIter<Shot> shot = shots;

  0005b	8d 46 7c	 lea	 eax, DWORD PTR [esi+124]

; 2475 : 	while (++shot)

  0005e	8d 54 24 08	 lea	 edx, DWORD PTR _shot$[esp+16]
  00062	89 44 24 08	 mov	 DWORD PTR _shot$[esp+16], eax
  00066	89 7c 24 0c	 mov	 DWORD PTR _shot$[esp+20], edi
  0006a	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  0006f	85 c0		 test	 eax, eax
  00071	74 29		 je	 SHORT $LN12@Deactivate
$LL13@Deactivate:

; 2476 : 	shot->Deactivate(sim->scene);

  00073	8d 44 24 08	 lea	 eax, DWORD PTR _shot$[esp+16]
  00077	e8 00 00 00 00	 call	 ?value@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::value
  0007c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0007f	8b 10		 mov	 edx, DWORD PTR [eax]
  00081	8b 92 a8 00 00
	00		 mov	 edx, DWORD PTR [edx+168]
  00087	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008a	51		 push	 ecx
  0008b	8b c8		 mov	 ecx, eax
  0008d	ff d2		 call	 edx
  0008f	8d 54 24 08	 lea	 edx, DWORD PTR _shot$[esp+16]
  00093	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  00098	85 c0		 test	 eax, eax
  0009a	75 d7		 jne	 SHORT $LL13@Deactivate
$LN12@Deactivate:

; 2477 : 
; 2478 : 	ListIter<Explosion> exp = explosions;

  0009c	8d 86 94 00 00
	00		 lea	 eax, DWORD PTR [esi+148]

; 2479 : 	while (++exp)

  000a2	8d 54 24 08	 lea	 edx, DWORD PTR _exp$[esp+16]
  000a6	89 44 24 08	 mov	 DWORD PTR _exp$[esp+16], eax
  000aa	89 7c 24 0c	 mov	 DWORD PTR _exp$[esp+20], edi
  000ae	e8 00 00 00 00	 call	 ?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::next
  000b3	85 c0		 test	 eax, eax
  000b5	74 29		 je	 SHORT $LN10@Deactivate
$LL11@Deactivate:

; 2480 : 	exp->Deactivate(sim->scene);

  000b7	8d 44 24 08	 lea	 eax, DWORD PTR _exp$[esp+16]
  000bb	e8 00 00 00 00	 call	 ?value@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::value
  000c0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c3	8b 10		 mov	 edx, DWORD PTR [eax]
  000c5	8b 92 a8 00 00
	00		 mov	 edx, DWORD PTR [edx+168]
  000cb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000ce	51		 push	 ecx
  000cf	8b c8		 mov	 ecx, eax
  000d1	ff d2		 call	 edx
  000d3	8d 54 24 08	 lea	 edx, DWORD PTR _exp$[esp+16]
  000d7	e8 00 00 00 00	 call	 ?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::next
  000dc	85 c0		 test	 eax, eax
  000de	75 d7		 jne	 SHORT $LL11@Deactivate
$LN10@Deactivate:

; 2481 : 
; 2482 : 	ListIter<Debris> deb = debris;

  000e0	8d 86 a0 00 00
	00		 lea	 eax, DWORD PTR [esi+160]

; 2483 : 	while (++deb)

  000e6	8d 54 24 08	 lea	 edx, DWORD PTR _deb$[esp+16]
  000ea	89 44 24 08	 mov	 DWORD PTR _deb$[esp+16], eax
  000ee	89 7c 24 0c	 mov	 DWORD PTR _deb$[esp+20], edi
  000f2	e8 00 00 00 00	 call	 ?next@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::next
  000f7	85 c0		 test	 eax, eax
  000f9	74 2e		 je	 SHORT $LN8@Deactivate
  000fb	eb 03 8d 49 00	 npad	 5
$LL9@Deactivate:

; 2484 : 	deb->Deactivate(sim->scene);

  00100	8d 44 24 08	 lea	 eax, DWORD PTR _deb$[esp+16]
  00104	e8 00 00 00 00	 call	 ?value@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::value
  00109	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0010c	8b 10		 mov	 edx, DWORD PTR [eax]
  0010e	8b 92 a8 00 00
	00		 mov	 edx, DWORD PTR [edx+168]
  00114	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00117	51		 push	 ecx
  00118	8b c8		 mov	 ecx, eax
  0011a	ff d2		 call	 edx
  0011c	8d 54 24 08	 lea	 edx, DWORD PTR _deb$[esp+16]
  00120	e8 00 00 00 00	 call	 ?next@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::next
  00125	85 c0		 test	 eax, eax
  00127	75 d7		 jne	 SHORT $LL9@Deactivate
$LN8@Deactivate:

; 2485 : 
; 2486 : 	ListIter<Asteroid> a = asteroids;

  00129	8d 86 ac 00 00
	00		 lea	 eax, DWORD PTR [esi+172]

; 2487 : 	while (++a)

  0012f	8d 54 24 08	 lea	 edx, DWORD PTR _a$[esp+16]
  00133	89 44 24 08	 mov	 DWORD PTR _a$[esp+16], eax
  00137	89 7c 24 0c	 mov	 DWORD PTR _a$[esp+20], edi
  0013b	e8 00 00 00 00	 call	 ?next@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::next
  00140	85 c0		 test	 eax, eax
  00142	74 29		 je	 SHORT $LN6@Deactivate
$LL7@Deactivate:

; 2488 : 	a->Deactivate(sim->scene);

  00144	8d 44 24 08	 lea	 eax, DWORD PTR _a$[esp+16]
  00148	e8 00 00 00 00	 call	 ?value@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::value
  0014d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00150	8b 10		 mov	 edx, DWORD PTR [eax]
  00152	8b 92 a8 00 00
	00		 mov	 edx, DWORD PTR [edx+168]
  00158	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0015b	51		 push	 ecx
  0015c	8b c8		 mov	 ecx, eax
  0015e	ff d2		 call	 edx
  00160	8d 54 24 08	 lea	 edx, DWORD PTR _a$[esp+16]
  00164	e8 00 00 00 00	 call	 ?next@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::next
  00169	85 c0		 test	 eax, eax
  0016b	75 d7		 jne	 SHORT $LL7@Deactivate
$LN6@Deactivate:

; 2489 : 
; 2490 : 	if (grid)

  0016d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00170	85 c0		 test	 eax, eax
  00172	74 0c		 je	 SHORT $LN5@Deactivate

; 2491 : 	sim->scene.DelGraphic(grid);

  00174	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00177	50		 push	 eax
  00178	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0017b	e8 00 00 00 00	 call	 ?DelGraphic@Scene@@QAEXPAVGraphic@@@Z ; Scene::DelGraphic
$LN5@Deactivate:

; 2492 : 
; 2493 : 	if (terrain)

  00180	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00183	85 c9		 test	 ecx, ecx
  00185	74 0e		 je	 SHORT $LN4@Deactivate

; 2494 : 	terrain->Deactivate(sim->scene);

  00187	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0018a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0018c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0018f	83 c2 0c	 add	 edx, 12			; 0000000cH
  00192	52		 push	 edx
  00193	ff d0		 call	 eax
$LN4@Deactivate:

; 2495 : 
; 2496 : 	player_ship = 0;

  00195	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 2497 : 	active      = false;

  0019c	c6 46 40 00	 mov	 BYTE PTR [esi+64], 0
  001a0	81 c6 b8 00 00
	00		 add	 esi, 184		; 000000b8H
  001a6	bf 05 00 00 00	 mov	 edi, 5
  001ab	eb 03 8d 49 00	 npad	 5
$LL3@Deactivate:

; 2498 : 
; 2499 : 	for (int i = 0; i < 5; i++)
; 2500 : 	track_database[i].destroy();

  001b0	e8 00 00 00 00	 call	 ?destroy@?$List@VContact@@@@QAEXXZ ; List<Contact>::destroy
  001b5	83 c6 0c	 add	 esi, 12			; 0000000cH
  001b8	4f		 dec	 edi
  001b9	75 f5		 jne	 SHORT $LL3@Deactivate
$LN1@Deactivate:

; 2501 : }

  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
?Deactivate@SimRegion@@UAEXXZ ENDP			; SimRegion::Deactivate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Activate@SimRegion@@UAEXXZ
_TEXT	SEGMENT
_a$ = -8						; size = 8
_deb$ = -8						; size = 8
_exp$ = -8						; size = 8
_shot$ = -8						; size = 8
_ship$ = -8						; size = 8
?Activate@SimRegion@@UAEXXZ PROC			; SimRegion::Activate, COMDAT
; _this$ = ecx

; 2430 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 2431 : 	if (!sim) return;

  0000c	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00010	57		 push	 edi
  00011	0f 84 89 01 00
	00		 je	 $LN14@Activate

; 2432 : 
; 2433 : 	ListIter<Ship> ship = ships;

  00017	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  0001a	83 cf ff	 or	 edi, -1

; 2434 : 	while (++ship)

  0001d	8d 54 24 08	 lea	 edx, DWORD PTR _ship$[esp+16]
  00021	89 44 24 08	 mov	 DWORD PTR _ship$[esp+16], eax
  00025	89 7c 24 0c	 mov	 DWORD PTR _ship$[esp+20], edi
  00029	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  0002e	85 c0		 test	 eax, eax
  00030	74 29		 je	 SHORT $LN11@Activate
$LL12@Activate:

; 2435 : 	ship->Activate(sim->scene);

  00032	8d 44 24 08	 lea	 eax, DWORD PTR _ship$[esp+16]
  00036	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	8b 10		 mov	 edx, DWORD PTR [eax]
  00040	8b 92 a4 00 00
	00		 mov	 edx, DWORD PTR [edx+164]
  00046	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00049	51		 push	 ecx
  0004a	8b c8		 mov	 ecx, eax
  0004c	ff d2		 call	 edx
  0004e	8d 54 24 08	 lea	 edx, DWORD PTR _ship$[esp+16]
  00052	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00057	85 c0		 test	 eax, eax
  00059	75 d7		 jne	 SHORT $LL12@Activate
$LN11@Activate:

; 2436 : 
; 2437 : 	ListIter<Shot> shot = shots;

  0005b	8d 46 7c	 lea	 eax, DWORD PTR [esi+124]

; 2438 : 	while (++shot)

  0005e	8d 54 24 08	 lea	 edx, DWORD PTR _shot$[esp+16]
  00062	89 44 24 08	 mov	 DWORD PTR _shot$[esp+16], eax
  00066	89 7c 24 0c	 mov	 DWORD PTR _shot$[esp+20], edi
  0006a	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  0006f	85 c0		 test	 eax, eax
  00071	74 29		 je	 SHORT $LN9@Activate
$LL10@Activate:

; 2439 : 	shot->Activate(sim->scene);

  00073	8d 44 24 08	 lea	 eax, DWORD PTR _shot$[esp+16]
  00077	e8 00 00 00 00	 call	 ?value@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::value
  0007c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0007f	8b 10		 mov	 edx, DWORD PTR [eax]
  00081	8b 92 a4 00 00
	00		 mov	 edx, DWORD PTR [edx+164]
  00087	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008a	51		 push	 ecx
  0008b	8b c8		 mov	 ecx, eax
  0008d	ff d2		 call	 edx
  0008f	8d 54 24 08	 lea	 edx, DWORD PTR _shot$[esp+16]
  00093	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  00098	85 c0		 test	 eax, eax
  0009a	75 d7		 jne	 SHORT $LL10@Activate
$LN9@Activate:

; 2440 : 
; 2441 : 	ListIter<Explosion> exp = explosions;

  0009c	8d 86 94 00 00
	00		 lea	 eax, DWORD PTR [esi+148]

; 2442 : 	while (++exp)

  000a2	8d 54 24 08	 lea	 edx, DWORD PTR _exp$[esp+16]
  000a6	89 44 24 08	 mov	 DWORD PTR _exp$[esp+16], eax
  000aa	89 7c 24 0c	 mov	 DWORD PTR _exp$[esp+20], edi
  000ae	e8 00 00 00 00	 call	 ?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::next
  000b3	85 c0		 test	 eax, eax
  000b5	74 29		 je	 SHORT $LN7@Activate
$LL8@Activate:

; 2443 : 	exp->Activate(sim->scene);

  000b7	8d 44 24 08	 lea	 eax, DWORD PTR _exp$[esp+16]
  000bb	e8 00 00 00 00	 call	 ?value@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::value
  000c0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c3	8b 10		 mov	 edx, DWORD PTR [eax]
  000c5	8b 92 a4 00 00
	00		 mov	 edx, DWORD PTR [edx+164]
  000cb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000ce	51		 push	 ecx
  000cf	8b c8		 mov	 ecx, eax
  000d1	ff d2		 call	 edx
  000d3	8d 54 24 08	 lea	 edx, DWORD PTR _exp$[esp+16]
  000d7	e8 00 00 00 00	 call	 ?next@?$ListIter@VExplosion@@@@QAEPAVExplosion@@XZ ; ListIter<Explosion>::next
  000dc	85 c0		 test	 eax, eax
  000de	75 d7		 jne	 SHORT $LL8@Activate
$LN7@Activate:

; 2444 : 
; 2445 : 	ListIter<Debris> deb = debris;

  000e0	8d 86 a0 00 00
	00		 lea	 eax, DWORD PTR [esi+160]

; 2446 : 	while (++deb)

  000e6	8d 54 24 08	 lea	 edx, DWORD PTR _deb$[esp+16]
  000ea	89 44 24 08	 mov	 DWORD PTR _deb$[esp+16], eax
  000ee	89 7c 24 0c	 mov	 DWORD PTR _deb$[esp+20], edi
  000f2	e8 00 00 00 00	 call	 ?next@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::next
  000f7	85 c0		 test	 eax, eax
  000f9	74 2e		 je	 SHORT $LN5@Activate
  000fb	eb 03 8d 49 00	 npad	 5
$LL6@Activate:

; 2447 : 	deb->Activate(sim->scene);

  00100	8d 44 24 08	 lea	 eax, DWORD PTR _deb$[esp+16]
  00104	e8 00 00 00 00	 call	 ?value@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::value
  00109	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0010c	8b 10		 mov	 edx, DWORD PTR [eax]
  0010e	8b 92 a4 00 00
	00		 mov	 edx, DWORD PTR [edx+164]
  00114	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00117	51		 push	 ecx
  00118	8b c8		 mov	 ecx, eax
  0011a	ff d2		 call	 edx
  0011c	8d 54 24 08	 lea	 edx, DWORD PTR _deb$[esp+16]
  00120	e8 00 00 00 00	 call	 ?next@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::next
  00125	85 c0		 test	 eax, eax
  00127	75 d7		 jne	 SHORT $LL6@Activate
$LN5@Activate:

; 2448 : 
; 2449 : 	ListIter<Asteroid> a = asteroids;

  00129	8d 86 ac 00 00
	00		 lea	 eax, DWORD PTR [esi+172]

; 2450 : 	while (++a)

  0012f	8d 54 24 08	 lea	 edx, DWORD PTR _a$[esp+16]
  00133	89 44 24 08	 mov	 DWORD PTR _a$[esp+16], eax
  00137	89 7c 24 0c	 mov	 DWORD PTR _a$[esp+20], edi
  0013b	e8 00 00 00 00	 call	 ?next@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::next
  00140	85 c0		 test	 eax, eax
  00142	74 29		 je	 SHORT $LN3@Activate
$LL4@Activate:

; 2451 : 	a->Activate(sim->scene);

  00144	8d 44 24 08	 lea	 eax, DWORD PTR _a$[esp+16]
  00148	e8 00 00 00 00	 call	 ?value@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::value
  0014d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00150	8b 10		 mov	 edx, DWORD PTR [eax]
  00152	8b 92 a4 00 00
	00		 mov	 edx, DWORD PTR [edx+164]
  00158	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0015b	51		 push	 ecx
  0015c	8b c8		 mov	 ecx, eax
  0015e	ff d2		 call	 edx
  00160	8d 54 24 08	 lea	 edx, DWORD PTR _a$[esp+16]
  00164	e8 00 00 00 00	 call	 ?next@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::next
  00169	85 c0		 test	 eax, eax
  0016b	75 d7		 jne	 SHORT $LL4@Activate
$LN3@Activate:

; 2452 : 
; 2453 : 	if (grid)

  0016d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00170	85 c0		 test	 eax, eax
  00172	74 0c		 je	 SHORT $LN2@Activate

; 2454 : 	sim->scene.AddGraphic(grid);

  00174	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00177	50		 push	 eax
  00178	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0017b	e8 00 00 00 00	 call	 ?AddGraphic@Scene@@QAEXPAVGraphic@@@Z ; Scene::AddGraphic
$LN2@Activate:

; 2455 : 
; 2456 : 	if (terrain)

  00180	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00183	85 c9		 test	 ecx, ecx
  00185	74 0e		 je	 SHORT $LN1@Activate

; 2457 : 	terrain->Activate(sim->scene);

  00187	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0018a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0018c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018f	83 c2 0c	 add	 edx, 12			; 0000000cH
  00192	52		 push	 edx
  00193	ff d0		 call	 eax
$LN1@Activate:

; 2458 : 
; 2459 : 	player_ship = 0;

  00195	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 2460 : 	active      = true;

  0019c	c6 46 40 01	 mov	 BYTE PTR [esi+64], 1
$LN14@Activate:

; 2461 : }

  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi
  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
?Activate@SimRegion@@UAEXXZ ENDP			; SimRegion::Activate
_TEXT	ENDS
PUBLIC	?ClearSelection@SimRegion@@QAEXXZ		; SimRegion::ClearSelection
; Function compile flags: /Ogtp
;	COMDAT ?ClearSelection@SimRegion@@QAEXXZ
_TEXT	SEGMENT
?ClearSelection@SimRegion@@QAEXXZ PROC			; SimRegion::ClearSelection, COMDAT
; _this$ = eax

; 2410 : {

  00000	56		 push	 esi

; 2411 : 	selection.clear();

  00001	8d 70 64	 lea	 esi, DWORD PTR [eax+100]
  00004	e8 00 00 00 00	 call	 ?clear@?$List@VShip@@@@QAEXXZ ; List<Ship>::clear
  00009	5e		 pop	 esi

; 2412 : }

  0000a	c3		 ret	 0
?ClearSelection@SimRegion@@QAEXXZ ENDP			; SimRegion::ClearSelection
_TEXT	ENDS
PUBLIC	?GetSelection@SimRegion@@QAE?AV?$ListIter@VShip@@@@XZ ; SimRegion::GetSelection
; Function compile flags: /Ogtp
;	COMDAT ?GetSelection@SimRegion@@QAE?AV?$ListIter@VShip@@@@XZ
_TEXT	SEGMENT
?GetSelection@SimRegion@@QAE?AV?$ListIter@VShip@@@@XZ PROC ; SimRegion::GetSelection, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 2398 : 	return selection;

  00000	83 c1 64	 add	 ecx, 100		; 00000064H
  00003	89 08		 mov	 DWORD PTR [eax], ecx
  00005	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 2399 : }

  0000c	c3		 ret	 0
?GetSelection@SimRegion@@QAE?AV?$ListIter@VShip@@@@XZ ENDP ; SimRegion::GetSelection
_TEXT	ENDS
PUBLIC	??1SimRegion@@UAE@XZ				; SimRegion::~SimRegion
;	COMDAT xdata$x
; File c:\matrix games\dev\foundationex\list.h
xdata$x	SEGMENT
__unwindtable$??1SimRegion@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??1SimRegion@@UAE@XZ$11
__ehfuncinfo$??1SimRegion@@UAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??1SimRegion@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ??1SimRegion@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv149 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1SimRegion@@UAE@XZ PROC				; SimRegion::~SimRegion, COMDAT
; _this$ = ecx

; 2279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1SimRegion@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7SimRegion@@6B@
  00033	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 11 ; 0000000bH

; 2280 : 	GRAPHIC_DESTROY(grid);

  0003a	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  0003d	85 c9		 test	 ecx, ecx
  0003f	74 0e		 je	 SHORT $LN4@SimRegion
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	8b 50 44	 mov	 edx, DWORD PTR [eax+68]
  00046	ff d2		 call	 edx
  00048	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
$LN4@SimRegion:

; 2281 : 	delete terrain;

  0004f	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  00052	85 c9		 test	 ecx, ecx
  00054	74 08		 je	 SHORT $LN7@SimRegion
  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	6a 01		 push	 1
  0005c	ff d2		 call	 edx
$LN7@SimRegion:

; 2282 : 	explosions.destroy();

  0005e	8d b7 94 00 00
	00		 lea	 esi, DWORD PTR [edi+148]
  00064	e8 00 00 00 00	 call	 ?destroy@?$List@VExplosion@@@@QAEXXZ ; List<Explosion>::destroy

; 2283 : 	shots.destroy();

  00069	8d 77 7c	 lea	 esi, DWORD PTR [edi+124]
  0006c	e8 00 00 00 00	 call	 ?destroy@?$List@VShot@@@@QAEXXZ ; List<Shot>::destroy

; 2284 : 	ships.destroy();

  00071	8d 77 4c	 lea	 esi, DWORD PTR [edi+76]
  00074	e8 00 00 00 00	 call	 ?destroy@?$List@VShip@@@@QAEXXZ ; List<Ship>::destroy

; 2285 : 	debris.destroy();

  00079	8d b7 a0 00 00
	00		 lea	 esi, DWORD PTR [edi+160]
  0007f	e8 00 00 00 00	 call	 ?destroy@?$List@VDebris@@@@QAEXXZ ; List<Debris>::destroy

; 2286 : 	asteroids.destroy();

  00084	8d b7 ac 00 00
	00		 lea	 esi, DWORD PTR [edi+172]
  0008a	e8 00 00 00 00	 call	 ?destroy@?$List@VAsteroid@@@@QAEXXZ ; List<Asteroid>::destroy

; 2287 : 	dead_ships.destroy();

  0008f	8d 77 70	 lea	 esi, DWORD PTR [edi+112]
  00092	e8 00 00 00 00	 call	 ?destroy@?$List@VShip@@@@QAEXXZ ; List<Ship>::destroy
  00097	8d 9f b8 00 00
	00		 lea	 ebx, DWORD PTR [edi+184]
  0009d	8b f3		 mov	 esi, ebx
  0009f	c7 45 f0 05 00
	00 00		 mov	 DWORD PTR tv149[ebp], 5
$LL3@SimRegion:

; 2288 : 
; 2289 : 	for (int i = 0; i < 5; i++)
; 2290 : 	track_database[i].destroy();

  000a6	e8 00 00 00 00	 call	 ?destroy@?$List@VContact@@@@QAEXXZ ; List<Contact>::destroy
  000ab	83 c6 0c	 add	 esi, 12			; 0000000cH
  000ae	ff 4d f0	 dec	 DWORD PTR tv149[ebp]
  000b1	75 f3		 jne	 SHORT $LL3@SimRegion

; 2291 : }

  000b3	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  000b7	8b 87 fc 00 00
	00		 mov	 eax, DWORD PTR [edi+252]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c3	83 c4 04	 add	 esp, 4
  000c6	68 00 00 00 00	 push	 OFFSET ??1?$List@VContact@@@@QAE@XZ ; List<Contact>::~List<Contact>
  000cb	6a 05		 push	 5
  000cd	6a 0c		 push	 12			; 0000000cH
  000cf	53		 push	 ebx
  000d0	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  000d4	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  000d9	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [edi+180]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000e5	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000f1	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000fd	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00109	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00115	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00119	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00122	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00126	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0012f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00133	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0013c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00140	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00149	83 c4 24	 add	 esp, 36			; 00000024H
  0014c	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  0014f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00156	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  0015b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0015e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00165	59		 pop	 ecx
  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	5b		 pop	 ebx
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1SimRegion@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$??1SimRegion@@UAE@XZ$1:
  0000b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	83 c0 4c	 add	 eax, 76			; 0000004cH
  00011	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??1SimRegion@@UAE@XZ$2:
  00016	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c0 58	 add	 eax, 88			; 00000058H
  0001c	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??1SimRegion@@UAE@XZ$3:
  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c0 64	 add	 eax, 100		; 00000064H
  00027	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??1SimRegion@@UAE@XZ$4:
  0002c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c0 70	 add	 eax, 112		; 00000070H
  00032	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??1SimRegion@@UAE@XZ$5:
  00037	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 c0 7c	 add	 eax, 124		; 0000007cH
  0003d	e9 00 00 00 00	 jmp	 ??1?$List@VShot@@@@QAE@XZ ; List<Shot>::~List<Shot>
__unwindfunclet$??1SimRegion@@UAE@XZ$6:
  00042	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00045	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0004a	e9 00 00 00 00	 jmp	 ??1?$List@VDrone@@@@QAE@XZ ; List<Drone>::~List<Drone>
__unwindfunclet$??1SimRegion@@UAE@XZ$7:
  0004f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00052	05 94 00 00 00	 add	 eax, 148		; 00000094H
  00057	e9 00 00 00 00	 jmp	 ??1?$List@VExplosion@@@@QAE@XZ ; List<Explosion>::~List<Explosion>
__unwindfunclet$??1SimRegion@@UAE@XZ$8:
  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00064	e9 00 00 00 00	 jmp	 ??1?$List@VDebris@@@@QAE@XZ ; List<Debris>::~List<Debris>
__unwindfunclet$??1SimRegion@@UAE@XZ$9:
  00069	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	05 ac 00 00 00	 add	 eax, 172		; 000000acH
  00071	e9 00 00 00 00	 jmp	 ??1?$List@VAsteroid@@@@QAE@XZ ; List<Asteroid>::~List<Asteroid>
__unwindfunclet$??1SimRegion@@UAE@XZ$10:
  00076	68 00 00 00 00	 push	 OFFSET ??1?$List@VContact@@@@QAE@XZ ; List<Contact>::~List<Contact>
  0007b	6a 05		 push	 5
  0007d	6a 0c		 push	 12			; 0000000cH
  0007f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00082	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0008d	c3		 ret	 0
__unwindfunclet$??1SimRegion@@UAE@XZ$11:
  0008e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00091	05 f4 00 00 00	 add	 eax, 244		; 000000f4H
  00096	e9 00 00 00 00	 jmp	 ??1?$List@VSimRegion@@@@QAE@XZ ; List<SimRegion>::~List<SimRegion>
__ehhandler$??1SimRegion@@UAE@XZ:
  0009b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0009f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000a2	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  000a5	33 c8		 xor	 ecx, eax
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1SimRegion@@UAE@XZ
  000b1	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1SimRegion@@UAE@XZ ENDP				; SimRegion::~SimRegion
; Function compile flags: /Ogtp
;	COMDAT ??_GSimRegion@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSimRegion@@UAEPAXI@Z PROC				; SimRegion::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1SimRegion@@UAE@XZ	; SimRegion::~SimRegion
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@3
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@3:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GSimRegion@@UAEPAXI@Z ENDP				; SimRegion::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0SimRegion@@QAE@PAVSim@@PBDH@Z		; SimRegion::SimRegion
;	COMDAT xdata$x
; File c:\matrix games\dev\stars45\sim.h
xdata$x	SEGMENT
__unwindtable$??0SimRegion@@QAE@PAVSim@@PBDH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$9
__ehfuncinfo$??0SimRegion@@QAE@PAVSim@@PBDH@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??0SimRegion@@QAE@PAVSim@@PBDH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ??0SimRegion@@QAE@PAVSim@@PBDH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
??0SimRegion@@QAE@PAVSim@@PBDH@Z PROC			; SimRegion::SimRegion, COMDAT
; _n$ = ecx

; 2234 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SimRegion@@QAE@PAVSim@@PBDH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00027	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0002a	51		 push	 ecx
  0002b	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SimRegion@@6B@
  00034	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00037	e8 00 00 00 00	 call	 ??0Text@@QAE@PBD@Z	; Text::Text
  0003c	8b 55 10	 mov	 edx, DWORD PTR _t$[ebp]
  0003f	33 db		 xor	 ebx, ebx
  00041	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0004a	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  0004d	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  00050	f2 0f 11 46 20	 movsd	 QWORD PTR [esi+32], xmm0
  00055	f2 0f 11 46 28	 movsd	 QWORD PTR [esi+40], xmm0
  0005a	f2 0f 11 46 30	 movsd	 QWORD PTR [esi+48], xmm0
  0005f	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  00062	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  00065	88 5e 40	 mov	 BYTE PTR [esi+64], bl
  00068	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  0006b	89 5e 48	 mov	 DWORD PTR [esi+72], ebx
  0006e	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
  00071	89 5e 50	 mov	 DWORD PTR [esi+80], ebx
  00074	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  00077	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  0007a	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx
  0007d	89 5e 60	 mov	 DWORD PTR [esi+96], ebx
  00080	89 5e 64	 mov	 DWORD PTR [esi+100], ebx
  00083	89 5e 68	 mov	 DWORD PTR [esi+104], ebx
  00086	89 5e 6c	 mov	 DWORD PTR [esi+108], ebx
  00089	89 5e 70	 mov	 DWORD PTR [esi+112], ebx
  0008c	89 5e 74	 mov	 DWORD PTR [esi+116], ebx
  0008f	89 5e 78	 mov	 DWORD PTR [esi+120], ebx
  00092	89 5e 7c	 mov	 DWORD PTR [esi+124], ebx
  00095	89 9e 80 00 00
	00		 mov	 DWORD PTR [esi+128], ebx
  0009b	89 9e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ebx
  000a1	89 9e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ebx
  000a7	89 9e 8c 00 00
	00		 mov	 DWORD PTR [esi+140], ebx
  000ad	89 9e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ebx
  000b3	89 9e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ebx
  000b9	89 9e 98 00 00
	00		 mov	 DWORD PTR [esi+152], ebx
  000bf	89 9e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ebx
  000c5	89 9e a0 00 00
	00		 mov	 DWORD PTR [esi+160], ebx
  000cb	89 9e a4 00 00
	00		 mov	 DWORD PTR [esi+164], ebx
  000d1	89 9e a8 00 00
	00		 mov	 DWORD PTR [esi+168], ebx
  000d7	89 9e ac 00 00
	00		 mov	 DWORD PTR [esi+172], ebx
  000dd	89 9e b0 00 00
	00		 mov	 DWORD PTR [esi+176], ebx
  000e3	89 9e b4 00 00
	00		 mov	 DWORD PTR [esi+180], ebx
  000e9	68 00 00 00 00	 push	 OFFSET ??1?$List@VContact@@@@QAE@XZ ; List<Contact>::~List<Contact>
  000ee	68 00 00 00 00	 push	 OFFSET ??0?$List@VContact@@@@QAE@XZ ; List<Contact>::List<Contact>
  000f3	6a 05		 push	 5
  000f5	6a 0c		 push	 12			; 0000000cH
  000f7	8d 86 b8 00 00
	00		 lea	 eax, DWORD PTR [esi+184]
  000fd	50		 push	 eax
  000fe	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00102	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  00107	89 9e f4 00 00
	00		 mov	 DWORD PTR [esi+244], ebx
  0010d	89 9e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ebx
  00113	89 9e fc 00 00
	00		 mov	 DWORD PTR [esi+252], ebx

; 2235 : 	if (sim) {

  00119	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0011c	89 9e 00 01 00
	00		 mov	 DWORD PTR [esi+256], ebx
  00122	89 9e 04 01 00
	00		 mov	 DWORD PTR [esi+260], ebx
  00128	3b c3		 cmp	 eax, ebx
  0012a	74 06		 je	 SHORT $LN40@SimRegion@2

; 2236 : 		star_system = sim->GetStarSystem();

  0012c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012f	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
$LN40@SimRegion@2:

; 2237 : 	}
; 2238 : }

  00132	8b c6		 mov	 eax, esi
  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5e		 pop	 esi
  00140	5b		 pop	 ebx
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$0:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$1:
  0000b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	83 c0 4c	 add	 eax, 76			; 0000004cH
  00011	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$2:
  00016	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c0 58	 add	 eax, 88			; 00000058H
  0001c	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$3:
  00021	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c0 64	 add	 eax, 100		; 00000064H
  00027	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$4:
  0002c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c0 70	 add	 eax, 112		; 00000070H
  00032	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$5:
  00037	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 c0 7c	 add	 eax, 124		; 0000007cH
  0003d	e9 00 00 00 00	 jmp	 ??1?$List@VShot@@@@QAE@XZ ; List<Shot>::~List<Shot>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$6:
  00042	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00045	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0004a	e9 00 00 00 00	 jmp	 ??1?$List@VDrone@@@@QAE@XZ ; List<Drone>::~List<Drone>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$7:
  0004f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00052	05 94 00 00 00	 add	 eax, 148		; 00000094H
  00057	e9 00 00 00 00	 jmp	 ??1?$List@VExplosion@@@@QAE@XZ ; List<Explosion>::~List<Explosion>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$8:
  0005c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00064	e9 00 00 00 00	 jmp	 ??1?$List@VDebris@@@@QAE@XZ ; List<Debris>::~List<Debris>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PBDH@Z$9:
  00069	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	05 ac 00 00 00	 add	 eax, 172		; 000000acH
  00071	e9 00 00 00 00	 jmp	 ??1?$List@VAsteroid@@@@QAE@XZ ; List<Asteroid>::~List<Asteroid>
__ehhandler$??0SimRegion@@QAE@PAVSim@@PBDH@Z:
  00076	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0007a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0007d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00080	33 c8		 xor	 ecx, eax
  00082	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00087	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SimRegion@@QAE@PAVSim@@PBDH@Z
  0008c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SimRegion@@QAE@PAVSim@@PBDH@Z ENDP			; SimRegion::SimRegion
PUBLIC	?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z		; Sim::ProcessEventTrigger
;	COMDAT xdata$x
; File c:\matrix games\dev\foundationex\text.h
xdata$x	SEGMENT
__unwindtable$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z$2
__ehfuncinfo$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z
_TEXT	SEGMENT
$T262321 = -48						; size = 8
$T262319 = -40						; size = 8
_ship_name$ = -32					; size = 8
_iter$ = -24						; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_type$ = 12						; size = 4
_event_id$ = 16						; size = 4
_ship$ = 20						; size = 4
_param$ = 24						; size = 4
?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z PROC		; Sim::ProcessEventTrigger, COMDAT

; 1858 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1859 : 	Text ship_name = ship;

  00028	8b 45 14	 mov	 eax, DWORD PTR _ship$[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d e0	 lea	 ecx, DWORD PTR _ship_name$[ebp]
  0002f	e8 00 00 00 00	 call	 ??0Text@@QAE@PBD@Z	; Text::Text

; 1860 : 
; 1861 : 	ListIter<MissionEvent> iter = events;

  00034	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H

; 1862 : 	while (++iter) {

  00044	8d 55 e8	 lea	 edx, DWORD PTR _iter$[ebp]
  00047	89 4d e8	 mov	 DWORD PTR _iter$[ebp], ecx
  0004a	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _iter$[ebp+4], -1
  00051	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::next
  00056	85 c0		 test	 eax, eax
  00058	0f 84 de 00 00
	00		 je	 $LN12@ProcessEve
$LN13@ProcessEve:

; 1863 : 		MissionEvent* event = iter.value();

  0005e	8d 45 e8	 lea	 eax, DWORD PTR _iter$[ebp]
  00061	e8 00 00 00 00	 call	 ?value@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::value
  00066	8b f8		 mov	 edi, eax

; 1864 : 
; 1865 : 		if (event->IsPending() && event->Trigger() == type) {

  00068	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  0006c	0f 85 ba 00 00
	00		 jne	 $LN1@ProcessEve
  00072	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  00075	39 87 98 00 00
	00		 cmp	 DWORD PTR [edi+152], eax
  0007b	0f 85 ab 00 00
	00		 jne	 $LN1@ProcessEve

; 1866 : 			switch (type) {

  00081	48		 dec	 eax
  00082	83 f8 08	 cmp	 eax, 8
  00085	0f 87 a1 00 00
	00		 ja	 $LN1@ProcessEve
  0008b	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN32@ProcessEve[eax]
  00092	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN38@ProcessEve[edx*4]
$LN8@ProcessEve:

; 1867 : 			case MissionEvent::TRIGGER_DAMAGE:
; 1868 : 			case MissionEvent::TRIGGER_DESTROYED:
; 1869 : 			case MissionEvent::TRIGGER_JUMP:
; 1870 : 			case MissionEvent::TRIGGER_LAUNCH:
; 1871 : 			case MissionEvent::TRIGGER_DOCK:
; 1872 : 			case MissionEvent::TRIGGER_TARGET:
; 1873 : 				if (event->TriggerParam() <= param) {

  00099	33 c9		 xor	 ecx, ecx
  0009b	8b d7		 mov	 edx, edi
  0009d	e8 00 00 00 00	 call	 ?TriggerParam@MissionEvent@@QBEHH@Z ; MissionEvent::TriggerParam
  000a2	3b 45 18	 cmp	 eax, DWORD PTR _param$[ebp]
  000a5	0f 8f 81 00 00
	00		 jg	 $LN1@ProcessEve

; 1874 : 					if (ship_name.indexOf(event->TriggerShip()) == 0)

  000ab	8d 75 d8	 lea	 esi, DWORD PTR $T262319[ebp]
  000ae	8b c7		 mov	 eax, edi
  000b0	e8 00 00 00 00	 call	 ?TriggerShip@MissionEvent@@QBE?AVText@@XZ ; MissionEvent::TriggerShip
  000b5	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000b9	8b 00		 mov	 eax, DWORD PTR [eax]
  000bb	50		 push	 eax
  000bc	8d 4d e0	 lea	 ecx, DWORD PTR _ship_name$[ebp]
  000bf	e8 00 00 00 00	 call	 ?indexOf@Text@@QBEHPBD@Z ; Text::indexOf
  000c4	85 c0		 test	 eax, eax
  000c6	8b ce		 mov	 ecx, esi
  000c8	0f 94 c3	 sete	 bl
  000cb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000cf	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  000d4	84 db		 test	 bl, bl
  000d6	74 54		 je	 SHORT $LN1@ProcessEve

; 1875 : 					event->Activate();
; 1876 : 				}
; 1877 : 				break;

  000d8	eb 4b		 jmp	 SHORT $LN37@ProcessEve
$LN5@ProcessEve:

; 1878 : 
; 1879 : 			case MissionEvent::TRIGGER_NAVPT:
; 1880 : 				if (event->TriggerParam() == param) {

  000da	33 c9		 xor	 ecx, ecx
  000dc	8b d7		 mov	 edx, edi
  000de	e8 00 00 00 00	 call	 ?TriggerParam@MissionEvent@@QBEHH@Z ; MissionEvent::TriggerParam
  000e3	3b 45 18	 cmp	 eax, DWORD PTR _param$[ebp]
  000e6	75 44		 jne	 SHORT $LN1@ProcessEve

; 1881 : 					if (ship_name.indexOf(event->TriggerShip()) == 0)

  000e8	8d 75 d0	 lea	 esi, DWORD PTR $T262321[ebp]
  000eb	8b c7		 mov	 eax, edi
  000ed	e8 00 00 00 00	 call	 ?TriggerShip@MissionEvent@@QBE?AVText@@XZ ; MissionEvent::TriggerShip
  000f2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f6	8b 00		 mov	 eax, DWORD PTR [eax]
  000f8	50		 push	 eax
  000f9	8d 4d e0	 lea	 ecx, DWORD PTR _ship_name$[ebp]
  000fc	e8 00 00 00 00	 call	 ?indexOf@Text@@QBEHPBD@Z ; Text::indexOf
  00101	85 c0		 test	 eax, eax
  00103	8b ce		 mov	 ecx, esi
  00105	0f 94 c3	 sete	 bl
  00108	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0010c	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  00111	84 db		 test	 bl, bl
  00113	74 17		 je	 SHORT $LN1@ProcessEve

; 1882 : 					event->Activate();
; 1883 : 				}
; 1884 : 				break;

  00115	eb 0e		 jmp	 SHORT $LN37@ProcessEve
$LN2@ProcessEve:

; 1885 : 
; 1886 : 			case MissionEvent::TRIGGER_EVENT:
; 1887 : 			case MissionEvent::TRIGGER_SKIPPED:
; 1888 : 				if (event->TriggerParam() == event_id)

  00117	33 c9		 xor	 ecx, ecx
  00119	8b d7		 mov	 edx, edi
  0011b	e8 00 00 00 00	 call	 ?TriggerParam@MissionEvent@@QBEHH@Z ; MissionEvent::TriggerParam
  00120	3b 45 10	 cmp	 eax, DWORD PTR _event_id$[ebp]
  00123	75 07		 jne	 SHORT $LN1@ProcessEve
$LN37@ProcessEve:

; 1889 : 				event->Activate();

  00125	8b cf		 mov	 ecx, edi
  00127	e8 00 00 00 00	 call	 ?Activate@MissionEvent@@QAEXXZ ; MissionEvent::Activate
$LN1@ProcessEve:

; 1862 : 	while (++iter) {

  0012c	8d 55 e8	 lea	 edx, DWORD PTR _iter$[ebp]
  0012f	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::next
  00134	85 c0		 test	 eax, eax
  00136	0f 85 22 ff ff
	ff		 jne	 $LN13@ProcessEve
$LN12@ProcessEve:

; 1890 : 				break;
; 1891 : 			}
; 1892 : 		}
; 1893 : 	}
; 1894 : }

  0013c	8d 4d e0	 lea	 ecx, DWORD PTR _ship_name$[ebp]
  0013f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00146	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  0014b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00155	59		 pop	 ecx
  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 14 00	 ret	 20			; 00000014H
  0015f	90		 npad	 1
$LN38@ProcessEve:
  00160	00 00 00 00	 DD	 $LN8@ProcessEve
  00164	00 00 00 00	 DD	 $LN5@ProcessEve
  00168	00 00 00 00	 DD	 $LN2@ProcessEve
$LN32@ProcessEve:
  0016c	00		 DB	 0
  0016d	00		 DB	 0
  0016e	00		 DB	 0
  0016f	00		 DB	 0
  00170	00		 DB	 0
  00171	01		 DB	 1
  00172	02		 DB	 2
  00173	02		 DB	 2
  00174	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _ship_name$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T262319[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z$2:
  00010	8d 4d d0	 lea	 ecx, DWORD PTR $T262321[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__ehhandler$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z ENDP		; Sim::ProcessEventTrigger
PUBLIC	?FindNearestSpaceRegion@Sim@@QAEPAVSimRegion@@PAVOrbital@@@Z ; Sim::FindNearestSpaceRegion
; Function compile flags: /Ogtp
;	COMDAT ?FindNearestSpaceRegion@Sim@@QAEPAVSimRegion@@PAVOrbital@@@Z
_TEXT	SEGMENT
_iter$119648 = -16					; size = 8
_rgn$ = -8						; size = 8
_this$ = 8						; size = 4
_body$ = 12						; size = 4
?FindNearestSpaceRegion@Sim@@QAEPAVSimRegion@@PAVOrbital@@@Z PROC ; Sim::FindNearestSpaceRegion, COMDAT

; 1419 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	53		 push	 ebx

; 1420 : 	SimRegion*  result   = 0;

  0000a	33 db		 xor	 ebx, ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 1421 : 
; 1422 : 	if (!body)

  0000e	39 5d 0c	 cmp	 DWORD PTR _body$[ebp], ebx
  00011	75 0b		 jne	 SHORT $LN8@FindNeares

; 1423 : 	return result;

  00013	33 c0		 xor	 eax, eax

; 1434 : 				}
; 1435 : 			}
; 1436 : 		}
; 1437 : 	}
; 1438 : 	
; 1439 : 	return result;
; 1440 : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
$LN8@FindNeares:

; 1424 : 
; 1425 : 	ListIter<SimRegion> rgn = regions;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c0 58	 add	 eax, 88			; 00000058H

; 1426 : 	while (++rgn && !result) {

  00024	8d 54 24 18	 lea	 edx, DWORD PTR _rgn$[esp+32]
  00028	89 44 24 18	 mov	 DWORD PTR _rgn$[esp+32], eax
  0002c	c7 44 24 1c ff
	ff ff ff	 mov	 DWORD PTR _rgn$[esp+36], -1
  00034	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00039	85 c0		 test	 eax, eax
  0003b	74 6b		 je	 SHORT $LN6@FindNeares
$LN7@FindNeares:
  0003d	85 db		 test	 ebx, ebx
  0003f	75 67		 jne	 SHORT $LN6@FindNeares

; 1427 : 		if (rgn->IsOrbital()) {

  00041	8d 44 24 18	 lea	 eax, DWORD PTR _rgn$[esp+32]
  00045	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  0004a	8b f0		 mov	 esi, eax
  0004c	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  0004f	75 4a		 jne	 SHORT $LN2@FindNeares

; 1428 : 			OrbitalRegion* orgn = rgn->GetOrbitalRegion();

  00051	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]

; 1429 : 			if (orgn) {

  00054	85 ff		 test	 edi, edi
  00056	74 43		 je	 SHORT $LN2@FindNeares

; 1430 : 				ListIter<OrbitalRegion> iter = body->Regions();

  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _body$[ebp]
  0005b	81 c1 f0 00 00
	00		 add	 ecx, 240		; 000000f0H

; 1431 : 				while (++iter) {

  00061	8d 54 24 10	 lea	 edx, DWORD PTR _iter$119648[esp+32]
  00065	89 4c 24 10	 mov	 DWORD PTR _iter$119648[esp+32], ecx
  00069	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _iter$119648[esp+36], -1
  00071	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::next
  00076	85 c0		 test	 eax, eax
  00078	74 21		 je	 SHORT $LN2@FindNeares
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL3@FindNeares:

; 1432 : 					if (iter.value() == orgn)

  00080	8d 44 24 10	 lea	 eax, DWORD PTR _iter$119648[esp+32]
  00084	e8 00 00 00 00	 call	 ?value@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::value
  00089	3b c7		 cmp	 eax, edi
  0008b	8d 54 24 10	 lea	 edx, DWORD PTR _iter$119648[esp+32]

; 1433 : 					result = rgn.value();

  0008f	0f 44 de	 cmove	 ebx, esi
  00092	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::next
  00097	85 c0		 test	 eax, eax
  00099	75 e5		 jne	 SHORT $LL3@FindNeares
$LN2@FindNeares:

; 1426 : 	while (++rgn && !result) {

  0009b	8d 54 24 18	 lea	 edx, DWORD PTR _rgn$[esp+32]
  0009f	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  000a4	85 c0		 test	 eax, eax
  000a6	75 95		 jne	 SHORT $LN7@FindNeares
$LN6@FindNeares:

; 1434 : 				}
; 1435 : 			}
; 1436 : 		}
; 1437 : 	}
; 1438 : 	
; 1439 : 	return result;
; 1440 : }

  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	8b c3		 mov	 eax, ebx
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8
?FindNearestSpaceRegion@Sim@@QAEPAVSimRegion@@PAVOrbital@@@Z ENDP ; Sim::FindNearestSpaceRegion
_TEXT	ENDS
PUBLIC	?FindRegion@Sim@@QAEPAVSimRegion@@PAVOrbitalRegion@@@Z ; Sim::FindRegion
; Function compile flags: /Ogtp
;	COMDAT ?FindRegion@Sim@@QAEPAVSimRegion@@PAVOrbitalRegion@@@Z
_TEXT	SEGMENT
_rgn$ = -8						; size = 8
?FindRegion@Sim@@QAEPAVSimRegion@@PAVOrbitalRegion@@@Z PROC ; Sim::FindRegion, COMDAT
; _this$ = eax
; _orgn$ = esi

; 1363 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1364 : 	ListIter<SimRegion> rgn = regions;

  00006	83 c0 58	 add	 eax, 88			; 00000058H

; 1365 : 	while (++rgn)

  00009	8d 55 f8	 lea	 edx, DWORD PTR _rgn$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _rgn$[ebp], eax
  0000f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _rgn$[ebp+4], -1
  00016	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  0001b	85 c0		 test	 eax, eax
  0001d	74 1a		 je	 SHORT $LN2@FindRegion
  0001f	90		 npad	 1
$LL3@FindRegion:

; 1366 : 	if (rgn->orbital_region == orgn)

  00020	8d 45 f8	 lea	 eax, DWORD PTR _rgn$[ebp]
  00023	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  00028	39 70 1c	 cmp	 DWORD PTR [eax+28], esi
  0002b	74 12		 je	 SHORT $LN13@FindRegion

; 1365 : 	while (++rgn)

  0002d	8d 55 f8	 lea	 edx, DWORD PTR _rgn$[ebp]
  00030	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00035	85 c0		 test	 eax, eax
  00037	75 e7		 jne	 SHORT $LL3@FindRegion
$LN2@FindRegion:

; 1368 : 
; 1369 : 	return 0;

  00039	33 c0		 xor	 eax, eax

; 1370 : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN13@FindRegion:

; 1367 : 	return rgn.value();

  0003f	8d 45 f8	 lea	 eax, DWORD PTR _rgn$[ebp]
  00042	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value

; 1370 : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?FindRegion@Sim@@QAEPAVSimRegion@@PAVOrbitalRegion@@@Z ENDP ; Sim::FindRegion
_TEXT	ENDS
PUBLIC	?ClearSelection@Sim@@QAEXXZ			; Sim::ClearSelection
; Function compile flags: /Ogtp
;	COMDAT ?ClearSelection@Sim@@QAEXXZ
_TEXT	SEGMENT
?ClearSelection@Sim@@QAEXXZ PROC			; Sim::ClearSelection, COMDAT
; _this$ = eax

; 1315 : 	if (active_region)

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	85 c0		 test	 eax, eax
  00005	74 05		 je	 SHORT $LN1@ClearSelec

; 1316 : 	active_region->ClearSelection();

  00007	e9 00 00 00 00	 jmp	 ?ClearSelection@SimRegion@@QAEXXZ ; SimRegion::ClearSelection
$LN1@ClearSelec:

; 1317 : }

  0000c	c3		 ret	 0
?ClearSelection@Sim@@QAEXXZ ENDP			; Sim::ClearSelection
_TEXT	ENDS
PUBLIC	?GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ	; Sim::GetSelection
;	COMDAT ?empty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4V?$List@VShip@@@@A
; File c:\matrix games\dev\foundationex\list.h
_BSS	SEGMENT
?empty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4V?$List@VShip@@@@A DB 0cH DUP (?) ; `Sim::GetSelection'::`4'::empty
_BSS	ENDS
;	COMDAT ?$S2@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4IA
_BSS	SEGMENT
?$S2@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4IA DD 01H DUP (?) ; `Sim::GetSelection'::`4'::$S2
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
_BSS	ENDS
;	COMDAT ?GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ
_TEXT	SEGMENT
?GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ PROC	; Sim::GetSelection, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 1305 : 	if (active_region)

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	33 c0		 xor	 eax, eax
  00005	3b c8		 cmp	 ecx, eax
  00007	74 08		 je	 SHORT $LN2@GetSelecti

; 1306 : 	return active_region->GetSelection();

  00009	8b c6		 mov	 eax, esi
  0000b	e8 00 00 00 00	 call	 ?GetSelection@SimRegion@@QAE?AV?$ListIter@VShip@@@@XZ ; SimRegion::GetSelection

; 1310 : }

  00010	c3		 ret	 0
$LN2@GetSelecti:

; 1307 : 
; 1308 : 	static List<Ship> empty;

  00011	b9 01 00 00 00	 mov	 ecx, 1
  00016	84 0d 00 00 00
	00		 test	 BYTE PTR ?$S2@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4IA, cl
  0001c	75 22		 jne	 SHORT $LN1@GetSelecti
  0001e	09 0d 00 00 00
	00		 or	 DWORD PTR ?$S2@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4IA, ecx
  00024	68 00 00 00 00	 push	 OFFSET ??__Fempty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@YAXXZ ; `Sim::GetSelection'::`4'::`dynamic atexit destructor for 'empty''
  00029	a3 00 00 00 00	 mov	 DWORD PTR ?empty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4V?$List@VShip@@@@A, eax
  0002e	a3 04 00 00 00	 mov	 DWORD PTR ?empty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4V?$List@VShip@@@@A+4, eax
  00033	a3 08 00 00 00	 mov	 DWORD PTR ?empty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4V?$List@VShip@@@@A+8, eax
  00038	e8 00 00 00 00	 call	 _atexit
  0003d	83 c4 04	 add	 esp, 4
$LN1@GetSelecti:

; 1309 : 	return empty;

  00040	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ?empty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4V?$List@VShip@@@@A
  00046	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
  0004d	8b c6		 mov	 eax, esi

; 1310 : }

  0004f	c3		 ret	 0
?GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ ENDP	; Sim::GetSelection
_TEXT	ENDS
PUBLIC	?GetPlayerElement@Sim@@QAEPAVElement@@XZ	; Sim::GetPlayerElement
; Function compile flags: /Ogtp
;	COMDAT ?GetPlayerElement@Sim@@QAEPAVElement@@XZ
_TEXT	SEGMENT
?GetPlayerElement@Sim@@QAEPAVElement@@XZ PROC		; Sim::GetPlayerElement, COMDAT
; _this$ = eax

; 1280 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 1281 : 	Element* elem = 0;

  00003	33 db		 xor	 ebx, ebx

; 1282 : 
; 1283 : 	for (int i = 0; i < elements.size(); i++) {

  00005	8b f8		 mov	 edi, eax
  00007	33 f6		 xor	 esi, esi
  00009	39 9f 88 00 00
	00		 cmp	 DWORD PTR [edi+136], ebx
  0000f	7e 1e		 jle	 SHORT $LN13@GetPlayerE
$LL4@GetPlayerE:

; 1284 : 		Element* e = elements[i];

  00011	56		 push	 esi
  00012	8d 87 88 00 00
	00		 lea	 eax, DWORD PTR [edi+136]
  00018	e8 00 00 00 00	 call	 ??A?$List@VElement@@@@QAEAAPAVElement@@H@Z ; List<Element>::operator[]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]

; 1285 : 
; 1286 : 		if (e->Player() > 0)

  0001f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0

; 1287 : 		elem = e;

  00023	0f 4f d8	 cmovg	 ebx, eax
  00026	46		 inc	 esi
  00027	3b b7 88 00 00
	00		 cmp	 esi, DWORD PTR [edi+136]
  0002d	7c e2		 jl	 SHORT $LL4@GetPlayerE
$LN13@GetPlayerE:
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 1288 : 	}
; 1289 : 
; 1290 : 	return elem;

  00031	8b c3		 mov	 eax, ebx
  00033	5b		 pop	 ebx

; 1291 : }

  00034	c3		 ret	 0
?GetPlayerElement@Sim@@QAEPAVElement@@XZ ENDP		; Sim::GetPlayerElement
_TEXT	ENDS
PUBLIC	?GetPlayerShip@Sim@@QAEPAVShip@@XZ		; Sim::GetPlayerShip
; Function compile flags: /Ogtp
;	COMDAT ?GetPlayerShip@Sim@@QAEPAVShip@@XZ
_TEXT	SEGMENT
_rgn$119492 = -8					; size = 8
?GetPlayerShip@Sim@@QAEPAVShip@@XZ PROC			; Sim::GetPlayerShip, COMDAT
; _this$ = ecx

; 1259 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 1260 : 	if (active_region)

  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000c	56		 push	 esi
  0000d	85 c0		 test	 eax, eax
  0000f	74 08		 je	 SHORT $LN4@GetPlayerS

; 1261 : 	return active_region->GetPlayerShip();

  00011	8b 40 44	 mov	 eax, DWORD PTR [eax+68]

; 1276 : }

  00014	5e		 pop	 esi
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN4@GetPlayerS:

; 1262 : 
; 1263 : 	Starshatter* stars = Starshatter::GetInstance();

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@Starshatter@@1PAV1@A ; Starshatter::instance

; 1264 : 	if (stars && stars->InCutscene()) {

  0001e	85 c0		 test	 eax, eax
  00020	74 52		 je	 SHORT $LN3@GetPlayerS
  00022	83 b8 0c a6 00
	00 00		 cmp	 DWORD PTR [eax+42508], 0
  00029	7e 49		 jle	 SHORT $LN3@GetPlayerS

; 1265 : 		Ship* player = 0;
; 1266 : 
; 1267 : 		ListIter<SimRegion> rgn = regions;

  0002b	83 c1 58	 add	 ecx, 88			; 00000058H

; 1268 : 		while (++rgn && !player) {

  0002e	8d 54 24 08	 lea	 edx, DWORD PTR _rgn$119492[esp+16]
  00032	33 f6		 xor	 esi, esi
  00034	89 4c 24 08	 mov	 DWORD PTR _rgn$119492[esp+16], ecx
  00038	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _rgn$119492[esp+20], -1
  00040	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00045	85 c0		 test	 eax, eax
  00047	74 24		 je	 SHORT $LN1@GetPlayerS
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL2@GetPlayerS:
  00050	85 f6		 test	 esi, esi
  00052	75 19		 jne	 SHORT $LN1@GetPlayerS

; 1269 : 			player = rgn->GetPlayerShip();

  00054	8d 44 24 08	 lea	 eax, DWORD PTR _rgn$119492[esp+16]
  00058	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  0005d	8b 70 44	 mov	 esi, DWORD PTR [eax+68]
  00060	8d 54 24 08	 lea	 edx, DWORD PTR _rgn$119492[esp+16]
  00064	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00069	85 c0		 test	 eax, eax
  0006b	75 e3		 jne	 SHORT $LL2@GetPlayerS
$LN1@GetPlayerS:

; 1270 : 		}
; 1271 : 
; 1272 : 		return player;

  0006d	8b c6		 mov	 eax, esi

; 1276 : }

  0006f	5e		 pop	 esi
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN3@GetPlayerS:

; 1273 : 	}
; 1274 : 
; 1275 : 	return 0;

  00074	33 c0		 xor	 eax, eax

; 1276 : }

  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?GetPlayerShip@Sim@@QAEPAVShip@@XZ ENDP			; Sim::GetPlayerShip
_TEXT	ENDS
PUBLIC	?GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ ; Sim::GetSystemList
;	COMDAT ?dummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4V3@A
; File c:\matrix games\dev\foundationex\list.h
_BSS	SEGMENT
?dummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4V3@A DB 0cH DUP (?) ; `Sim::GetSystemList'::`4'::dummy_system_list
_BSS	ENDS
;	COMDAT ?$S1@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4IA
_BSS	SEGMENT
?$S1@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4IA DD 01H DUP (?) ; `Sim::GetSystemList'::`4'::$S1
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
_BSS	ENDS
;	COMDAT ?GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ
_TEXT	SEGMENT
?GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ PROC	; Sim::GetSystemList, COMDAT
; _this$ = eax

; 1241 : 	if (mission)

  00000	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [eax+192]
  00006	33 c9		 xor	 ecx, ecx
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 06		 je	 SHORT $LN2@GetSystemL

; 1242 : 	return mission->GetSystemList();

  0000c	05 e0 00 00 00	 add	 eax, 224		; 000000e0H

; 1246 : }

  00011	c3		 ret	 0
$LN2@GetSystemL:

; 1243 : 
; 1244 : 	static List<StarSystem> dummy_system_list;

  00012	b8 01 00 00 00	 mov	 eax, 1
  00017	84 05 00 00 00
	00		 test	 BYTE PTR ?$S1@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4IA, al
  0001d	75 25		 jne	 SHORT $LN1@GetSystemL
  0001f	09 05 00 00 00
	00		 or	 DWORD PTR ?$S1@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4IA, eax
  00025	68 00 00 00 00	 push	 OFFSET ??__Fdummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@YAXXZ ; `Sim::GetSystemList'::`4'::`dynamic atexit destructor for 'dummy_system_list''
  0002a	89 0d 00 00 00
	00		 mov	 DWORD PTR ?dummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4V3@A, ecx
  00030	89 0d 04 00 00
	00		 mov	 DWORD PTR ?dummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4V3@A+4, ecx
  00036	89 0d 08 00 00
	00		 mov	 DWORD PTR ?dummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4V3@A+8, ecx
  0003c	e8 00 00 00 00	 call	 _atexit
  00041	83 c4 04	 add	 esp, 4
$LN1@GetSystemL:

; 1245 : 	return dummy_system_list;

  00044	b8 00 00 00 00	 mov	 eax, OFFSET ?dummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4V3@A

; 1246 : }

  00049	c3		 ret	 0
?GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ ENDP	; Sim::GetSystemList
_TEXT	ENDS
PUBLIC	?ShowGrid@Sim@@QAEXH@Z				; Sim::ShowGrid
; Function compile flags: /Ogtp
;	COMDAT ?ShowGrid@Sim@@QAEXH@Z
_TEXT	SEGMENT
_rgn$ = -8						; size = 8
?ShowGrid@Sim@@QAEXH@Z PROC				; Sim::ShowGrid, COMDAT
; _this$ = edi
; _show$ = eax

; 1214 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	56		 push	 esi
  0000a	8b f0		 mov	 esi, eax

; 1215 : 	Player* player = Player::GetCurrentPlayer();

  0000c	e8 00 00 00 00	 call	 ?GetCurrentPlayer@Player@@SAPAV1@XZ ; Player::GetCurrentPlayer

; 1216 : 
; 1217 : 	if (player && player->GridMode() == 0) {

  00011	85 c0		 test	 eax, eax
  00013	74 12		 je	 SHORT $LN3@ShowGrid@2
  00015	83 b8 c8 00 00
	00 00		 cmp	 DWORD PTR [eax+200], 0
  0001c	75 09		 jne	 SHORT $LN3@ShowGrid@2

; 1218 : 		show       = 0;

  0001e	33 f6		 xor	 esi, esi

; 1219 : 		grid_shown = false;

  00020	c6 87 bd 00 00
	00 00		 mov	 BYTE PTR [edi+189], 0
$LN3@ShowGrid@2:

; 1220 : 	}
; 1221 : 
; 1222 : 	ListIter<SimRegion> rgn = regions;

  00027	8d 47 58	 lea	 eax, DWORD PTR [edi+88]

; 1223 : 	while (++rgn) {

  0002a	8d 54 24 08	 lea	 edx, DWORD PTR _rgn$[esp+16]
  0002e	89 44 24 08	 mov	 DWORD PTR _rgn$[esp+16], eax
  00032	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _rgn$[esp+20], -1
  0003a	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  0003f	85 c0		 test	 eax, eax
  00041	74 1c		 je	 SHORT $LN1@ShowGrid@2
$LL2@ShowGrid@2:

; 1224 : 		rgn->ShowGrid(show);

  00043	56		 push	 esi
  00044	8d 44 24 0c	 lea	 eax, DWORD PTR _rgn$[esp+20]
  00048	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  0004d	e8 00 00 00 00	 call	 ?ShowGrid@SimRegion@@QAEXH@Z ; SimRegion::ShowGrid
  00052	8d 54 24 08	 lea	 edx, DWORD PTR _rgn$[esp+16]
  00056	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  0005b	85 c0		 test	 eax, eax
  0005d	75 e4		 jne	 SHORT $LL2@ShowGrid@2
$LN1@ShowGrid@2:

; 1225 : 	}
; 1226 : 
; 1227 : 	grid_shown = show?true:false;

  0005f	85 f6		 test	 esi, esi
  00061	0f 95 c1	 setne	 cl
  00064	88 8f bd 00 00
	00		 mov	 BYTE PTR [edi+189], cl

; 1228 : }

  0006a	5e		 pop	 esi
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?ShowGrid@Sim@@QAEXH@Z ENDP				; Sim::ShowGrid
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?FindShotByObjID@Sim@@UAEPAVShot@@K@Z
_TEXT	SEGMENT
_rgn$ = -8						; size = 8
_objid$ = 8						; size = 4
?FindShotByObjID@Sim@@UAEPAVShot@@K@Z PROC		; Sim::FindShotByObjID, COMDAT
; _this$ = ecx

; 1065 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi

; 1066 : 	Shot* shot = 0;
; 1067 : 
; 1068 : 	ListIter<SimRegion> rgn = regions;

  0000a	83 c1 58	 add	 ecx, 88			; 00000058H
  0000d	57		 push	 edi

; 1069 : 	while (++rgn && !shot)

  0000e	8d 54 24 08	 lea	 edx, DWORD PTR _rgn$[esp+16]
  00012	33 f6		 xor	 esi, esi
  00014	89 4c 24 08	 mov	 DWORD PTR _rgn$[esp+16], ecx
  00018	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _rgn$[esp+20], -1
  00020	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00025	85 c0		 test	 eax, eax
  00027	74 2d		 je	 SHORT $LN14@FindShotBy@2
  00029	8b 7d 08	 mov	 edi, DWORD PTR _objid$[ebp]
  0002c	8d 64 24 00	 npad	 4
$LL2@FindShotBy@2:
  00030	85 f6		 test	 esi, esi
  00032	75 22		 jne	 SHORT $LN14@FindShotBy@2

; 1070 : 	shot = rgn->FindShotByObjID(objid);

  00034	8d 44 24 08	 lea	 eax, DWORD PTR _rgn$[esp+16]
  00038	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  0003d	8b 10		 mov	 edx, DWORD PTR [eax]
  0003f	8b c8		 mov	 ecx, eax
  00041	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00044	57		 push	 edi
  00045	ff d0		 call	 eax
  00047	8d 54 24 08	 lea	 edx, DWORD PTR _rgn$[esp+16]
  0004b	8b f0		 mov	 esi, eax
  0004d	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00052	85 c0		 test	 eax, eax
  00054	75 da		 jne	 SHORT $LL2@FindShotBy@2
$LN14@FindShotBy@2:

; 1071 : 
; 1072 : 	return shot;
; 1073 : }

  00056	5f		 pop	 edi
  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?FindShotByObjID@Sim@@UAEPAVShot@@K@Z ENDP		; Sim::FindShotByObjID
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?FindShipByObjID@Sim@@UAEPAVShip@@K@Z
_TEXT	SEGMENT
_rgn$ = -8						; size = 8
_objid$ = 8						; size = 4
?FindShipByObjID@Sim@@UAEPAVShip@@K@Z PROC		; Sim::FindShipByObjID, COMDAT
; _this$ = ecx

; 1053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi

; 1054 : 	Ship* ship = 0;
; 1055 : 
; 1056 : 	ListIter<SimRegion> rgn = regions;

  0000a	83 c1 58	 add	 ecx, 88			; 00000058H
  0000d	57		 push	 edi

; 1057 : 	while (++rgn && !ship)

  0000e	8d 54 24 08	 lea	 edx, DWORD PTR _rgn$[esp+16]
  00012	33 f6		 xor	 esi, esi
  00014	89 4c 24 08	 mov	 DWORD PTR _rgn$[esp+16], ecx
  00018	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _rgn$[esp+20], -1
  00020	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00025	85 c0		 test	 eax, eax
  00027	74 2d		 je	 SHORT $LN14@FindShipBy@2
  00029	8b 7d 08	 mov	 edi, DWORD PTR _objid$[ebp]
  0002c	8d 64 24 00	 npad	 4
$LL2@FindShipBy@2:
  00030	85 f6		 test	 esi, esi
  00032	75 22		 jne	 SHORT $LN14@FindShipBy@2

; 1058 : 	ship = rgn->FindShipByObjID(objid);

  00034	8d 44 24 08	 lea	 eax, DWORD PTR _rgn$[esp+16]
  00038	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  0003d	8b 10		 mov	 edx, DWORD PTR [eax]
  0003f	8b c8		 mov	 ecx, eax
  00041	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00044	57		 push	 edi
  00045	ff d0		 call	 eax
  00047	8d 54 24 08	 lea	 edx, DWORD PTR _rgn$[esp+16]
  0004b	8b f0		 mov	 esi, eax
  0004d	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00052	85 c0		 test	 eax, eax
  00054	75 da		 jne	 SHORT $LL2@FindShipBy@2
$LN14@FindShipBy@2:

; 1059 : 
; 1060 : 	return ship;
; 1061 : }

  00056	5f		 pop	 edi
  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?FindShipByObjID@Sim@@UAEPAVShip@@K@Z ENDP		; Sim::FindShipByObjID
_TEXT	ENDS
PUBLIC	?GetAssignedElements@Sim@@QAEHPAVElement@@AAV?$List@VElement@@@@@Z ; Sim::GetAssignedElements
; Function compile flags: /Ogtp
;	COMDAT ?GetAssignedElements@Sim@@QAEHPAVElement@@AAV?$List@VElement@@@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_elem$ = 12						; size = 4
_assigned$ = 16						; size = 4
?GetAssignedElements@Sim@@QAEHPAVElement@@AAV?$List@VElement@@@@@Z PROC ; Sim::GetAssignedElements, COMDAT

; 971  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 972  : 	assigned.clear();

  00005	8b 7d 10	 mov	 edi, DWORD PTR _assigned$[ebp]
  00008	8b f7		 mov	 esi, edi
  0000a	e8 00 00 00 00	 call	 ?clear@?$List@VElement@@@@QAEXXZ ; List<Element>::clear

; 973  : 
; 974  : 	if (elem) {

  0000f	83 7d 0c 00	 cmp	 DWORD PTR _elem$[ebp], 0
  00013	74 4c		 je	 SHORT $LN17@GetAssigne

; 975  : 		for (int i = 0; i < elements.size(); i++) {

  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00019	33 f6		 xor	 esi, esi
  0001b	39 b3 88 00 00
	00		 cmp	 DWORD PTR [ebx+136], esi
  00021	7e 35		 jle	 SHORT $LN16@GetAssigne
$LL4@GetAssigne:

; 976  : 			Element* e = elements.at(i);

  00023	56		 push	 esi
  00024	8d 83 88 00 00
	00		 lea	 eax, DWORD PTR [ebx+136]
  0002a	e8 00 00 00 00	 call	 ?at@?$List@VElement@@@@QAEAAPAVElement@@H@Z ; List<Element>::at
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]

; 977  : 			if (!e->IsSquadron() && e->GetAssignment() == elem)

  00031	e8 00 00 00 00	 call	 ?IsSquadron@Element@@QBE_NXZ ; Element::IsSquadron
  00036	84 c0		 test	 al, al
  00038	75 15		 jne	 SHORT $LN3@GetAssigne
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _elem$[ebp]
  0003d	39 41 78	 cmp	 DWORD PTR [ecx+120], eax
  00040	75 0d		 jne	 SHORT $LN3@GetAssigne

; 978  : 			assigned.append(e);

  00042	8b 45 10	 mov	 eax, DWORD PTR _assigned$[ebp]
  00045	8b f9		 mov	 edi, ecx
  00047	e8 00 00 00 00	 call	 ?append@?$List@VElement@@@@QAEXPBVElement@@@Z ; List<Element>::append
  0004c	8b 7d 10	 mov	 edi, DWORD PTR _assigned$[ebp]
$LN3@GetAssigne:

; 975  : 		for (int i = 0; i < elements.size(); i++) {

  0004f	46		 inc	 esi
  00050	3b b3 88 00 00
	00		 cmp	 esi, DWORD PTR [ebx+136]
  00056	7c cb		 jl	 SHORT $LL4@GetAssigne
$LN16@GetAssigne:

; 979  : 		}
; 980  : 	}
; 981  : 
; 982  : 	return assigned.size();

  00058	8b 07		 mov	 eax, DWORD PTR [edi]
  0005a	5b		 pop	 ebx
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 983  : }

  0005d	5d		 pop	 ebp
  0005e	c2 0c 00	 ret	 12			; 0000000cH
$LN17@GetAssigne:

; 979  : 		}
; 980  : 	}
; 981  : 
; 982  : 	return assigned.size();

  00061	8b 07		 mov	 eax, DWORD PTR [edi]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi

; 983  : }

  00065	5d		 pop	 ebp
  00066	c2 0c 00	 ret	 12			; 0000000cH
?GetAssignedElements@Sim@@QAEHPAVElement@@AAV?$List@VElement@@@@@Z ENDP ; Sim::GetAssignedElements
_TEXT	ENDS
PUBLIC	?CopyEvents@Sim@@IAEXXZ				; Sim::CopyEvents
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CopyEvents@Sim@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$6
__ehfuncinfo$?CopyEvents@Sim@@IAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?CopyEvents@Sim@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?CopyEvents@Sim@@IAEXXZ
_TEXT	SEGMENT
_iter$119120 = -32					; size = 8
$T262544 = -24						; size = 4
tv320 = -20						; size = 4
_orig$119124 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?CopyEvents@Sim@@IAEXXZ PROC				; Sim::CopyEvents, COMDAT
; _this$ = ecx

; 904  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CopyEvents@Sim@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 905  : 	events.destroy();

  0002a	8d b7 a0 00 00
	00		 lea	 esi, DWORD PTR [edi+160]
  00030	89 75 ec	 mov	 DWORD PTR tv320[ebp], esi
  00033	e8 00 00 00 00	 call	 ?destroy@?$List@VMissionEvent@@@@QAEXXZ ; List<MissionEvent>::destroy

; 906  : 
; 907  : 	if (mission) {

  00038	8b 87 c0 00 00
	00		 mov	 eax, DWORD PTR [edi+192]
  0003e	85 c0		 test	 eax, eax
  00040	0f 84 a4 02 00
	00		 je	 $LN1@CopyEvents

; 908  : 		ListIter<MissionEvent> iter = mission->GetEvents();

  00046	05 f8 00 00 00	 add	 eax, 248		; 000000f8H

; 909  : 		while (++iter) {

  0004b	8d 55 e0	 lea	 edx, DWORD PTR _iter$119120[ebp]
  0004e	89 45 e0	 mov	 DWORD PTR _iter$119120[ebp], eax
  00051	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _iter$119120[ebp+4], -1
  00058	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::next
  0005d	85 c0		 test	 eax, eax
  0005f	0f 84 85 02 00
	00		 je	 $LN1@CopyEvents
$LN2@CopyEvents:

; 910  : 			MissionEvent* orig = iter.value();

  00065	8d 45 e0	 lea	 eax, DWORD PTR _iter$119120[ebp]
  00068	e8 00 00 00 00	 call	 ?value@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::value
  0006d	8b f0		 mov	 esi, eax

; 911  : 			MissionEvent* event = new(__FILE__,__LINE__) MissionEvent(*orig);

  0006f	68 48 01 00 00	 push	 328			; 00000148H
  00074	89 75 f0	 mov	 DWORD PTR _orig$119124[ebp], esi
  00077	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007c	8b d8		 mov	 ebx, eax
  0007e	83 c4 04	 add	 esp, 4
  00081	89 5d e8	 mov	 DWORD PTR $T262544[ebp], ebx
  00084	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008b	85 db		 test	 ebx, ebx
  0008d	0f 84 34 02 00
	00		 je	 $LN6@CopyEvents
  00093	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7MissionEvent@@6B@
  00099	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009c	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0009f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000a2	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  000a5	dd 46 10	 fld	 QWORD PTR [esi+16]
  000a8	dd 5b 10	 fstp	 QWORD PTR [ebx+16]
  000ab	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  000ae	dd 46 18	 fld	 QWORD PTR [esi+24]
  000b1	50		 push	 eax
  000b2	dd 5b 18	 fstp	 QWORD PTR [ebx+24]
  000b5	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  000b8	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  000bb	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  000be	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  000c3	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  000c6	51		 push	 ecx
  000c7	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  000ca	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ce	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  000d3	8d 56 34	 lea	 edx, DWORD PTR [esi+52]
  000d6	52		 push	 edx
  000d7	8d 4b 34	 lea	 ecx, DWORD PTR [ebx+52]
  000da	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000de	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  000e3	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  000e6	50		 push	 eax
  000e7	8d 4b 3c	 lea	 ecx, DWORD PTR [ebx+60]
  000ea	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000ee	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  000f3	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  000f6	51		 push	 ecx
  000f7	8d 4b 44	 lea	 ecx, DWORD PTR [ebx+68]
  000fa	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000fe	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  00103	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00107	f3 0f 7e 46 4c	 movq	 xmm0, QWORD PTR [esi+76]
  0010c	66 0f d6 43 4c	 movq	 QWORD PTR [ebx+76], xmm0
  00111	f3 0f 7e 46 54	 movq	 xmm0, QWORD PTR [esi+84]
  00116	66 0f d6 43 54	 movq	 QWORD PTR [ebx+84], xmm0
  0011b	f3 0f 7e 46 5c	 movq	 xmm0, QWORD PTR [esi+92]
  00120	66 0f d6 43 5c	 movq	 QWORD PTR [ebx+92], xmm0
  00125	f3 0f 7e 46 64	 movq	 xmm0, QWORD PTR [esi+100]
  0012a	66 0f d6 43 64	 movq	 QWORD PTR [ebx+100], xmm0
  0012f	f3 0f 7e 46 6c	 movq	 xmm0, QWORD PTR [esi+108]
  00134	66 0f d6 43 6c	 movq	 QWORD PTR [ebx+108], xmm0
  00139	8b 56 74	 mov	 edx, DWORD PTR [esi+116]
  0013c	89 53 74	 mov	 DWORD PTR [ebx+116], edx
  0013f	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  00142	89 43 78	 mov	 DWORD PTR [ebx+120], eax
  00145	f3 0f 7e 46 7c	 movq	 xmm0, QWORD PTR [esi+124]
  0014a	66 0f d6 43 7c	 movq	 QWORD PTR [ebx+124], xmm0
  0014f	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  00155	89 8b 84 00 00
	00		 mov	 DWORD PTR [ebx+132], ecx
  0015b	f3 0f 7e 86 88
	00 00 00	 movq	 xmm0, QWORD PTR [esi+136]
  00163	66 0f d6 83 88
	00 00 00	 movq	 QWORD PTR [ebx+136], xmm0
  0016b	f3 0f 7e 86 90
	00 00 00	 movq	 xmm0, QWORD PTR [esi+144]
  00173	66 0f d6 83 90
	00 00 00	 movq	 QWORD PTR [ebx+144], xmm0
  0017b	8b 96 98 00 00
	00		 mov	 edx, DWORD PTR [esi+152]
  00181	8d 86 9c 00 00
	00		 lea	 eax, DWORD PTR [esi+156]
  00187	50		 push	 eax
  00188	8d 8b 9c 00 00
	00		 lea	 ecx, DWORD PTR [ebx+156]
  0018e	89 93 98 00 00
	00		 mov	 DWORD PTR [ebx+152], edx
  00194	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  00199	8d 8e a4 00 00
	00		 lea	 ecx, DWORD PTR [esi+164]
  0019f	51		 push	 ecx
  001a0	8d 8b a4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+164]
  001a6	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  001aa	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  001af	f3 0f 7e 86 ac
	00 00 00	 movq	 xmm0, QWORD PTR [esi+172]
  001b7	66 0f d6 83 ac
	00 00 00	 movq	 QWORD PTR [ebx+172], xmm0
  001bf	f3 0f 7e 86 b4
	00 00 00	 movq	 xmm0, QWORD PTR [esi+180]
  001c7	66 0f d6 83 b4
	00 00 00	 movq	 QWORD PTR [ebx+180], xmm0
  001cf	f3 0f 7e 86 bc
	00 00 00	 movq	 xmm0, QWORD PTR [esi+188]
  001d7	66 0f d6 83 bc
	00 00 00	 movq	 QWORD PTR [ebx+188], xmm0
  001df	f3 0f 7e 86 c4
	00 00 00	 movq	 xmm0, QWORD PTR [esi+196]
  001e7	66 0f d6 83 c4
	00 00 00	 movq	 QWORD PTR [ebx+196], xmm0
  001ef	f3 0f 7e 86 cc
	00 00 00	 movq	 xmm0, QWORD PTR [esi+204]
  001f7	66 0f d6 83 cc
	00 00 00	 movq	 QWORD PTR [ebx+204], xmm0
  001ff	8b 96 d4 00 00
	00		 mov	 edx, DWORD PTR [esi+212]
  00205	89 93 d4 00 00
	00		 mov	 DWORD PTR [ebx+212], edx
  0020b	c7 83 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+216], OFFSET ??_7Resource@@6B@
  00215	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  0021b	89 83 dc 00 00
	00		 mov	 DWORD PTR [ebx+220], eax
  00221	c7 83 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+216], OFFSET ??_7Bitmap@@6B@
  0022b	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  00231	89 8b e0 00 00
	00		 mov	 DWORD PTR [ebx+224], ecx
  00237	8b 96 e4 00 00
	00		 mov	 edx, DWORD PTR [esi+228]
  0023d	89 93 e4 00 00
	00		 mov	 DWORD PTR [ebx+228], edx
  00243	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  00249	89 83 e8 00 00
	00		 mov	 DWORD PTR [ebx+232], eax
  0024f	8b 8e ec 00 00
	00		 mov	 ecx, DWORD PTR [esi+236]
  00255	89 8b ec 00 00
	00		 mov	 DWORD PTR [ebx+236], ecx
  0025b	8a 96 f0 00 00
	00		 mov	 dl, BYTE PTR [esi+240]
  00261	88 93 f0 00 00
	00		 mov	 BYTE PTR [ebx+240], dl
  00267	8a 86 f1 00 00
	00		 mov	 al, BYTE PTR [esi+241]
  0026d	88 83 f1 00 00
	00		 mov	 BYTE PTR [ebx+241], al
  00273	8a 8e f2 00 00
	00		 mov	 cl, BYTE PTR [esi+242]
  00279	88 8b f2 00 00
	00		 mov	 BYTE PTR [ebx+242], cl
  0027f	8b 96 f4 00 00
	00		 mov	 edx, DWORD PTR [esi+244]
  00285	89 93 f4 00 00
	00		 mov	 DWORD PTR [ebx+244], edx
  0028b	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  00291	8b 55 f0	 mov	 edx, DWORD PTR _orig$119124[ebp]
  00294	89 83 f8 00 00
	00		 mov	 DWORD PTR [ebx+248], eax
  0029a	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  002a0	89 8b fc 00 00
	00		 mov	 DWORD PTR [ebx+252], ecx
  002a6	81 c6 00 01 00
	00		 add	 esi, 256		; 00000100H
  002ac	8d bb 00 01 00
	00		 lea	 edi, DWORD PTR [ebx+256]
  002b2	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  002b7	f3 a5		 rep movsd
  002b9	8b 82 40 01 00
	00		 mov	 eax, DWORD PTR [edx+320]
  002bf	89 83 40 01 00
	00		 mov	 DWORD PTR [ebx+320], eax
  002c5	eb 02		 jmp	 SHORT $LN7@CopyEvents
$LN6@CopyEvents:
  002c7	33 db		 xor	 ebx, ebx
$LN7@CopyEvents:

; 912  : 			events.append(event);

  002c9	8b 45 ec	 mov	 eax, DWORD PTR tv320[ebp]
  002cc	8b fb		 mov	 edi, ebx
  002ce	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002d5	e8 00 00 00 00	 call	 ?append@?$List@VMissionEvent@@@@QAEXPBVMissionEvent@@@Z ; List<MissionEvent>::append
  002da	8d 55 e0	 lea	 edx, DWORD PTR _iter$119120[ebp]
  002dd	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::next
  002e2	85 c0		 test	 eax, eax
  002e4	0f 85 7b fd ff
	ff		 jne	 $LN2@CopyEvents
$LN1@CopyEvents:

; 913  : 		}
; 914  : 	}
; 915  : }

  002ea	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002ed	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002f4	59		 pop	 ecx
  002f5	5f		 pop	 edi
  002f6	5e		 pop	 esi
  002f7	5b		 pop	 ebx
  002f8	8b e5		 mov	 esp, ebp
  002fa	5d		 pop	 ebp
  002fb	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$0:
  00000	68 8f 03 00 00	 push	 911			; 0000038fH
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 e8	 mov	 eax, DWORD PTR $T262544[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$1:
  00017	8b 4d e8	 mov	 ecx, DWORD PTR $T262544[ebp]
  0001a	83 c1 24	 add	 ecx, 36			; 00000024H
  0001d	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$2:
  00022	8b 4d e8	 mov	 ecx, DWORD PTR $T262544[ebp]
  00025	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00028	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$3:
  0002d	8b 4d e8	 mov	 ecx, DWORD PTR $T262544[ebp]
  00030	83 c1 34	 add	 ecx, 52			; 00000034H
  00033	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$4:
  00038	8b 4d e8	 mov	 ecx, DWORD PTR $T262544[ebp]
  0003b	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0003e	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$5:
  00043	8b 4d e8	 mov	 ecx, DWORD PTR $T262544[ebp]
  00046	83 c1 44	 add	 ecx, 68			; 00000044H
  00049	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CopyEvents@Sim@@IAEXXZ$6:
  0004e	8b 4d e8	 mov	 ecx, DWORD PTR $T262544[ebp]
  00051	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  00057	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__ehhandler$?CopyEvents@Sim@@IAEXXZ:
  0005c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00060	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00063	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00066	33 c8		 xor	 ecx, eax
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CopyEvents@Sim@@IAEXXZ
  00072	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CopyEvents@Sim@@IAEXXZ ENDP				; Sim::CopyEvents
PUBLIC	?IsComplete@Sim@@QBE_NXZ			; Sim::IsComplete
; Function compile flags: /Ogtp
;	COMDAT ?IsComplete@Sim@@QBE_NXZ
_TEXT	SEGMENT
?IsComplete@Sim@@QBE_NXZ PROC				; Sim::IsComplete, COMDAT
; _this$ = eax

; 291  : 	return mission && mission->IsComplete();

  00000	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [eax+192]
  00006	85 c0		 test	 eax, eax
  00008	74 0f		 je	 SHORT $LN3@IsComplete
  0000a	80 b8 ba 00 00
	00 00		 cmp	 BYTE PTR [eax+186], 0
  00011	74 06		 je	 SHORT $LN3@IsComplete
  00013	b8 01 00 00 00	 mov	 eax, 1

; 292  : }

  00018	c3		 ret	 0
$LN3@IsComplete:

; 291  : 	return mission && mission->IsComplete();

  00019	33 c0		 xor	 eax, eax

; 292  : }

  0001b	c3		 ret	 0
?IsComplete@Sim@@QBE_NXZ ENDP				; Sim::IsComplete
_TEXT	ENDS
PUBLIC	?IsActive@Sim@@QBE_NXZ				; Sim::IsActive
; Function compile flags: /Ogtp
;	COMDAT ?IsActive@Sim@@QBE_NXZ
_TEXT	SEGMENT
?IsActive@Sim@@QBE_NXZ PROC				; Sim::IsActive, COMDAT
; _this$ = eax

; 285  : 	return mission && mission->IsActive();

  00000	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [eax+192]
  00006	85 c0		 test	 eax, eax
  00008	74 0f		 je	 SHORT $LN3@IsActive
  0000a	80 b8 b9 00 00
	00 00		 cmp	 BYTE PTR [eax+185], 0
  00011	74 06		 je	 SHORT $LN3@IsActive
  00013	b8 01 00 00 00	 mov	 eax, 1

; 286  : }

  00018	c3		 ret	 0
$LN3@IsActive:

; 285  : 	return mission && mission->IsActive();

  00019	33 c0		 xor	 eax, eax

; 286  : }

  0001b	c3		 ret	 0
?IsActive@Sim@@QBE_NXZ ENDP				; Sim::IsActive
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0SimSplash@@QAE@PAVSimRegion@@ABUPoint@@NN@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_d$ = 12						; size = 8
_n$ = 20						; size = 8
??0SimSplash@@QAE@PAVSimRegion@@ABUPoint@@NN@Z PROC	; SimSplash::SimSplash, COMDAT
; _this$ = esi
; _l$ = edi

; 108  : 	owner_name("Collateral Damage"), missile(false) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CAMCFAKE@Collateral?5Damage?$AA@
  00008	8b ce		 mov	 ecx, esi
  0000a	e8 00 00 00 00	 call	 ??0Text@@QAE@PBD@Z	; Text::Text
  0000f	dd 07		 fld	 QWORD PTR [edi]
  00011	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _d$[ebp]
  00016	dd 5e 08	 fstp	 QWORD PTR [esi+8]
  00019	dd 47 08	 fld	 QWORD PTR [edi+8]
  0001c	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  0001f	dd 5e 10	 fstp	 QWORD PTR [esi+16]
  00022	dd 47 10	 fld	 QWORD PTR [edi+16]
  00025	dd 5e 18	 fstp	 QWORD PTR [esi+24]
  00028	f2 0f 11 46 20	 movsd	 QWORD PTR [esi+32], xmm0
  0002d	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _n$[ebp]
  00032	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00035	f2 0f 11 46 28	 movsd	 QWORD PTR [esi+40], xmm0
  0003a	c6 46 34 00	 mov	 BYTE PTR [esi+52], 0
  0003e	8b c6		 mov	 eax, esi
  00040	5d		 pop	 ebp
  00041	c2 14 00	 ret	 20			; 00000014H
??0SimSplash@@QAE@PAVSimRegion@@ABUPoint@@NN@Z ENDP	; SimSplash::SimSplash
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0SimHyper@@QAE@PAVShip@@PAVSimRegion@@ABUPoint@@H_N00@Z
_TEXT	SEGMENT
_o$ = 8							; size = 4
_r$ = 12						; size = 4
_t$ = 16						; size = 4
_h$ = 20						; size = 1
_fc1$ = 24						; size = 4
_fc2$ = 28						; size = 4
??0SimHyper@@QAE@PAVShip@@PAVSimRegion@@ABUPoint@@H_N00@Z PROC ; SimHyper::SimHyper, COMDAT
; _this$ = eax
; _l$ = ecx

; 89   : 	SimHyper(Ship* o, SimRegion* r, const Point& l, int t, bool h, Ship* fc1, Ship* fc2)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _o$[ebp]
  00006	89 10		 mov	 DWORD PTR [eax], edx
  00008	8b 55 0c	 mov	 edx, DWORD PTR _r$[ebp]
  0000b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000e	dd 01		 fld	 QWORD PTR [ecx]
  00010	8a 55 14	 mov	 dl, BYTE PTR _h$[ebp]
  00013	dd 58 08	 fstp	 QWORD PTR [eax+8]
  00016	dd 41 08	 fld	 QWORD PTR [ecx+8]
  00019	dd 58 10	 fstp	 QWORD PTR [eax+16]
  0001c	dd 41 10	 fld	 QWORD PTR [ecx+16]
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _t$[ebp]
  00022	dd 58 18	 fstp	 QWORD PTR [eax+24]
  00025	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00028	8b 4d 18	 mov	 ecx, DWORD PTR _fc1$[ebp]
  0002b	88 50 24	 mov	 BYTE PTR [eax+36], dl
  0002e	8b 55 1c	 mov	 edx, DWORD PTR _fc2$[ebp]
  00031	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00034	89 50 2c	 mov	 DWORD PTR [eax+44], edx
  00037	5d		 pop	 ebp
  00038	c2 18 00	 ret	 24			; 00000018H
??0SimHyper@@QAE@PAVShip@@PAVSimRegion@@ABUPoint@@H_N00@Z ENDP ; SimHyper::SimHyper
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\matrix games\dev\foundationex\memdebug.h
xdata$x	SEGMENT
__unwindtable$?AddInstruction@MissionElement@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddInstruction@MissionElement@@QAEXPBD@Z$0
__ehfuncinfo$?AddInstruction@MissionElement@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddInstruction@MissionElement@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\mission.h
xdata$x	ENDS
;	COMDAT ?AddInstruction@MissionElement@@QAEXPBD@Z
_TEXT	SEGMENT
$T262629 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_i$ = 12						; size = 4
?AddInstruction@MissionElement@@QAEXPBD@Z PROC		; MissionElement::AddInstruction, COMDAT

; 294  : 	void              AddInstruction(const char* i)  { instructions.append(new(__FILE__,__LINE__) Text(i)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddInstruction@MissionElement@@QAEXPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	6a 08		 push	 8
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002a	83 c4 04	 add	 esp, 4
  0002d	89 45 f0	 mov	 DWORD PTR $T262629[ebp], eax
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	85 c0		 test	 eax, eax
  00039	74 0d		 je	 SHORT $LN3@AddInstruc
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  0003e	51		 push	 ecx
  0003f	8b c8		 mov	 ecx, eax
  00041	e8 00 00 00 00	 call	 ??0Text@@QAE@PBD@Z	; Text::Text
  00046	eb 02		 jmp	 SHORT $LN4@AddInstruc
$LN3@AddInstruc:
  00048	33 c0		 xor	 eax, eax
$LN4@AddInstruc:
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	50		 push	 eax
  0004e	81 c1 dc 00 00
	00		 add	 ecx, 220		; 000000dcH
  00054	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005b	e8 00 00 00 00	 call	 ?append@?$List@VText@@@@QAEXPBVText@@@Z ; List<Text>::append
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddInstruction@MissionElement@@QAEXPBD@Z$0:
  00000	68 26 01 00 00	 push	 294			; 00000126H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@DCHCODGP@c?3?2matrix?5games?2dev?2stars45?2Miss@
  0000a	8b 45 f0	 mov	 eax, DWORD PTR $T262629[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__ehhandler$?AddInstruction@MissionElement@@QAEXPBD@Z:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddInstruction@MissionElement@@QAEXPBD@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddInstruction@MissionElement@@QAEXPBD@Z ENDP		; MissionElement::AddInstruction
; Function compile flags: /Ogtp
;	COMDAT ??_GUniverse@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GUniverse@@UAEPAXI@Z PROC				; Universe::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Universe@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar@4
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar@4:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GUniverse@@UAEPAXI@Z ENDP				; Universe::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\matrix games\dev\foundationex\list.inl
;	COMDAT ?removeItem@?$ListIter@VShot@@@@QAEPAVShot@@XZ
_TEXT	SEGMENT
?removeItem@?$ListIter@VShot@@@@QAEPAVShot@@XZ PROC	; ListIter<Shot>::removeItem, COMDAT
; _this$ = edx

; 393  :    if (list && step >= 0 && step < list->items)

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	85 c0		 test	 eax, eax
  00004	74 1a		 je	 SHORT $LN1@removeItem@4
  00006	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00009	85 c9		 test	 ecx, ecx
  0000b	78 13		 js	 SHORT $LN1@removeItem@4
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	7d 0f		 jge	 SHORT $LN1@removeItem@4

; 394  :       return list->removeIndex(step--);

  00011	56		 push	 esi
  00012	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  00015	51		 push	 ecx
  00016	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00019	e8 00 00 00 00	 call	 ?removeIndex@?$List@VShot@@@@QAEPAVShot@@H@Z ; List<Shot>::removeIndex
  0001e	5e		 pop	 esi

; 397  : }

  0001f	c3		 ret	 0
$LN1@removeItem@4:

; 395  : 
; 396  :    return 0;

  00020	33 c0		 xor	 eax, eax

; 397  : }

  00022	c3		 ret	 0
?removeItem@?$ListIter@VShot@@@@QAEPAVShot@@XZ ENDP	; ListIter<Shot>::removeItem
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?removeItem@?$ListIter@VShip@@@@QAEPAVShip@@XZ
_TEXT	SEGMENT
?removeItem@?$ListIter@VShip@@@@QAEPAVShip@@XZ PROC	; ListIter<Ship>::removeItem, COMDAT
; _this$ = edx

; 393  :    if (list && step >= 0 && step < list->items)

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	85 c0		 test	 eax, eax
  00004	74 1a		 je	 SHORT $LN1@removeItem@5
  00006	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00009	85 c9		 test	 ecx, ecx
  0000b	78 13		 js	 SHORT $LN1@removeItem@5
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	7d 0f		 jge	 SHORT $LN1@removeItem@5

; 394  :       return list->removeIndex(step--);

  00011	56		 push	 esi
  00012	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  00015	51		 push	 ecx
  00016	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00019	e8 00 00 00 00	 call	 ?removeIndex@?$List@VShip@@@@QAEPAVShip@@H@Z ; List<Ship>::removeIndex
  0001e	5e		 pop	 esi

; 397  : }

  0001f	c3		 ret	 0
$LN1@removeItem@5:

; 395  : 
; 396  :    return 0;

  00020	33 c0		 xor	 eax, eax

; 397  : }

  00022	c3		 ret	 0
?removeItem@?$ListIter@VShip@@@@QAEPAVShip@@XZ ENDP	; ListIter<Ship>::removeItem
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?removeIndex@?$List@VSimRegion@@@@QAEPAVSimRegion@@H@Z
_TEXT	SEGMENT
_index$ = -4						; size = 4
?removeIndex@?$List@VSimRegion@@@@QAEPAVSimRegion@@H@Z PROC ; List<SimRegion>::removeIndex, COMDAT
; _this$ = eax

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f0		 mov	 esi, eax

; 223  :    if (!check(index))

  00008	8d 7d fc	 lea	 edi, DWORD PTR _index$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _index$[ebp], 0
  00012	e8 00 00 00 00	 call	 ?check@?$List@VSimRegion@@@@ABE_NAAH@Z ; List<SimRegion>::check
  00017	84 c0		 test	 al, al
  00019	75 08		 jne	 SHORT $LN4@removeInde@6

; 224  :       return 0;

  0001b	5f		 pop	 edi
  0001c	33 c0		 xor	 eax, eax
  0001e	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN4@removeInde@6:

; 225  : 
; 226  :    T* tmp = array[index];

  00023	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _index$[ebp]
  00029	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]

; 227  :    array[index] = 0;

  0002e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 228  : 
; 229  :    // slide left:
; 230  :    for (int i = index; i < items-1; i++)

  00034	8b 16		 mov	 edx, DWORD PTR [esi]
  00036	4a		 dec	 edx
  00037	3b ca		 cmp	 ecx, edx
  00039	7d 19		 jge	 SHORT $LN1@removeInde@6
  0003b	eb 03 8d 49 00	 npad	 5
$LL3@removeInde@6:
  00040	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 231  :       array[i] = array[i+1];

  00043	8b 7c 8a 04	 mov	 edi, DWORD PTR [edx+ecx*4+4]
  00047	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  0004a	89 3a		 mov	 DWORD PTR [edx], edi
  0004c	8b 16		 mov	 edx, DWORD PTR [esi]
  0004e	41		 inc	 ecx
  0004f	4a		 dec	 edx
  00050	3b ca		 cmp	 ecx, edx
  00052	7c ec		 jl	 SHORT $LL3@removeInde@6
$LN1@removeInde@6:

; 232  : 
; 233  :    // blank out the hole we just created:
; 234  :    array[items-1] = 0;

  00054	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00056	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00059	c7 44 8a fc 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4-4], 0

; 235  : 
; 236  :    items--;

  00061	ff 0e		 dec	 DWORD PTR [esi]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi

; 237  :    return tmp;
; 238  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?removeIndex@?$List@VSimRegion@@@@QAEPAVSimRegion@@H@Z ENDP ; List<SimRegion>::removeIndex
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$List@VSimRegion@@@@QAEAAPAVSimRegion@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
??A?$List@VSimRegion@@@@QAEAAPAVSimRegion@@H@Z PROC	; List<SimRegion>::operator[], COMDAT
; _this$ = eax

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f0		 mov	 esi, eax

; 83   :    if (check(index))

  00007	8d 7d 08	 lea	 edi, DWORD PTR _index$[ebp]
  0000a	e8 00 00 00 00	 call	 ?check@?$List@VSimRegion@@@@ABE_NAAH@Z ; List<SimRegion>::check
  0000f	84 c0		 test	 al, al
  00011	74 0f		 je	 SHORT $LN3@operator@3

; 84   :       return array[index];

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00019	5f		 pop	 edi
  0001a	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0001d	5e		 pop	 esi

; 90   : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN3@operator@3:

; 85   : 
; 86   :    if (!array || !extent)

  00022	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00026	74 06		 je	 SHORT $LN1@operator@3
  00028	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0002c	75 0a		 jne	 SHORT $LN2@operator@3
$LN1@operator@3:

; 87   :       resize(1);

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	e8 00 00 00 00	 call	 ?resize@?$List@VSimRegion@@@@AAEXH@Z ; List<SimRegion>::resize
$LN2@operator@3:

; 88   : 
; 89   :    return array[0];

  00038	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi

; 90   : }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??A?$List@VSimRegion@@@@QAEAAPAVSimRegion@@H@Z ENDP	; List<SimRegion>::operator[]
_TEXT	ENDS
PUBLIC	?UpdateTracks@SimRegion@@IAEXN@Z		; SimRegion::UpdateTracks
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
;	COMDAT ?UpdateTracks@SimRegion@@IAEXN@Z
_TEXT	SEGMENT
_c_life$121279 = -28					; size = 8
_track_iter$121272 = -16				; size = 8
tv83 = -8						; size = 4
_this$ = 8						; size = 4
?UpdateTracks@SimRegion@@IAEXN@Z PROC			; SimRegion::UpdateTracks, COMDAT

; 3547 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx

; 3548 : 	for (int i = 0; i < 5; i++) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	81 c3 b8 00 00
	00		 add	 ebx, 184		; 000000b8H
  00012	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR tv83[ebp], 5
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL13@UpdateTrac:

; 3549 : 		ListIter<Contact> track_iter = track_database[i];
; 3550 : 
; 3551 : 		while (++track_iter) {

  00020	8d 55 f0	 lea	 edx, DWORD PTR _track_iter$121272[ebp]
  00023	89 5d f0	 mov	 DWORD PTR _track_iter$121272[ebp], ebx
  00026	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _track_iter$121272[ebp+4], -1
  0002d	e8 00 00 00 00	 call	 ?next@?$ListIter@VContact@@@@QAEPAVContact@@XZ ; ListIter<Contact>::next
  00032	85 c0		 test	 eax, eax
  00034	0f 84 a9 00 00
	00		 je	 $LN12@UpdateTrac
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL10@UpdateTrac:

; 3552 : 			Contact* t        = track_iter.value();

  00040	8d 45 f0	 lea	 eax, DWORD PTR _track_iter$121272[ebp]
  00043	e8 00 00 00 00	 call	 ?value@?$ListIter@VContact@@@@QAEPAVContact@@XZ ; ListIter<Contact>::value

; 3553 : 			Ship*    c_ship   = t->GetShip();
; 3554 : 			Shot*    c_shot   = t->GetShot();
; 3555 : 			double   c_life   = 0;

  00048	0f 57 c0	 xorps	 xmm0, xmm0
  0004b	8b f0		 mov	 esi, eax
  0004d	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00050	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00053	f2 0f 11 45 e4	 movsd	 QWORD PTR _c_life$121279[ebp], xmm0

; 3556 : 
; 3557 : 			if (c_ship) {

  00058	85 ff		 test	 edi, edi
  0005a	74 2c		 je	 SHORT $LN8@UpdateTrac

; 3558 : 				c_life = c_ship->Life();
; 3559 : 
; 3560 : 				// look for quantum jumps and orbit transitions:
; 3561 : 				if (c_ship->GetRegion() != this || c_ship->IsNetObserver())

  0005c	8b 07		 mov	 eax, DWORD PTR [edi]
  0005e	f2 0f 10 87 a8
	01 00 00	 movsd	 xmm0, QWORD PTR [edi+424]
  00066	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  0006c	8b cf		 mov	 ecx, edi
  0006e	f2 0f 11 45 e4	 movsd	 QWORD PTR _c_life$121279[ebp], xmm0
  00073	ff d2		 call	 edx
  00075	3b 45 08	 cmp	 eax, DWORD PTR _this$[ebp]
  00078	75 09		 jne	 SHORT $LN6@UpdateTrac
  0007a	80 bf 17 04 00
	00 00		 cmp	 BYTE PTR [edi+1047], 0
  00081	74 16		 je	 SHORT $LN30@UpdateTrac
$LN6@UpdateTrac:

; 3562 : 				c_life = 0;

  00083	0f 57 c0	 xorps	 xmm0, xmm0

; 3563 : 			}

  00086	eb 0c		 jmp	 SHORT $LN35@UpdateTrac
$LN8@UpdateTrac:

; 3564 : 
; 3565 : 			else if (c_shot)

  00088	85 c0		 test	 eax, eax
  0008a	74 0d		 je	 SHORT $LN30@UpdateTrac

; 3566 : 			c_life = c_shot->Life();

  0008c	f2 0f 10 80 a8
	01 00 00	 movsd	 xmm0, QWORD PTR [eax+424]
$LN35@UpdateTrac:
  00094	f2 0f 11 45 e4	 movsd	 QWORD PTR _c_life$121279[ebp], xmm0
$LN30@UpdateTrac:

; 3567 : 
; 3568 : 			if (t->Age() < 0 || c_life == 0) {

  00099	e8 00 00 00 00	 call	 ?Age@Contact@@QBENXZ	; Contact::Age
  0009e	66 0f 28 c8	 movapd	 xmm1, xmm0
  000a2	0f 57 c0	 xorps	 xmm0, xmm0
  000a5	66 0f 2f c1	 comisd	 xmm0, xmm1
  000a9	77 16		 ja	 SHORT $LN2@UpdateTrac
  000ab	f2 0f 10 4d e4	 movsd	 xmm1, QWORD PTR _c_life$121279[ebp]
  000b0	66 0f 2e c8	 ucomisd xmm1, xmm0
  000b4	9f		 lahf
  000b5	f6 c4 44	 test	 ah, 68			; 00000044H
  000b8	7b 07		 jnp	 SHORT $LN2@UpdateTrac

; 3571 : 			}
; 3572 : 
; 3573 : 			else {
; 3574 : 				t->Reset();

  000ba	e8 00 00 00 00	 call	 ?Reset@Contact@@QAEXXZ	; Contact::Reset
  000bf	eb 12		 jmp	 SHORT $LN16@UpdateTrac
$LN2@UpdateTrac:

; 3569 : 				track_iter.removeItem();

  000c1	8d 55 f0	 lea	 edx, DWORD PTR _track_iter$121272[ebp]
  000c4	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VContact@@@@QAEPAVContact@@XZ ; ListIter<Contact>::removeItem

; 3570 : 				delete t;

  000c9	8b 06		 mov	 eax, DWORD PTR [esi]
  000cb	8b 10		 mov	 edx, DWORD PTR [eax]
  000cd	6a 01		 push	 1
  000cf	8b ce		 mov	 ecx, esi
  000d1	ff d2		 call	 edx
$LN16@UpdateTrac:

; 3549 : 		ListIter<Contact> track_iter = track_database[i];
; 3550 : 
; 3551 : 		while (++track_iter) {

  000d3	8d 55 f0	 lea	 edx, DWORD PTR _track_iter$121272[ebp]
  000d6	e8 00 00 00 00	 call	 ?next@?$ListIter@VContact@@@@QAEPAVContact@@XZ ; ListIter<Contact>::next
  000db	85 c0		 test	 eax, eax
  000dd	0f 85 5d ff ff
	ff		 jne	 $LL10@UpdateTrac
$LN12@UpdateTrac:

; 3548 : 	for (int i = 0; i < 5; i++) {

  000e3	83 c3 0c	 add	 ebx, 12			; 0000000cH
  000e6	ff 4d f8	 dec	 DWORD PTR tv83[ebp]
  000e9	0f 85 31 ff ff
	ff		 jne	 $LL13@UpdateTrac

; 3575 : 			}
; 3576 : 		}
; 3577 : 	}
; 3578 : }

  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 04 00	 ret	 4
?UpdateTracks@SimRegion@@IAEXN@Z ENDP			; SimRegion::UpdateTracks
_TEXT	ENDS
PUBLIC	?TranslateObject@SimRegion@@IAEXPAVSimObject@@@Z ; SimRegion::TranslateObject
; Function compile flags: /Ogtp
;	COMDAT ?TranslateObject@SimRegion@@IAEXPAVSimObject@@@Z
_TEXT	SEGMENT
_delta$121212 = -24					; size = 24
?TranslateObject@SimRegion@@IAEXPAVSimObject@@@Z PROC	; SimRegion::TranslateObject, COMDAT
; _this$ = esi
; _object$ = edi

; 3519 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 3520 : 	if (orbital_region)

  00006	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00009	83 ec 18	 sub	 esp, 24			; 00000018H
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN10@TranslateO

; 3521 : 	location = orbital_region->Location();

  00010	f2 0f 10 40 60	 movsd	 xmm0, QWORD PTR [eax+96]
  00015	f2 0f 10 48 68	 movsd	 xmm1, QWORD PTR [eax+104]
  0001a	f2 0f 10 50 70	 movsd	 xmm2, QWORD PTR [eax+112]
  0001f	f2 0f 11 46 20	 movsd	 QWORD PTR [esi+32], xmm0
  00024	f2 0f 11 4e 28	 movsd	 QWORD PTR [esi+40], xmm1
  00029	f2 0f 11 56 30	 movsd	 QWORD PTR [esi+48], xmm2
$LN10@TranslateO:

; 3522 : 
; 3523 : 	if (object) {

  0002e	85 ff		 test	 edi, edi
  00030	74 55		 je	 SHORT $LN1@TranslateO

; 3524 : 		SimRegion* orig = object->GetRegion();

  00032	8b 07		 mov	 eax, DWORD PTR [edi]
  00034	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  0003a	8b cf		 mov	 ecx, edi
  0003c	ff d2		 call	 edx

; 3525 : 		if (orig) {

  0003e	85 c0		 test	 eax, eax
  00040	74 45		 je	 SHORT $LN1@TranslateO

; 3526 : 			Point delta = Location() - orig->Location();

  00042	f2 0f 10 46 20	 movsd	 xmm0, QWORD PTR [esi+32]
  00047	f2 0f 10 4e 28	 movsd	 xmm1, QWORD PTR [esi+40]
  0004c	f2 0f 10 56 30	 movsd	 xmm2, QWORD PTR [esi+48]
  00051	f2 0f 5c 40 20	 subsd	 xmm0, QWORD PTR [eax+32]
  00056	f2 0f 5c 48 28	 subsd	 xmm1, QWORD PTR [eax+40]
  0005b	f2 0f 5c 50 30	 subsd	 xmm2, QWORD PTR [eax+48]

; 3527 : 			delta = delta.OtherHand();
; 3528 : 			object->TranslateBy(delta);

  00060	8b 07		 mov	 eax, DWORD PTR [edi]
  00062	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0006a	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0006d	8d 0c 24	 lea	 ecx, DWORD PTR _delta$121212[esp+24]
  00070	51		 push	 ecx
  00071	8b cf		 mov	 ecx, edi
  00073	f2 0f 11 44 24
	04		 movsd	 QWORD PTR _delta$121212[esp+28], xmm0
  00079	f2 0f 11 54 24
	0c		 movsd	 QWORD PTR _delta$121212[esp+36], xmm2
  0007f	f2 0f 11 4c 24
	14		 movsd	 QWORD PTR _delta$121212[esp+44], xmm1
  00085	ff d2		 call	 edx
$LN1@TranslateO:

; 3529 : 		}
; 3530 : 	}
; 3531 : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?TranslateObject@SimRegion@@IAEXPAVSimObject@@@Z ENDP	; SimRegion::TranslateObject
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?InsertObject@SimRegion@@UAEXPAVAsteroid@@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?InsertObject@SimRegion@@UAEXPAVAsteroid@@@Z PROC	; SimRegion::InsertObject, COMDAT
; _this$ = ecx

; 3497 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 3498 : 	if (!a) return;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _a$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	74 54		 je	 SHORT $LN1@InsertObje

; 3499 : 
; 3500 : 	SimRegion* orig = a->GetRegion();

  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00016	8b cf		 mov	 ecx, edi
  00018	ff d2		 call	 edx

; 3501 : 
; 3502 : 	if (orig != this) {

  0001a	3b c6		 cmp	 eax, esi
  0001c	74 44		 je	 SHORT $LN1@InsertObje

; 3503 : 		if (orig != 0)

  0001e	85 c0		 test	 eax, eax
  00020	74 0a		 je	 SHORT $LN2@InsertObje

; 3504 : 		orig->asteroids.remove(a);

  00022	05 ac 00 00 00	 add	 eax, 172		; 000000acH
  00027	e8 00 00 00 00	 call	 ?remove@?$List@VAsteroid@@@@QAEPAVAsteroid@@PBV2@@Z ; List<Asteroid>::remove
$LN2@InsertObje:

; 3505 : 
; 3506 : 		asteroids.append(a);

  0002c	8d 86 ac 00 00
	00		 lea	 eax, DWORD PTR [esi+172]
  00032	e8 00 00 00 00	 call	 ?append@?$List@VAsteroid@@@@QAEXPBVAsteroid@@@Z ; List<Asteroid>::append

; 3507 : 		TranslateObject(a);

  00037	e8 00 00 00 00	 call	 ?TranslateObject@SimRegion@@IAEXPAVSimObject@@@Z ; SimRegion::TranslateObject

; 3508 : 		a->SetRegion(this);

  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8b 90 94 00 00
	00		 mov	 edx, DWORD PTR [eax+148]
  00044	56		 push	 esi
  00045	8b cf		 mov	 ecx, edi
  00047	ff d2		 call	 edx

; 3509 : 		
; 3510 : 		if (active)

  00049	80 7e 40 00	 cmp	 BYTE PTR [esi+64], 0
  0004d	74 13		 je	 SHORT $LN1@InsertObje

; 3511 : 		a->Activate(sim->scene);

  0004f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  0005a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0005d	51		 push	 ecx
  0005e	8b cf		 mov	 ecx, edi
  00060	ff d2		 call	 edx
$LN1@InsertObje:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 3512 : 	}
; 3513 : }

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?InsertObject@SimRegion@@UAEXPAVAsteroid@@@Z ENDP	; SimRegion::InsertObject
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?InsertObject@SimRegion@@UAEXPAVDebris@@@Z
_TEXT	SEGMENT
_d$ = 8							; size = 4
?InsertObject@SimRegion@@UAEXPAVDebris@@@Z PROC		; SimRegion::InsertObject, COMDAT
; _this$ = ecx

; 3477 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 3478 : 	if (!d) return;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _d$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	74 54		 je	 SHORT $LN1@InsertObje@2

; 3479 : 
; 3480 : 	SimRegion* orig = d->GetRegion();

  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00016	8b cf		 mov	 ecx, edi
  00018	ff d2		 call	 edx

; 3481 : 
; 3482 : 	if (orig != this) {

  0001a	3b c6		 cmp	 eax, esi
  0001c	74 44		 je	 SHORT $LN1@InsertObje@2

; 3483 : 		if (orig != 0)

  0001e	85 c0		 test	 eax, eax
  00020	74 0a		 je	 SHORT $LN2@InsertObje@2

; 3484 : 		orig->debris.remove(d);

  00022	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00027	e8 00 00 00 00	 call	 ?remove@?$List@VDebris@@@@QAEPAVDebris@@PBV2@@Z ; List<Debris>::remove
$LN2@InsertObje@2:

; 3485 : 
; 3486 : 		debris.append(d);

  0002c	8d 86 a0 00 00
	00		 lea	 eax, DWORD PTR [esi+160]
  00032	e8 00 00 00 00	 call	 ?append@?$List@VDebris@@@@QAEXPBVDebris@@@Z ; List<Debris>::append

; 3487 : 		TranslateObject(d);

  00037	e8 00 00 00 00	 call	 ?TranslateObject@SimRegion@@IAEXPAVSimObject@@@Z ; SimRegion::TranslateObject

; 3488 : 		d->SetRegion(this);

  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8b 90 94 00 00
	00		 mov	 edx, DWORD PTR [eax+148]
  00044	56		 push	 esi
  00045	8b cf		 mov	 ecx, edi
  00047	ff d2		 call	 edx

; 3489 : 		
; 3490 : 		if (active)

  00049	80 7e 40 00	 cmp	 BYTE PTR [esi+64], 0
  0004d	74 13		 je	 SHORT $LN1@InsertObje@2

; 3491 : 		d->Activate(sim->scene);

  0004f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  0005a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0005d	51		 push	 ecx
  0005e	8b cf		 mov	 ecx, edi
  00060	ff d2		 call	 edx
$LN1@InsertObje@2:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 3492 : 	}
; 3493 : }

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?InsertObject@SimRegion@@UAEXPAVDebris@@@Z ENDP		; SimRegion::InsertObject
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?InsertObject@SimRegion@@UAEXPAVExplosion@@@Z
_TEXT	SEGMENT
_exp$ = 8						; size = 4
?InsertObject@SimRegion@@UAEXPAVExplosion@@@Z PROC	; SimRegion::InsertObject, COMDAT
; _this$ = ecx

; 3457 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 3458 : 	if (!exp) return;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _exp$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	74 54		 je	 SHORT $LN1@InsertObje@3

; 3459 : 
; 3460 : 	SimRegion* orig = exp->GetRegion();

  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00016	8b cf		 mov	 ecx, edi
  00018	ff d2		 call	 edx

; 3461 : 
; 3462 : 	if (orig != this) {

  0001a	3b c6		 cmp	 eax, esi
  0001c	74 44		 je	 SHORT $LN1@InsertObje@3

; 3463 : 		if (orig != 0)

  0001e	85 c0		 test	 eax, eax
  00020	74 0a		 je	 SHORT $LN2@InsertObje@3

; 3464 : 		orig->explosions.remove(exp);

  00022	05 94 00 00 00	 add	 eax, 148		; 00000094H
  00027	e8 00 00 00 00	 call	 ?remove@?$List@VExplosion@@@@QAEPAVExplosion@@PBV2@@Z ; List<Explosion>::remove
$LN2@InsertObje@3:

; 3465 : 
; 3466 : 		explosions.append(exp);

  0002c	8d 86 94 00 00
	00		 lea	 eax, DWORD PTR [esi+148]
  00032	e8 00 00 00 00	 call	 ?append@?$List@VExplosion@@@@QAEXPBVExplosion@@@Z ; List<Explosion>::append

; 3467 : 		TranslateObject(exp);

  00037	e8 00 00 00 00	 call	 ?TranslateObject@SimRegion@@IAEXPAVSimObject@@@Z ; SimRegion::TranslateObject

; 3468 : 		exp->SetRegion(this);

  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8b 90 94 00 00
	00		 mov	 edx, DWORD PTR [eax+148]
  00044	56		 push	 esi
  00045	8b cf		 mov	 ecx, edi
  00047	ff d2		 call	 edx

; 3469 : 		
; 3470 : 		if (active)

  00049	80 7e 40 00	 cmp	 BYTE PTR [esi+64], 0
  0004d	74 13		 je	 SHORT $LN1@InsertObje@3

; 3471 : 		exp->Activate(sim->scene);

  0004f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  0005a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0005d	51		 push	 ecx
  0005e	8b cf		 mov	 ecx, edi
  00060	ff d2		 call	 edx
$LN1@InsertObje@3:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 3472 : 	}
; 3473 : }

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?InsertObject@SimRegion@@UAEXPAVExplosion@@@Z ENDP	; SimRegion::InsertObject
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?InsertObject@SimRegion@@UAEXPAVShot@@@Z
_TEXT	SEGMENT
_shot$ = 8						; size = 4
?InsertObject@SimRegion@@UAEXPAVShot@@@Z PROC		; SimRegion::InsertObject, COMDAT
; _this$ = ecx

; 3434 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 3435 : 	if (!shot) return;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _shot$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	74 6a		 je	 SHORT $LN1@InsertObje@4

; 3436 : 
; 3437 : 	SimRegion* orig = shot->GetRegion();

  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00016	8b cf		 mov	 ecx, edi
  00018	ff d2		 call	 edx

; 3438 : 
; 3439 : 	if (orig != this) {

  0001a	3b c6		 cmp	 eax, esi
  0001c	74 5a		 je	 SHORT $LN1@InsertObje@4

; 3440 : 		if (orig != 0)

  0001e	85 c0		 test	 eax, eax
  00020	74 08		 je	 SHORT $LN3@InsertObje@4

; 3441 : 		orig->shots.remove(shot);

  00022	83 c0 7c	 add	 eax, 124		; 0000007cH
  00025	e8 00 00 00 00	 call	 ?remove@?$List@VShot@@@@QAEPAVShot@@PBV2@@Z ; List<Shot>::remove
$LN3@InsertObje@4:

; 3442 : 
; 3443 : 		shots.append(shot);

  0002a	8d 46 7c	 lea	 eax, DWORD PTR [esi+124]
  0002d	e8 00 00 00 00	 call	 ?append@?$List@VShot@@@@QAEXPBVShot@@@Z ; List<Shot>::append

; 3444 : 		if (shot->IsDrone())

  00032	8b 07		 mov	 eax, DWORD PTR [edi]
  00034	8b 90 c4 00 00
	00		 mov	 edx, DWORD PTR [eax+196]
  0003a	8b cf		 mov	 ecx, edi
  0003c	ff d2		 call	 edx
  0003e	84 c0		 test	 al, al
  00040	74 0b		 je	 SHORT $LN2@InsertObje@4

; 3445 : 		drones.append((Drone*) shot);

  00042	8d 86 88 00 00
	00		 lea	 eax, DWORD PTR [esi+136]
  00048	e8 00 00 00 00	 call	 ?append@?$List@VDrone@@@@QAEXPBVDrone@@@Z ; List<Drone>::append
$LN2@InsertObje@4:

; 3446 : 
; 3447 : 		TranslateObject(shot);

  0004d	e8 00 00 00 00	 call	 ?TranslateObject@SimRegion@@IAEXPAVSimObject@@@Z ; SimRegion::TranslateObject

; 3448 : 		shot->SetRegion(this);

  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	8b 90 94 00 00
	00		 mov	 edx, DWORD PTR [eax+148]
  0005a	56		 push	 esi
  0005b	8b cf		 mov	 ecx, edi
  0005d	ff d2		 call	 edx

; 3449 : 		
; 3450 : 		if (active)

  0005f	80 7e 40 00	 cmp	 BYTE PTR [esi+64], 0
  00063	74 13		 je	 SHORT $LN1@InsertObje@4

; 3451 : 		shot->Activate(sim->scene);

  00065	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00068	8b 07		 mov	 eax, DWORD PTR [edi]
  0006a	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  00070	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00073	51		 push	 ecx
  00074	8b cf		 mov	 ecx, edi
  00076	ff d2		 call	 edx
$LN1@InsertObje@4:
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi

; 3452 : 	}
; 3453 : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?InsertObject@SimRegion@@UAEXPAVShot@@@Z ENDP		; SimRegion::InsertObject
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?InsertObject@SimRegion@@UAEXPAVShip@@@Z
_TEXT	SEGMENT
_ship$ = 8						; size = 4
?InsertObject@SimRegion@@UAEXPAVShip@@@Z PROC		; SimRegion::InsertObject, COMDAT
; _this$ = ecx

; 3404 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 3405 : 	if (!ship) return;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _ship$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	0f 84 8f 00 00
	00		 je	 $LN1@InsertObje@5

; 3406 : 
; 3407 : 	SimRegion* orig = ship->GetRegion();

  00012	8b 07		 mov	 eax, DWORD PTR [edi]
  00014	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  0001a	53		 push	 ebx
  0001b	8b cf		 mov	 ecx, edi
  0001d	ff d2		 call	 edx
  0001f	8b d8		 mov	 ebx, eax

; 3408 : 
; 3409 : 	if (orig != this) {

  00021	3b de		 cmp	 ebx, esi
  00023	74 7b		 je	 SHORT $LN9@InsertObje@5

; 3410 : 		if (orig != 0) {

  00025	85 db		 test	 ebx, ebx
  00027	74 31		 je	 SHORT $LN4@InsertObje@5

; 3411 : 			if (orig->active)

  00029	80 7b 40 00	 cmp	 BYTE PTR [ebx+64], 0
  0002d	74 13		 je	 SHORT $LN3@InsertObje@5

; 3412 : 			ship->Deactivate(sim->scene);

  0002f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00032	8b 07		 mov	 eax, DWORD PTR [edi]
  00034	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0003a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003d	51		 push	 ecx
  0003e	8b cf		 mov	 ecx, edi
  00040	ff d2		 call	 edx
$LN3@InsertObje@5:

; 3413 : 
; 3414 : 			orig->ships.remove(ship);

  00042	8d 43 4c	 lea	 eax, DWORD PTR [ebx+76]
  00045	e8 00 00 00 00	 call	 ?remove@?$List@VShip@@@@QAEPAVShip@@PBV2@@Z ; List<Ship>::remove

; 3415 : 			orig->carriers.remove(ship);

  0004a	8d 43 58	 lea	 eax, DWORD PTR [ebx+88]
  0004d	e8 00 00 00 00	 call	 ?remove@?$List@VShip@@@@QAEPAVShip@@PBV2@@Z ; List<Ship>::remove

; 3416 : 			orig->selection.remove(ship);

  00052	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  00055	e8 00 00 00 00	 call	 ?remove@?$List@VShip@@@@QAEPAVShip@@PBV2@@Z ; List<Ship>::remove
$LN4@InsertObje@5:

; 3417 : 		}
; 3418 : 
; 3419 : 		ships.append(ship);

  0005a	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  0005d	e8 00 00 00 00	 call	 ?append@?$List@VShip@@@@QAEXPBVShip@@@Z ; List<Ship>::append

; 3420 : 
; 3421 : 		if (ship->NumFlightDecks())

  00062	8b c7		 mov	 eax, edi
  00064	e8 00 00 00 00	 call	 ?NumFlightDecks@Ship@@QBEHXZ ; Ship::NumFlightDecks
  00069	85 c0		 test	 eax, eax
  0006b	74 08		 je	 SHORT $LN2@InsertObje@5

; 3422 : 		carriers.append(ship);

  0006d	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  00070	e8 00 00 00 00	 call	 ?append@?$List@VShip@@@@QAEXPBVShip@@@Z ; List<Ship>::append
$LN2@InsertObje@5:

; 3423 : 
; 3424 : 		TranslateObject(ship);

  00075	e8 00 00 00 00	 call	 ?TranslateObject@SimRegion@@IAEXPAVSimObject@@@Z ; SimRegion::TranslateObject

; 3425 : 		ship->SetRegion(this);

  0007a	8b 07		 mov	 eax, DWORD PTR [edi]
  0007c	8b 90 94 00 00
	00		 mov	 edx, DWORD PTR [eax+148]
  00082	56		 push	 esi
  00083	8b cf		 mov	 ecx, edi
  00085	ff d2		 call	 edx

; 3426 : 		
; 3427 : 		if (active)

  00087	80 7e 40 00	 cmp	 BYTE PTR [esi+64], 0
  0008b	74 13		 je	 SHORT $LN9@InsertObje@5

; 3428 : 		ship->Activate(sim->scene);

  0008d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00090	8b 07		 mov	 eax, DWORD PTR [edi]
  00092	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  00098	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009b	51		 push	 ecx
  0009c	8b cf		 mov	 ecx, edi
  0009e	ff d2		 call	 edx
$LN9@InsertObje@5:
  000a0	5b		 pop	 ebx
$LN1@InsertObje@5:
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi

; 3429 : 	}
; 3430 : }

  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
?InsertObject@SimRegion@@UAEXPAVShip@@@Z ENDP		; SimRegion::InsertObject
_TEXT	ENDS
PUBLIC	?AddSelection@SimRegion@@QAEXPAVShip@@@Z	; SimRegion::AddSelection
; Function compile flags: /Ogtp
;	COMDAT ?AddSelection@SimRegion@@QAEXPAVShip@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddSelection@SimRegion@@QAEXPAVShip@@@Z PROC		; SimRegion::AddSelection, COMDAT
; _newsel$ = eax

; 2416 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f8		 mov	 edi, eax

; 2417 : 	if (!newsel || 
; 2418 : 			newsel->GetFlightPhase() <  Ship::ACTIVE ||
; 2419 : 			newsel->GetFlightPhase() >= Ship::RECOVERY)

  00006	85 ff		 test	 edi, edi
  00008	74 3d		 je	 SHORT $LN2@AddSelecti
  0000a	8b 07		 mov	 eax, DWORD PTR [edi]
  0000c	8b 90 d4 00 00
	00		 mov	 edx, DWORD PTR [eax+212]
  00012	8b cf		 mov	 ecx, edi
  00014	ff d2		 call	 edx
  00016	83 f8 05	 cmp	 eax, 5
  00019	7c 2c		 jl	 SHORT $LN2@AddSelecti
  0001b	8b 07		 mov	 eax, DWORD PTR [edi]
  0001d	8b 90 d4 00 00
	00		 mov	 edx, DWORD PTR [eax+212]
  00023	8b cf		 mov	 ecx, edi
  00025	ff d2		 call	 edx
  00027	83 f8 07	 cmp	 eax, 7
  0002a	7d 1b		 jge	 SHORT $LN2@AddSelecti

; 2420 : 	return;
; 2421 : 
; 2422 : 	if (!selection.contains(newsel))

  0002c	56		 push	 esi
  0002d	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00030	8b c7		 mov	 eax, edi
  00032	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  00035	e8 00 00 00 00	 call	 ?contains@?$List@VShip@@@@QBE_NPBVShip@@@Z ; List<Ship>::contains
  0003a	84 c0		 test	 al, al
  0003c	75 08		 jne	 SHORT $LN6@AddSelecti

; 2423 : 	selection.append(newsel);

  0003e	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00041	e8 00 00 00 00	 call	 ?append@?$List@VShip@@@@QAEXPBVShip@@@Z ; List<Ship>::append
$LN6@AddSelecti:
  00046	5e		 pop	 esi
$LN2@AddSelecti:
  00047	5f		 pop	 edi

; 2424 : }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
?AddSelection@SimRegion@@QAEXPAVShip@@@Z ENDP		; SimRegion::AddSelection
_TEXT	ENDS
PUBLIC	?SetSelection@SimRegion@@QAEXPAVShip@@@Z	; SimRegion::SetSelection
; Function compile flags: /Ogtp
;	COMDAT ?SetSelection@SimRegion@@QAEXPAVShip@@@Z
_TEXT	SEGMENT
?SetSelection@SimRegion@@QAEXPAVShip@@@Z PROC		; SimRegion::SetSelection, COMDAT
; _this$ = eax
; _newsel$ = edi

; 2403 : {

  00000	56		 push	 esi

; 2404 : 	selection.clear();

  00001	8d 70 64	 lea	 esi, DWORD PTR [eax+100]
  00004	e8 00 00 00 00	 call	 ?clear@?$List@VShip@@@@QAEXXZ ; List<Ship>::clear

; 2405 : 	selection.append(newsel);

  00009	8b c6		 mov	 eax, esi
  0000b	5e		 pop	 esi
  0000c	e9 00 00 00 00	 jmp	 ?append@?$List@VShip@@@@QAEXPBVShip@@@Z ; List<Ship>::append
?SetSelection@SimRegion@@QAEXPAVShip@@@Z ENDP		; SimRegion::SetSelection
_TEXT	ENDS
PUBLIC	?IsSelected@SimRegion@@QAE_NPAVShip@@@Z		; SimRegion::IsSelected
; Function compile flags: /Ogtp
;	COMDAT ?IsSelected@SimRegion@@QAE_NPAVShip@@@Z
_TEXT	SEGMENT
?IsSelected@SimRegion@@QAE_NPAVShip@@@Z PROC		; SimRegion::IsSelected, COMDAT
; _this$ = ecx
; _s$ = eax

; 2392 : 	return selection.contains(s);

  00000	83 c1 64	 add	 ecx, 100		; 00000064H
  00003	e9 00 00 00 00	 jmp	 ?contains@?$List@VShip@@@@QBE_NPBVShip@@@Z ; List<Ship>::contains
?IsSelected@SimRegion@@QAE_NPAVShip@@@Z ENDP		; SimRegion::IsSelected
_TEXT	ENDS
PUBLIC	??NSimRegion@@QBEHABV0@@Z			; SimRegion::operator<=
; Function compile flags: /Ogtp
;	COMDAT ??NSimRegion@@QBEHABV0@@Z
_TEXT	SEGMENT
??NSimRegion@@QBEHABV0@@Z PROC				; SimRegion::operator<=, COMDAT
; _this$ = eax
; _r$ = ecx

; 2301 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 2302 : 	return (orbital_region && r.orbital_region && *orbital_region <= *r.orbital_region);

  00006	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00009	85 c0		 test	 eax, eax
  0000b	74 64		 je	 SHORT $LN3@operator@4
  0000d	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00010	85 c9		 test	 ecx, ecx
  00012	74 5d		 je	 SHORT $LN3@operator@4
  00014	f2 0f 10 40 68	 movsd	 xmm0, QWORD PTR [eax+104]
  00019	f2 0f 10 48 60	 movsd	 xmm1, QWORD PTR [eax+96]
  0001e	f2 0f 10 50 70	 movsd	 xmm2, QWORD PTR [eax+112]
  00023	f2 0f 10 59 68	 movsd	 xmm3, QWORD PTR [ecx+104]
  00028	f2 0f 10 61 60	 movsd	 xmm4, QWORD PTR [ecx+96]
  0002d	f2 0f 10 69 70	 movsd	 xmm5, QWORD PTR [ecx+112]
  00032	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00036	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0003a	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0003e	f2 0f 59 e4	 mulsd	 xmm4, xmm4
  00042	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  00046	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0004a	f2 0f 59 db	 mulsd	 xmm3, xmm3
  0004e	f2 0f 51 c1	 sqrtsd	 xmm0, xmm1
  00052	f2 0f 58 e3	 addsd	 xmm4, xmm3
  00056	f2 0f 59 ed	 mulsd	 xmm5, xmm5
  0005a	f2 0f 58 e5	 addsd	 xmm4, xmm5
  0005e	f2 0f 51 cc	 sqrtsd	 xmm1, xmm4
  00062	66 0f 2f c8	 comisd	 xmm1, xmm0
  00066	72 09		 jb	 SHORT $LN3@operator@4
  00068	b8 01 00 00 00	 mov	 eax, 1

; 2303 : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN3@operator@4:

; 2302 : 	return (orbital_region && r.orbital_region && *orbital_region <= *r.orbital_region);

  00071	33 c0		 xor	 eax, eax

; 2303 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
??NSimRegion@@QBEHABV0@@Z ENDP				; SimRegion::operator<=
_TEXT	ENDS
PUBLIC	??MSimRegion@@QBEHABV0@@Z			; SimRegion::operator<
; Function compile flags: /Ogtp
;	COMDAT ??MSimRegion@@QBEHABV0@@Z
_TEXT	SEGMENT
??MSimRegion@@QBEHABV0@@Z PROC				; SimRegion::operator<, COMDAT
; _this$ = eax
; _r$ = ecx

; 2295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 2296 : 	return (orbital_region && r.orbital_region && *orbital_region <  *r.orbital_region);

  00006	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00009	85 c0		 test	 eax, eax
  0000b	74 64		 je	 SHORT $LN3@operator@5
  0000d	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00010	85 c9		 test	 ecx, ecx
  00012	74 5d		 je	 SHORT $LN3@operator@5
  00014	f2 0f 10 40 68	 movsd	 xmm0, QWORD PTR [eax+104]
  00019	f2 0f 10 48 60	 movsd	 xmm1, QWORD PTR [eax+96]
  0001e	f2 0f 10 50 70	 movsd	 xmm2, QWORD PTR [eax+112]
  00023	f2 0f 10 59 68	 movsd	 xmm3, QWORD PTR [ecx+104]
  00028	f2 0f 10 61 60	 movsd	 xmm4, QWORD PTR [ecx+96]
  0002d	f2 0f 10 69 70	 movsd	 xmm5, QWORD PTR [ecx+112]
  00032	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00036	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0003a	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0003e	f2 0f 59 e4	 mulsd	 xmm4, xmm4
  00042	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  00046	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0004a	f2 0f 59 db	 mulsd	 xmm3, xmm3
  0004e	f2 0f 51 c1	 sqrtsd	 xmm0, xmm1
  00052	f2 0f 58 e3	 addsd	 xmm4, xmm3
  00056	f2 0f 59 ed	 mulsd	 xmm5, xmm5
  0005a	f2 0f 58 e5	 addsd	 xmm4, xmm5
  0005e	f2 0f 51 cc	 sqrtsd	 xmm1, xmm4
  00062	66 0f 2f c8	 comisd	 xmm1, xmm0
  00066	76 09		 jbe	 SHORT $LN3@operator@5
  00068	b8 01 00 00 00	 mov	 eax, 1

; 2297 : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN3@operator@5:

; 2296 : 	return (orbital_region && r.orbital_region && *orbital_region <  *r.orbital_region);

  00071	33 c0		 xor	 eax, eax

; 2297 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
??MSimRegion@@QBEHABV0@@Z ENDP				; SimRegion::operator<
_TEXT	ENDS
PUBLIC	?FindSquadron@Sim@@IAEPAVHangar@@PBDAAH@Z	; Sim::FindSquadron
; Function compile flags: /Ogtp
;	COMDAT ?FindSquadron@Sim@@IAEPAVHangar@@PBDAAH@Z
_TEXT	SEGMENT
$T290829 = -28						; size = 8
_iter$ = -20						; size = 8
_s_iter$120265 = -12					; size = 8
_hangar$ = -4						; size = 4
_name$ = 8						; size = 4
_index$ = 12						; size = 4
?FindSquadron@Sim@@IAEPAVHangar@@PBDAAH@Z PROC		; Sim::FindSquadron, COMDAT
; _this$ = eax

; 2204 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2205 : 	Hangar* hangar = 0;
; 2206 : 
; 2207 : 	ListIter<SimRegion> iter = regions;

  00008	83 c0 58	 add	 eax, 88			; 00000058H
  0000b	33 f6		 xor	 esi, esi
  0000d	57		 push	 edi

; 2208 : 	while (++iter && !hangar) {

  0000e	8d 55 ec	 lea	 edx, DWORD PTR _iter$[ebp]
  00011	89 75 fc	 mov	 DWORD PTR _hangar$[ebp], esi
  00014	89 45 ec	 mov	 DWORD PTR _iter$[ebp], eax
  00017	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _iter$[ebp+4], -1
  0001e	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00023	85 c0		 test	 eax, eax
  00025	0f 84 db 00 00
	00		 je	 $LN41@FindSquadr
$LN8@FindSquadr:
  0002b	85 f6		 test	 esi, esi
  0002d	0f 85 d3 00 00
	00		 jne	 $LN41@FindSquadr

; 2209 : 		SimRegion* rgn = iter.value();

  00033	8d 45 ec	 lea	 eax, DWORD PTR _iter$[ebp]
  00036	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value

; 2210 : 
; 2211 : 		ListIter<Ship> s_iter = rgn->Carriers();

  0003b	83 c0 58	 add	 eax, 88			; 00000058H

; 2212 : 		while (++s_iter && !hangar) {

  0003e	8d 55 f4	 lea	 edx, DWORD PTR _s_iter$120265[ebp]
  00041	89 45 f4	 mov	 DWORD PTR _s_iter$120265[ebp], eax
  00044	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _s_iter$120265[ebp+4], -1
  0004b	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00050	85 c0		 test	 eax, eax
  00052	0f 84 9e 00 00
	00		 je	 $LN5@FindSquadr
$LN6@FindSquadr:
  00058	85 f6		 test	 esi, esi
  0005a	0f 85 96 00 00
	00		 jne	 $LN5@FindSquadr

; 2213 : 			Ship*    carrier = s_iter.value();

  00060	8d 45 f4	 lea	 eax, DWORD PTR _s_iter$120265[ebp]
  00063	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value

; 2214 : 			Hangar*  h       = carrier->GetHangar();

  00068	8b 98 68 03 00
	00		 mov	 ebx, DWORD PTR [eax+872]

; 2215 : 
; 2216 : 			for (int i = 0; i < h->NumSquadrons() && !hangar; i++) {

  0006e	33 ff		 xor	 edi, edi
  00070	39 7b 14	 cmp	 DWORD PTR [ebx+20], edi
  00073	7e 71		 jle	 SHORT $LN2@FindSquadr
$LL4@FindSquadr:
  00075	85 f6		 test	 esi, esi
  00077	75 6d		 jne	 SHORT $LN2@FindSquadr

; 2217 : 				if (h->SquadronName(i) == name) {

  00079	8b c7		 mov	 eax, edi
  0007b	8d 75 e4	 lea	 esi, DWORD PTR $T290829[ebp]
  0007e	8b cb		 mov	 ecx, ebx
  00080	e8 00 00 00 00	 call	 ?SquadronName@Hangar@@QBE?AVText@@H@Z ; Hangar::SquadronName
  00085	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00088	80 79 10 00	 cmp	 BYTE PTR [ecx+16], 0
  0008c	8b 00		 mov	 eax, DWORD PTR [eax]
  0008e	74 2a		 je	 SHORT $LN29@FindSquadr
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
$LL36@FindSquadr:
  00093	8a 10		 mov	 dl, BYTE PTR [eax]
  00095	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00097	75 1a		 jne	 SHORT $LN37@FindSquadr
  00099	84 d2		 test	 dl, dl
  0009b	74 12		 je	 SHORT $LN38@FindSquadr
  0009d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000a0	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000a3	75 0e		 jne	 SHORT $LN37@FindSquadr
  000a5	83 c0 02	 add	 eax, 2
  000a8	83 c1 02	 add	 ecx, 2
  000ab	84 d2		 test	 dl, dl
  000ad	75 e4		 jne	 SHORT $LL36@FindSquadr
$LN38@FindSquadr:
  000af	33 c0		 xor	 eax, eax
  000b1	eb 14		 jmp	 SHORT $LN39@FindSquadr
$LN37@FindSquadr:
  000b3	1b c0		 sbb	 eax, eax
  000b5	83 d8 ff	 sbb	 eax, -1
  000b8	eb 0d		 jmp	 SHORT $LN39@FindSquadr
$LN29@FindSquadr:
  000ba	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  000bd	52		 push	 edx
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 __stricmp
  000c4	83 c4 08	 add	 esp, 8
$LN39@FindSquadr:
  000c7	8d 4d e4	 lea	 ecx, DWORD PTR $T290829[ebp]
  000ca	8b f0		 mov	 esi, eax
  000cc	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  000d1	85 f6		 test	 esi, esi
  000d3	75 08		 jne	 SHORT $LN3@FindSquadr

; 2218 : 					hangar = h;
; 2219 : 					index  = i;

  000d5	8b 4d 0c	 mov	 ecx, DWORD PTR _index$[ebp]
  000d8	89 5d fc	 mov	 DWORD PTR _hangar$[ebp], ebx
  000db	89 39		 mov	 DWORD PTR [ecx], edi
$LN3@FindSquadr:

; 2215 : 
; 2216 : 			for (int i = 0; i < h->NumSquadrons() && !hangar; i++) {

  000dd	8b 75 fc	 mov	 esi, DWORD PTR _hangar$[ebp]
  000e0	47		 inc	 edi
  000e1	3b 7b 14	 cmp	 edi, DWORD PTR [ebx+20]
  000e4	7c 8f		 jl	 SHORT $LL4@FindSquadr
$LN2@FindSquadr:

; 2212 : 		while (++s_iter && !hangar) {

  000e6	8d 55 f4	 lea	 edx, DWORD PTR _s_iter$120265[ebp]
  000e9	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  000ee	85 c0		 test	 eax, eax
  000f0	0f 85 62 ff ff
	ff		 jne	 $LN6@FindSquadr
$LN5@FindSquadr:

; 2208 : 	while (++iter && !hangar) {

  000f6	8d 55 ec	 lea	 edx, DWORD PTR _iter$[ebp]
  000f9	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  000fe	85 c0		 test	 eax, eax
  00100	0f 85 25 ff ff
	ff		 jne	 $LN8@FindSquadr
$LN41@FindSquadr:

; 2220 : 				}
; 2221 : 			}
; 2222 : 		}
; 2223 : 	}
; 2224 : 
; 2225 : 	return hangar;
; 2226 : }

  00106	5f		 pop	 edi
  00107	8b c6		 mov	 eax, esi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 08 00	 ret	 8
?FindSquadron@Sim@@IAEPAVHangar@@PBDAAH@Z ENDP		; Sim::FindSquadron
_TEXT	ENDS
PUBLIC	?SkipCutscene@Sim@@QAEXXZ			; Sim::SkipCutscene
; Function compile flags: /Ogtp
;	COMDAT ?SkipCutscene@Sim@@QAEXXZ
_TEXT	SEGMENT
_skip_time$120089 = -16					; size = 8
_end_time$120078 = -16					; size = 8
_iter$120076 = -8					; size = 8
?SkipCutscene@Sim@@QAEXXZ PROC				; Sim::SkipCutscene, COMDAT
; _this$ = edi

; 1906 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1907 : 	Starshatter* stars = Starshatter::GetInstance();

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@Starshatter@@1PAV1@A ; Starshatter::instance
  00008	83 ec 10	 sub	 esp, 16			; 00000010H
  0000b	53		 push	 ebx
  0000c	56		 push	 esi

; 1908 : 	if (stars && stars->InCutscene()) {

  0000d	85 c0		 test	 eax, eax
  0000f	0f 84 bd 00 00
	00		 je	 $LN1@SkipCutsce
  00015	83 b8 0c a6 00
	00 00		 cmp	 DWORD PTR [eax+42508], 0
  0001c	0f 8e b0 00 00
	00		 jle	 $LN1@SkipCutsce

; 1909 : 		ListIter<MissionEvent>  iter     = events;
; 1910 : 		bool                    end      = false;
; 1911 : 		double                  end_time = 0;

  00022	0f 57 c0	 xorps	 xmm0, xmm0
  00025	8d 87 a0 00 00
	00		 lea	 eax, DWORD PTR [edi+160]

; 1912 : 
; 1913 : 		while (++iter && !end) {

  0002b	8d 55 f8	 lea	 edx, DWORD PTR _iter$120076[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR _iter$120076[ebp], eax
  00031	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iter$120076[ebp+4], -1
  00038	32 db		 xor	 bl, bl
  0003a	f2 0f 11 45 f0	 movsd	 QWORD PTR _end_time$120078[ebp], xmm0
  0003f	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::next
  00044	85 c0		 test	 eax, eax
  00046	74 5f		 je	 SHORT $LN8@SkipCutsce
$LL9@SkipCutsce:
  00048	84 db		 test	 bl, bl
  0004a	75 5b		 jne	 SHORT $LN8@SkipCutsce

; 1914 : 			MissionEvent* event = iter.value();

  0004c	8d 45 f8	 lea	 eax, DWORD PTR _iter$120076[ebp]
  0004f	e8 00 00 00 00	 call	 ?value@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::value
  00054	8b f0		 mov	 esi, eax

; 1915 : 
; 1916 : 			if (event->IsPending() || event->IsActive()) {

  00056	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00059	85 c0		 test	 eax, eax
  0005b	74 05		 je	 SHORT $LN6@SkipCutsce
  0005d	83 f8 01	 cmp	 eax, 1
  00060	75 39		 jne	 SHORT $LN2@SkipCutsce
$LN6@SkipCutsce:

; 1917 : 				if (event->Event() == MissionEvent::END_SCENE ||
; 1918 : 						event->Event() == MissionEvent::END_MISSION) {

  00062	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00065	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00068	74 05		 je	 SHORT $LN4@SkipCutsce
  0006a	83 f8 08	 cmp	 eax, 8
  0006d	75 0c		 jne	 SHORT $LN29@SkipCutsce
$LN4@SkipCutsce:

; 1919 : 					end = true;
; 1920 : 					end_time = event->Time();

  0006f	f2 0f 10 46 10	 movsd	 xmm0, QWORD PTR [esi+16]
  00074	b3 01		 mov	 bl, 1
  00076	f2 0f 11 45 f0	 movsd	 QWORD PTR _end_time$120078[ebp], xmm0
$LN29@SkipCutsce:

; 1921 : 				}
; 1922 : 
; 1923 : 				if (event->Event() == MissionEvent::FIRE_WEAPON) {
; 1924 : 					event->Skip();

  0007b	8b ce		 mov	 ecx, esi
  0007d	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00080	75 09		 jne	 SHORT $LN3@SkipCutsce
  00082	8b 16		 mov	 edx, DWORD PTR [esi]
  00084	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00087	ff d0		 call	 eax

; 1925 : 				}
; 1926 : 
; 1927 : 				else {

  00089	eb 10		 jmp	 SHORT $LN2@SkipCutsce
$LN3@SkipCutsce:

; 1928 : 					event->Activate();

  0008b	e8 00 00 00 00	 call	 ?Activate@MissionEvent@@QAEXXZ ; MissionEvent::Activate

; 1929 : 					event->Execute(true);

  00090	8b 16		 mov	 edx, DWORD PTR [esi]
  00092	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00095	6a 01		 push	 1
  00097	8b ce		 mov	 ecx, esi
  00099	ff d0		 call	 eax
$LN2@SkipCutsce:

; 1912 : 
; 1913 : 		while (++iter && !end) {

  0009b	8d 55 f8	 lea	 edx, DWORD PTR _iter$120076[ebp]
  0009e	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::next
  000a3	85 c0		 test	 eax, eax
  000a5	75 a1		 jne	 SHORT $LL9@SkipCutsce
$LN8@SkipCutsce:

; 1930 : 				}
; 1931 : 			}
; 1932 : 		}
; 1933 : 
; 1934 : 		double skip_time = end_time - MissionClock();

  000a7	57		 push	 edi
  000a8	e8 00 00 00 00	 call	 ?MissionClock@Sim@@QBENXZ ; Sim::MissionClock
  000ad	dc 6d f0	 fsubr	 QWORD PTR _end_time$120078[ebp]
  000b0	dd 55 f0	 fst	 QWORD PTR _skip_time$120089[ebp]

; 1935 : 		if (skip_time > 0) {

  000b3	d9 ee		 fldz
  000b5	d9 c9		 fxch	 ST(1)
  000b7	df f1		 fcomip	 ST(1)
  000b9	dd d8		 fstp	 ST(0)
  000bb	76 15		 jbe	 SHORT $LN1@SkipCutsce

; 1936 : 			Game::SkipGameTime(skip_time);

  000bd	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _skip_time$120089[ebp]
  000c2	83 ec 08	 sub	 esp, 8
  000c5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000ca	e8 00 00 00 00	 call	 ?SkipGameTime@Game@@SAXN@Z ; Game::SkipGameTime
  000cf	83 c4 08	 add	 esp, 8
$LN1@SkipCutsce:

; 1937 : 		}
; 1938 : 	}
; 1939 : }

  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
?SkipCutscene@Sim@@QAEXXZ ENDP				; Sim::SkipCutscene
_TEXT	ENDS
PUBLIC	?ExecEvents@Sim@@QAEXN@Z			; Sim::ExecEvents
; Function compile flags: /Ogtp
;	COMDAT ?ExecEvents@Sim@@QAEXN@Z
_TEXT	SEGMENT
_iter$ = -8						; size = 8
_seconds$ = 8						; size = 8
?ExecEvents@Sim@@QAEXN@Z PROC				; Sim::ExecEvents, COMDAT
; _this$ = eax

; 1585 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1586 : 	ListIter<MissionEvent> iter = events;

  00006	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  0000b	56		 push	 esi

; 1587 : 	while (++iter) {

  0000c	8d 55 f8	 lea	 edx, DWORD PTR _iter$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR _iter$[ebp], eax
  00012	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iter$[ebp+4], -1
  00019	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::next
  0001e	85 c0		 test	 eax, eax
  00020	74 28		 je	 SHORT $LN1@ExecEvents
$LN2@ExecEvents:

; 1588 : 		MissionEvent* event = iter.value();
; 1589 : 		event->ExecFrame(seconds);

  00022	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  00027	83 ec 08	 sub	 esp, 8
  0002a	8d 45 f8	 lea	 eax, DWORD PTR _iter$[ebp]
  0002d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00032	e8 00 00 00 00	 call	 ?value@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::value
  00037	8b f0		 mov	 esi, eax
  00039	e8 00 00 00 00	 call	 ?ExecFrame@MissionEvent@@QAEXN@Z ; MissionEvent::ExecFrame
  0003e	8d 55 f8	 lea	 edx, DWORD PTR _iter$[ebp]
  00041	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionEvent@@@@QAEPAVMissionEvent@@XZ ; ListIter<MissionEvent>::next
  00046	85 c0		 test	 eax, eax
  00048	75 d8		 jne	 SHORT $LN2@ExecEvents
$LN1@ExecEvents:

; 1590 : 	}
; 1591 : }

  0004a	5e		 pop	 esi
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
?ExecEvents@Sim@@QAEXN@Z ENDP				; Sim::ExecEvents
_TEXT	ENDS
PUBLIC	?RequestHyperJump@Sim@@QAEXPAVShip@@PAVSimRegion@@ABUPoint@@H00@Z ; Sim::RequestHyperJump
; Function compile flags: /Ogtp
;	COMDAT ?RequestHyperJump@Sim@@QAEXPAVShip@@PAVSimRegion@@ABUPoint@@H00@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_rgn$ = 12						; size = 4
_type$ = 16						; size = 4
_fc1$ = 20						; size = 4
_fc2$ = 24						; size = 4
?RequestHyperJump@Sim@@QAEXPAVShip@@PAVSimRegion@@ABUPoint@@H00@Z PROC ; Sim::RequestHyperJump, COMDAT
; _obj$ = eax
; _loc$ = esi

; 1479 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi
  00005	8b f8		 mov	 edi, eax

; 1480 : 	bool hyperdrive = false;
; 1481 : 
; 1482 : 	if (obj->GetQuantumDrive() && obj->GetQuantumDrive()->Subtype() == QuantumDrive::HYPER)

  00007	8b 87 38 03 00
	00		 mov	 eax, DWORD PTR [edi+824]
  0000d	32 db		 xor	 bl, bl
  0000f	85 c0		 test	 eax, eax
  00011	74 08		 je	 SHORT $LN1@RequestHyp
  00013	83 78 14 01	 cmp	 DWORD PTR [eax+20], 1
  00017	75 02		 jne	 SHORT $LN1@RequestHyp

; 1483 : 	hyperdrive = true;

  00019	b3 01		 mov	 bl, 1
$LN1@RequestHyp:

; 1484 : 
; 1485 : 	jumplist.append(new(__FILE__,__LINE__) SimHyper(obj, rgn, loc, type, hyperdrive, fc1, fc2));

  0001b	6a 30		 push	 48			; 00000030H
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	74 41		 je	 SHORT $LN4@RequestHyp
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _rgn$[ebp]
  0002c	8b 55 10	 mov	 edx, DWORD PTR _type$[ebp]
  0002f	89 38		 mov	 DWORD PTR [eax], edi
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00034	dd 06		 fld	 QWORD PTR [esi]
  00036	8b 4d 14	 mov	 ecx, DWORD PTR _fc1$[ebp]
  00039	dd 58 08	 fstp	 QWORD PTR [eax+8]
  0003c	dd 46 08	 fld	 QWORD PTR [esi+8]
  0003f	8b f8		 mov	 edi, eax
  00041	dd 58 10	 fstp	 QWORD PTR [eax+16]
  00044	dd 46 10	 fld	 QWORD PTR [esi+16]
  00047	dd 58 18	 fstp	 QWORD PTR [eax+24]
  0004a	89 50 20	 mov	 DWORD PTR [eax+32], edx
  0004d	8b 55 18	 mov	 edx, DWORD PTR _fc2$[ebp]
  00050	88 58 24	 mov	 BYTE PTR [eax+36], bl
  00053	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00056	89 50 2c	 mov	 DWORD PTR [eax+44], edx
  00059	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 c0 70	 add	 eax, 112		; 00000070H
  0005f	e8 00 00 00 00	 call	 ?append@?$List@VSimHyper@@@@QAEXPBVSimHyper@@@Z ; List<SimHyper>::append
  00064	5f		 pop	 edi
  00065	5b		 pop	 ebx

; 1486 : }

  00066	5d		 pop	 ebp
  00067	c2 14 00	 ret	 20			; 00000014H
$LN4@RequestHyp:

; 1484 : 
; 1485 : 	jumplist.append(new(__FILE__,__LINE__) SimHyper(obj, rgn, loc, type, hyperdrive, fc1, fc2));

  0006a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	33 ff		 xor	 edi, edi
  0006f	83 c0 70	 add	 eax, 112		; 00000070H
  00072	e8 00 00 00 00	 call	 ?append@?$List@VSimHyper@@@@QAEXPBVSimHyper@@@Z ; List<SimHyper>::append
  00077	5f		 pop	 edi
  00078	5b		 pop	 ebx

; 1486 : }

  00079	5d		 pop	 ebp
  0007a	c2 14 00	 ret	 20			; 00000014H
?RequestHyperJump@Sim@@QAEXPAVShip@@PAVSimRegion@@ABUPoint@@H00@Z ENDP ; Sim::RequestHyperJump
_TEXT	ENDS
PUBLIC	?FindRegion@Sim@@QAEPAVSimRegion@@PBD@Z		; Sim::FindRegion
; Function compile flags: /Ogtp
;	COMDAT ?FindRegion@Sim@@QAEPAVSimRegion@@PBD@Z
_TEXT	SEGMENT
_rgn$ = -8						; size = 8
?FindRegion@Sim@@QAEPAVSimRegion@@PBD@Z PROC		; Sim::FindRegion, COMDAT
; _this$ = eax
; _name$ = esi

; 1352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8

; 1353 : 	ListIter<SimRegion> rgn = regions;

  00009	83 c0 58	 add	 eax, 88			; 00000058H

; 1354 : 	while (++rgn)

  0000c	8d 14 24	 lea	 edx, DWORD PTR _rgn$[esp+8]
  0000f	89 04 24	 mov	 DWORD PTR _rgn$[esp+8], eax
  00012	c7 44 24 04 ff
	ff ff ff	 mov	 DWORD PTR _rgn$[esp+12], -1
  0001a	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  0001f	85 c0		 test	 eax, eax
  00021	74 61		 je	 SHORT $LN2@FindRegion@2
$LL3@FindRegion@2:

; 1355 : 	if (rgn->name == name)

  00023	8d 04 24	 lea	 eax, DWORD PTR _rgn$[esp+8]
  00026	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  0002b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0002e	80 79 10 00	 cmp	 BYTE PTR [ecx+16], 0
  00032	74 33		 je	 SHORT $LN15@FindRegion@2
  00034	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00037	8b ce		 mov	 ecx, esi
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL20@FindRegion@2:
  00040	8a 10		 mov	 dl, BYTE PTR [eax]
  00042	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00044	75 1a		 jne	 SHORT $LN21@FindRegion@2
  00046	84 d2		 test	 dl, dl
  00048	74 12		 je	 SHORT $LN22@FindRegion@2
  0004a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0004d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00050	75 0e		 jne	 SHORT $LN21@FindRegion@2
  00052	83 c0 02	 add	 eax, 2
  00055	83 c1 02	 add	 ecx, 2
  00058	84 d2		 test	 dl, dl
  0005a	75 e4		 jne	 SHORT $LL20@FindRegion@2
$LN22@FindRegion@2:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 14		 jmp	 SHORT $LN14@FindRegion@2
$LN21@FindRegion@2:
  00060	1b c0		 sbb	 eax, eax
  00062	83 d8 ff	 sbb	 eax, -1
  00065	eb 0d		 jmp	 SHORT $LN14@FindRegion@2
$LN15@FindRegion@2:
  00067	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0006a	56		 push	 esi
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 __stricmp
  00071	83 c4 08	 add	 esp, 8
$LN14@FindRegion@2:
  00074	85 c0		 test	 eax, eax
  00076	74 12		 je	 SHORT $LN19@FindRegion@2

; 1354 : 	while (++rgn)

  00078	8d 14 24	 lea	 edx, DWORD PTR _rgn$[esp+8]
  0007b	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00080	85 c0		 test	 eax, eax
  00082	75 9f		 jne	 SHORT $LL3@FindRegion@2
$LN2@FindRegion@2:

; 1357 : 
; 1358 : 	return 0;

  00084	33 c0		 xor	 eax, eax

; 1359 : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN19@FindRegion@2:

; 1356 : 	return rgn.value();

  0008a	8d 04 24	 lea	 eax, DWORD PTR _rgn$[esp+8]
  0008d	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value

; 1359 : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
?FindRegion@Sim@@QAEPAVSimRegion@@PBD@Z ENDP		; Sim::FindRegion
_TEXT	ENDS
PUBLIC	?SetTestMode@Sim@@QAEX_N@Z			; Sim::SetTestMode
; Function compile flags: /Ogtp
;	COMDAT ?SetTestMode@Sim@@QAEX_N@Z
_TEXT	SEGMENT
?SetTestMode@Sim@@QAEX_N@Z PROC				; Sim::SetTestMode, COMDAT
; _this$ = esi
; _t$ = eax

; 1338 : 	test_mode    = t;
; 1339 : 	Ship* pship  = GetPlayerShip();

  00000	8b ce		 mov	 ecx, esi
  00002	88 86 bc 00 00
	00		 mov	 BYTE PTR [esi+188], al
  00008	e8 00 00 00 00	 call	 ?GetPlayerShip@Sim@@QAEPAVShip@@XZ ; Sim::GetPlayerShip
  0000d	8b c8		 mov	 ecx, eax

; 1340 : 
; 1341 : 	if (pship)

  0000f	85 c9		 test	 ecx, ecx
  00011	74 25		 je	 SHORT $LN1@SetTestMod

; 1342 : 	if (IsTestMode())

  00013	80 be bc 00 00
	00 00		 cmp	 BYTE PTR [esi+188], 0

; 1343 : 	pship->SetControls(0);

  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	74 0b		 je	 SHORT $LN2@SetTestMod
  0001e	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  00024	6a 00		 push	 0
  00026	ff d0		 call	 eax

; 1346 : }

  00028	c3		 ret	 0
$LN2@SetTestMod:

; 1344 : 	else
; 1345 : 	pship->SetControls(ctrl);

  00029	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  0002f	8b 92 cc 00 00
	00		 mov	 edx, DWORD PTR [edx+204]
  00035	50		 push	 eax
  00036	ff d2		 call	 edx
$LN1@SetTestMod:

; 1346 : }

  00038	c3		 ret	 0
?SetTestMode@Sim@@QAEX_N@Z ENDP				; Sim::SetTestMode
_TEXT	ENDS
PUBLIC	?SetSelection@Sim@@QAEXPAVShip@@@Z		; Sim::SetSelection
; Function compile flags: /Ogtp
;	COMDAT ?SetSelection@Sim@@QAEXPAVShip@@@Z
_TEXT	SEGMENT
?SetSelection@Sim@@QAEXPAVShip@@@Z PROC			; Sim::SetSelection, COMDAT
; _this$ = eax
; _newsel$ = edi

; 1329 : 	if (active_region)

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	85 c0		 test	 eax, eax
  00005	74 05		 je	 SHORT $LN1@SetSelecti

; 1330 : 	active_region->SetSelection(newsel);

  00007	e9 00 00 00 00	 jmp	 ?SetSelection@SimRegion@@QAEXPAVShip@@@Z ; SimRegion::SetSelection
$LN1@SetSelecti:

; 1331 : }

  0000c	c3		 ret	 0
?SetSelection@Sim@@QAEXPAVShip@@@Z ENDP			; Sim::SetSelection
_TEXT	ENDS
PUBLIC	?AddSelection@Sim@@QAEXPAVShip@@@Z		; Sim::AddSelection
; Function compile flags: /Ogtp
;	COMDAT ?AddSelection@Sim@@QAEXPAVShip@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?AddSelection@Sim@@QAEXPAVShip@@@Z PROC			; Sim::AddSelection, COMDAT
; _this$ = eax

; 1321 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1322 : 	if (active_region)

  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN1@AddSelecti@2

; 1323 : 	active_region->AddSelection(s);

  0000a	50		 push	 eax
  0000b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000e	e8 00 00 00 00	 call	 ?AddSelection@SimRegion@@QAEXPAVShip@@@Z ; SimRegion::AddSelection
$LN1@AddSelecti@2:

; 1324 : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?AddSelection@Sim@@QAEXPAVShip@@@Z ENDP			; Sim::AddSelection
_TEXT	ENDS
PUBLIC	?IsSelected@Sim@@QAE_NPAVShip@@@Z		; Sim::IsSelected
; Function compile flags: /Ogtp
;	COMDAT ?IsSelected@Sim@@QAE_NPAVShip@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?IsSelected@Sim@@QAE_NPAVShip@@@Z PROC			; Sim::IsSelected, COMDAT
; _this$ = eax

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1296 : 	if (active_region)

  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0c		 je	 SHORT $LN1@IsSelected

; 1297 : 	return active_region->IsSelected(s);

  0000a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000d	e8 00 00 00 00	 call	 ?IsSelected@SimRegion@@QAE_NPAVShip@@@Z ; SimRegion::IsSelected

; 1300 : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN1@IsSelected:

; 1298 : 
; 1299 : 	return false;

  00016	32 c0		 xor	 al, al

; 1300 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?IsSelected@Sim@@QAE_NPAVShip@@@Z ENDP			; Sim::IsSelected
_TEXT	ENDS
PUBLIC	?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z ; Sim::CreateDebris
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\geometry.h
xdata$x	SEGMENT
__unwindtable$?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z$0
__ehfuncinfo$?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z
_TEXT	SEGMENT
$T291011 = -40						; size = 12
$T291010 = -28						; size = 12
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_model$ = 12						; size = 4
$T291009 = 16						; size = 4
_rgn$ = 16						; size = 4
_mass$ = 20						; size = 8
?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z PROC ; Sim::CreateDebris, COMDAT
; _pos$ = edx
; _vel$ = ecx

; 1139 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b 5d 10	 mov	 ebx, DWORD PTR _rgn$[ebp]
  0002b	8b f1		 mov	 esi, ecx
  0002d	8b fa		 mov	 edi, edx

; 1140 : 	Debris* debris = new(__FILE__,__LINE__) Debris(model, pos, vel, mass);

  0002f	68 e0 01 00 00	 push	 480			; 000001e0H
  00034	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00039	83 c4 04	 add	 esp, 4
  0003c	89 45 10	 mov	 DWORD PTR $T291009[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	85 c0		 test	 eax, eax
  00048	74 74		 je	 SHORT $LN6@CreateDebr
  0004a	f2 0f 10 06	 movsd	 xmm0, QWORD PTR [esi]
  0004e	f2 0f 10 4e 08	 movsd	 xmm1, QWORD PTR [esi+8]
  00053	f2 0f 10 56 10	 movsd	 xmm2, QWORD PTR [esi+16]
  00058	8b 55 0c	 mov	 edx, DWORD PTR _model$[ebp]
  0005b	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0005f	f3 0f 11 45 e4	 movss	 DWORD PTR $T291010[ebp], xmm0
  00064	f2 0f 10 07	 movsd	 xmm0, QWORD PTR [edi]
  00068	83 ec 08	 sub	 esp, 8
  0006b	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0006f	f3 0f 11 45 d8	 movss	 DWORD PTR $T291011[ebp], xmm0
  00074	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _mass$[ebp]
  00079	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0007e	8d 4d e4	 lea	 ecx, DWORD PTR $T291010[ebp]
  00081	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00085	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  00089	51		 push	 ecx
  0008a	f3 0f 11 4d e8	 movss	 DWORD PTR $T291010[ebp+4], xmm1
  0008f	f2 0f 10 4f 08	 movsd	 xmm1, QWORD PTR [edi+8]
  00094	f3 0f 11 55 ec	 movss	 DWORD PTR $T291010[ebp+8], xmm2
  00099	f2 0f 10 57 10	 movsd	 xmm2, QWORD PTR [edi+16]
  0009e	52		 push	 edx
  0009f	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  000a3	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  000a7	50		 push	 eax
  000a8	8d 7d d8	 lea	 edi, DWORD PTR $T291011[ebp]
  000ab	f3 0f 11 4d dc	 movss	 DWORD PTR $T291011[ebp+4], xmm1
  000b0	f3 0f 11 55 e0	 movss	 DWORD PTR $T291011[ebp+8], xmm2
  000b5	e8 00 00 00 00	 call	 ??0Debris@@QAE@PAVModel@@ABUVec3@@1N@Z ; Debris::Debris
  000ba	8b f0		 mov	 esi, eax
  000bc	eb 02		 jmp	 SHORT $LN7@CreateDebr
$LN6@CreateDebr:
  000be	33 f6		 xor	 esi, esi
$LN7@CreateDebr:
  000c0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 1141 : 
; 1142 : 	if (rgn)

  000c7	85 db		 test	 ebx, ebx
  000c9	74 06		 je	 SHORT $LN3@CreateDebr

; 1143 : 	rgn->InsertObject(debris);

  000cb	8b 03		 mov	 eax, DWORD PTR [ebx]
  000cd	8b cb		 mov	 ecx, ebx
  000cf	eb 0e		 jmp	 SHORT $LN21@CreateDebr
$LN3@CreateDebr:

; 1144 : 
; 1145 : 	else if (active_region)

  000d1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000d8	74 0b		 je	 SHORT $LN19@CreateDebr

; 1146 : 	active_region->InsertObject(debris);

  000da	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000dd	8b 01		 mov	 eax, DWORD PTR [ecx]
$LN21@CreateDebr:
  000df	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  000e2	56		 push	 esi
  000e3	ff d2		 call	 edx
$LN19@CreateDebr:

; 1147 : 
; 1148 : 	return debris;

  000e5	8b c6		 mov	 eax, esi

; 1149 : }

  000e7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ea	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f1	59		 pop	 ecx
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z$0:
  00000	68 74 04 00 00	 push	 1140			; 00000474H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 10	 mov	 eax, DWORD PTR $T291009[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__ehhandler$?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateDebris@Sim@@QAEPAVDebris@@ABUPoint@@0PAVModel@@NPAVSimRegion@@@Z ENDP ; Sim::CreateDebris
PUBLIC	?FindOrbitalBody@Sim@@QAEPAVOrbital@@PBD@Z	; Sim::FindOrbitalBody
; Function compile flags: /Ogtp
;	COMDAT ?FindOrbitalBody@Sim@@QAEPAVOrbital@@PBD@Z
_TEXT	SEGMENT
_iter$119322 = -8					; size = 8
?FindOrbitalBody@Sim@@QAEPAVOrbital@@PBD@Z PROC		; Sim::FindOrbitalBody, COMDAT
; _this$ = eax
; _name$ = ecx

; 1079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1080 : 	Orbital* body = 0;
; 1081 : 
; 1082 : 	if (mission) {

  00003	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [eax+192]
  00009	83 ec 08	 sub	 esp, 8
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	33 ff		 xor	 edi, edi
  00010	8b f1		 mov	 esi, ecx
  00012	85 c0		 test	 eax, eax
  00014	74 3b		 je	 SHORT $LN16@FindOrbita

; 1083 : 		ListIter<StarSystem> iter = mission->GetSystemList();

  00016	05 e0 00 00 00	 add	 eax, 224		; 000000e0H

; 1084 : 		while (++iter && !body) {

  0001b	8d 55 f8	 lea	 edx, DWORD PTR _iter$119322[ebp]
  0001e	89 45 f8	 mov	 DWORD PTR _iter$119322[ebp], eax
  00021	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iter$119322[ebp+4], -1
  00028	e8 00 00 00 00	 call	 ?next@?$ListIter@VStarSystem@@@@QAEPAVStarSystem@@XZ ; ListIter<StarSystem>::next
  0002d	85 c0		 test	 eax, eax
  0002f	74 20		 je	 SHORT $LN16@FindOrbita
$LL2@FindOrbita:
  00031	85 ff		 test	 edi, edi
  00033	75 1c		 jne	 SHORT $LN16@FindOrbita

; 1085 : 			StarSystem* sys = iter.value();

  00035	8d 45 f8	 lea	 eax, DWORD PTR _iter$119322[ebp]
  00038	e8 00 00 00 00	 call	 ?value@?$ListIter@VStarSystem@@@@QAEPAVStarSystem@@XZ ; ListIter<StarSystem>::value

; 1086 : 			body = sys->FindOrbital(name);

  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?FindOrbital@StarSystem@@QAEPAVOrbital@@PBD@Z ; StarSystem::FindOrbital
  00043	8d 55 f8	 lea	 edx, DWORD PTR _iter$119322[ebp]
  00046	8b f8		 mov	 edi, eax
  00048	e8 00 00 00 00	 call	 ?next@?$ListIter@VStarSystem@@@@QAEPAVStarSystem@@XZ ; ListIter<StarSystem>::next
  0004d	85 c0		 test	 eax, eax
  0004f	75 e0		 jne	 SHORT $LL2@FindOrbita
$LN16@FindOrbita:

; 1087 : 		}
; 1088 : 	}
; 1089 : 
; 1090 : 	return body;

  00051	8b c7		 mov	 eax, edi

; 1091 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?FindOrbitalBody@Sim@@QAEPAVOrbital@@PBD@Z ENDP		; Sim::FindOrbitalBody
_TEXT	ENDS
PUBLIC	?FindShip@Sim@@QAEPAVShip@@PBD0@Z		; Sim::FindShip
; Function compile flags: /Ogtp
;	COMDAT ?FindShip@Sim@@QAEPAVShip@@PBD0@Z
_TEXT	SEGMENT
_rgn$119277 = -8					; size = 8
_this$ = 8						; size = 4
_name$ = 12						; size = 4
?FindShip@Sim@@QAEPAVShip@@PBD0@Z PROC			; Sim::FindShip, COMDAT
; _rgn_name$ = eax

; 1017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR _name$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b f0		 mov	 esi, eax

; 1018 : 	Ship* ship = 0;

  00011	33 ff		 xor	 edi, edi

; 1019 : 
; 1020 : 	if (rgn_name) {

  00013	85 f6		 test	 esi, esi
  00015	74 19		 je	 SHORT $LN16@FindShip@2

; 1021 : 		SimRegion* rgn = FindRegion(rgn_name);

  00017	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?FindRegion@Sim@@QAEPAVSimRegion@@PBD@Z ; Sim::FindRegion

; 1022 : 		if (rgn)

  0001f	85 c0		 test	 eax, eax
  00021	74 0d		 je	 SHORT $LN16@FindShip@2

; 1023 : 		ship = rgn->FindShip(name);

  00023	53		 push	 ebx
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?FindShip@SimRegion@@QAEPAVShip@@PBD@Z ; SimRegion::FindShip
  0002a	8b f8		 mov	 edi, eax

; 1024 : 	}
; 1025 : 
; 1026 : 	if (!ship) {

  0002c	85 ff		 test	 edi, edi
  0002e	75 45		 jne	 SHORT $LN1@FindShip@2
$LN16@FindShip@2:

; 1027 : 		ListIter<SimRegion> rgn = regions;

  00030	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 c0 58	 add	 eax, 88			; 00000058H

; 1028 : 		while (++rgn && !ship)

  00036	8d 54 24 10	 lea	 edx, DWORD PTR _rgn$119277[esp+24]
  0003a	89 44 24 10	 mov	 DWORD PTR _rgn$119277[esp+24], eax
  0003e	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _rgn$119277[esp+28], -1
  00046	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  0004b	85 c0		 test	 eax, eax
  0004d	74 24		 je	 SHORT $LN18@FindShip@2
  0004f	90		 npad	 1
$LL2@FindShip@2:
  00050	85 ff		 test	 edi, edi
  00052	75 1f		 jne	 SHORT $LN18@FindShip@2

; 1029 : 		ship = rgn->FindShip(name);

  00054	8d 44 24 10	 lea	 eax, DWORD PTR _rgn$119277[esp+24]
  00058	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  0005d	53		 push	 ebx
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?FindShip@SimRegion@@QAEPAVShip@@PBD@Z ; SimRegion::FindShip
  00064	8d 54 24 10	 lea	 edx, DWORD PTR _rgn$119277[esp+24]
  00068	8b f8		 mov	 edi, eax
  0006a	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  0006f	85 c0		 test	 eax, eax
  00071	75 dd		 jne	 SHORT $LL2@FindShip@2
$LN18@FindShip@2:

; 1030 : 	}
; 1031 : 
; 1032 : 	return ship;

  00073	8b c7		 mov	 eax, edi
$LN1@FindShip@2:

; 1033 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
?FindShip@Sim@@QAEPAVShip@@PBD0@Z ENDP			; Sim::FindShip
_TEXT	ENDS
PUBLIC	?FindElement@Sim@@QAEPAVElement@@PBD@Z		; Sim::FindElement
;	COMDAT xdata$x
; File c:\matrix games\dev\foundationex\text.h
xdata$x	SEGMENT
__unwindtable$?FindElement@Sim@@QAEPAVElement@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindElement@Sim@@QAEPAVElement@@PBD@Z$0
__ehfuncinfo$?FindElement@Sim@@QAEPAVElement@@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindElement@Sim@@QAEPAVElement@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?FindElement@Sim@@QAEPAVElement@@PBD@Z
_TEXT	SEGMENT
_ename$119222 = -32					; size = 8
_iter$ = -24						; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?FindElement@Sim@@QAEPAVElement@@PBD@Z PROC		; Sim::FindElement, COMDAT
; _name$ = esi

; 953  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?FindElement@Sim@@QAEPAVElement@@PBD@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 14	 sub	 esp, 20			; 00000014H
  00017	53		 push	 ebx
  00018	57		 push	 edi
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c4		 xor	 eax, esp
  00020	50		 push	 eax
  00021	8d 44 24 20	 lea	 eax, DWORD PTR __$EHRec$[esp+44]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 954  : 	ListIter<Element> iter = elements;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00033	83 cb ff	 or	 ebx, -1

; 955  : 
; 956  : 	while (++iter) {

  00036	8d 54 24 14	 lea	 edx, DWORD PTR _iter$[esp+44]
  0003a	89 44 24 14	 mov	 DWORD PTR _iter$[esp+44], eax
  0003e	89 5c 24 18	 mov	 DWORD PTR _iter$[esp+48], ebx
  00042	e8 00 00 00 00	 call	 ?next@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::next
  00047	85 c0		 test	 eax, eax
  00049	74 7b		 je	 SHORT $LN2@FindElemen
  0004b	eb 03 8d 49 00	 npad	 5
$LL3@FindElemen:

; 957  : 		Element* elem  = iter.value();

  00050	8d 44 24 14	 lea	 eax, DWORD PTR _iter$[esp+44]
  00054	e8 00 00 00 00	 call	 ?value@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::value
  00059	8b f8		 mov	 edi, eax

; 958  : 		Text     ename = elem->Name();

  0005b	8d 4f 2c	 lea	 ecx, DWORD PTR [edi+44]
  0005e	51		 push	 ecx
  0005f	8d 4c 24 10	 lea	 ecx, DWORD PTR _ename$119222[esp+48]
  00063	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text

; 959  : 
; 960  : 		if (ename == name)

  00068	8b 54 24 10	 mov	 edx, DWORD PTR _ename$119222[esp+48]
  0006c	80 7a 10 00	 cmp	 BYTE PTR [edx+16], 0
  00070	8b 44 24 0c	 mov	 eax, DWORD PTR _ename$119222[esp+44]
  00074	74 28		 je	 SHORT $LN16@FindElemen
  00076	8b ce		 mov	 ecx, esi
$LL22@FindElemen:
  00078	8a 10		 mov	 dl, BYTE PTR [eax]
  0007a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0007c	75 1a		 jne	 SHORT $LN23@FindElemen
  0007e	84 d2		 test	 dl, dl
  00080	74 12		 je	 SHORT $LN24@FindElemen
  00082	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00085	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00088	75 0e		 jne	 SHORT $LN23@FindElemen
  0008a	83 c0 02	 add	 eax, 2
  0008d	83 c1 02	 add	 ecx, 2
  00090	84 d2		 test	 dl, dl
  00092	75 e4		 jne	 SHORT $LL22@FindElemen
$LN24@FindElemen:
  00094	33 c0		 xor	 eax, eax
  00096	eb 10		 jmp	 SHORT $LN15@FindElemen
$LN23@FindElemen:
  00098	1b c0		 sbb	 eax, eax
  0009a	1b c3		 sbb	 eax, ebx
  0009c	eb 0a		 jmp	 SHORT $LN15@FindElemen
$LN16@FindElemen:
  0009e	56		 push	 esi
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 __stricmp
  000a5	83 c4 08	 add	 esp, 8
$LN15@FindElemen:

; 962  : 	}

  000a8	89 5c 24 28	 mov	 DWORD PTR __$EHRec$[esp+52], ebx
  000ac	8d 4c 24 0c	 lea	 ecx, DWORD PTR _ename$119222[esp+44]
  000b0	85 c0		 test	 eax, eax
  000b2	74 28		 je	 SHORT $LN20@FindElemen
  000b4	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  000b9	8d 54 24 14	 lea	 edx, DWORD PTR _iter$[esp+44]
  000bd	e8 00 00 00 00	 call	 ?next@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::next
  000c2	85 c0		 test	 eax, eax
  000c4	75 8a		 jne	 SHORT $LL3@FindElemen
$LN2@FindElemen:

; 963  : 
; 964  : 	return 0;

  000c6	33 c0		 xor	 eax, eax

; 965  : }

  000c8	8b 4c 24 20	 mov	 ecx, DWORD PTR __$EHRec$[esp+44]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5b		 pop	 ebx
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
$LN20@FindElemen:

; 961  : 		return elem;

  000dc	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  000e1	8b c7		 mov	 eax, edi

; 965  : }

  000e3	8b 4c 24 20	 mov	 ecx, DWORD PTR __$EHRec$[esp+44]
  000e7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ee	59		 pop	 ecx
  000ef	5f		 pop	 edi
  000f0	5b		 pop	 ebx
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindElement@Sim@@QAEPAVElement@@PBD@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _ename$119222[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__ehhandler$?FindElement@Sim@@QAEPAVElement@@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 e4	 lea	 eax, DWORD PTR [edx-28]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FindElement@Sim@@QAEPAVElement@@PBD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FindElement@Sim@@QAEPAVElement@@PBD@Z ENDP		; Sim::FindElement
PUBLIC	?DestroyElement@Sim@@QAEXPAVElement@@@Z		; Sim::DestroyElement
; Function compile flags: /Ogtp
;	COMDAT ?DestroyElement@Sim@@QAEXPAVElement@@@Z
_TEXT	SEGMENT
?DestroyElement@Sim@@QAEXPAVElement@@@Z PROC		; Sim::DestroyElement, COMDAT
; _this$ = ecx
; _elem$ = eax

; 944  : {

  00000	56		 push	 esi

; 945  : 	if (elements.contains(elem))

  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi
  00004	8d 8e 88 00 00
	00		 lea	 ecx, DWORD PTR [esi+136]
  0000a	8b f8		 mov	 edi, eax
  0000c	e8 00 00 00 00	 call	 ?contains@?$List@VElement@@@@QBE_NPBVElement@@@Z ; List<Element>::contains
  00011	84 c0		 test	 al, al
  00013	74 0b		 je	 SHORT $LN1@DestroyEle

; 946  : 	elements.remove(elem);

  00015	8d 86 88 00 00
	00		 lea	 eax, DWORD PTR [esi+136]
  0001b	e8 00 00 00 00	 call	 ?remove@?$List@VElement@@@@QAEPAVElement@@PBV2@@Z ; List<Element>::remove
$LN1@DestroyEle:

; 947  : 
; 948  : 	delete elem;

  00020	85 ff		 test	 edi, edi
  00022	74 0a		 je	 SHORT $LN4@DestroyEle
  00024	8b 07		 mov	 eax, DWORD PTR [edi]
  00026	8b 10		 mov	 edx, DWORD PTR [eax]
  00028	6a 01		 push	 1
  0002a	8b cf		 mov	 ecx, edi
  0002c	ff d2		 call	 edx
$LN4@DestroyEle:

; 949  : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
?DestroyElement@Sim@@QAEXPAVElement@@@Z ENDP		; Sim::DestroyElement
_TEXT	ENDS
PUBLIC	?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z	; Sim::CreateElement
;	COMDAT xdata$x
; File c:\matrix games\dev\foundationex\memdebug.h
xdata$x	SEGMENT
__unwindtable$?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z$0
__ehfuncinfo$?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z
_TEXT	SEGMENT
$T291132 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_callsign$ = 12						; size = 4
_IFF$ = 16						; size = 4
_type$ = 20						; size = 4
?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z PROC		; Sim::CreateElement, COMDAT

; 936  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 937  : 	Element* elem = new(__FILE__,__LINE__) Element(callsign, IFF, type);

  00025	68 e8 00 00 00	 push	 232			; 000000e8H
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f0	 mov	 DWORD PTR $T291132[ebp], eax
  00035	33 ff		 xor	 edi, edi
  00037	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  0003a	3b c7		 cmp	 eax, edi
  0003c	74 13		 je	 SHORT $LN3@CreateElem
  0003e	8b 4d 10	 mov	 ecx, DWORD PTR _IFF$[ebp]
  00041	8b 7d 0c	 mov	 edi, DWORD PTR _callsign$[ebp]
  00044	51		 push	 ecx
  00045	8b 4d 14	 mov	 ecx, DWORD PTR _type$[ebp]
  00048	8b f0		 mov	 esi, eax
  0004a	e8 00 00 00 00	 call	 ??0Element@@QAE@PBDHH@Z	; Element::Element
  0004f	8b f8		 mov	 edi, eax
$LN3@CreateElem:

; 938  : 	elements.append(elem);

  00051	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00054	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00059	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00060	e8 00 00 00 00	 call	 ?append@?$List@VElement@@@@QAEXPBVElement@@@Z ; List<Element>::append

; 939  : 	return elem;

  00065	8b c7		 mov	 eax, edi

; 940  : }

  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z$0:
  00000	68 a9 03 00 00	 push	 937			; 000003a9H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 f0	 mov	 eax, DWORD PTR $T291132[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__ehhandler$?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z ENDP		; Sim::CreateElement
PUBLIC	?FindAvailCallsign@Sim@@QAEPBDH@Z		; Sim::FindAvailCallsign
; Function compile flags: /Ogtp
;	COMDAT ?FindAvailCallsign@Sim@@QAEPBDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_IFF$ = 12						; size = 4
?FindAvailCallsign@Sim@@QAEPBDH@Z PROC			; Sim::FindAvailCallsign, COMDAT

; 921  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _IFF$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi

; 922  : 	const char* call = "Unidentified";
; 923  : 
; 924  : 	for (int i = 0; i < 32; i++) {

  00009	33 ff		 xor	 edi, edi
  0000b	eb 03 8d 49 00	 npad	 5
$LL4@FindAvailC:

; 925  : 		call = Callsign::GetCallsign(IFF);

  00010	8b f3		 mov	 esi, ebx
  00012	e8 00 00 00 00	 call	 ?GetCallsign@Callsign@@SAPBDH@Z ; Callsign::GetCallsign
  00017	8b f0		 mov	 esi, eax

; 926  : 
; 927  : 		if (!FindElement(call))

  00019	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?FindElement@Sim@@QAEPAVElement@@PBD@Z ; Sim::FindElement
  00022	85 c0		 test	 eax, eax
  00024	74 06		 je	 SHORT $LN10@FindAvailC

; 922  : 	const char* call = "Unidentified";
; 923  : 
; 924  : 	for (int i = 0; i < 32; i++) {

  00026	47		 inc	 edi
  00027	83 ff 20	 cmp	 edi, 32			; 00000020H
  0002a	7c e4		 jl	 SHORT $LL4@FindAvailC
$LN10@FindAvailC:

; 928  : 		break;
; 929  : 	}
; 930  : 
; 931  : 	return call;
; 932  : }

  0002c	5f		 pop	 edi
  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
?FindAvailCallsign@Sim@@QAEPBDH@Z ENDP			; Sim::FindAvailCallsign
_TEXT	ENDS
PUBLIC	?LoadMission@Sim@@QAEXPAVMission@@_N@Z		; Sim::LoadMission
;	COMDAT xdata$x
; File c:\matrix games\dev\foundationex\list.h
xdata$x	SEGMENT
__unwindtable$?LoadMission@Sim@@QAEXPAVMission@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadMission@Sim@@QAEXPAVMission@@_N@Z$0
__ehfuncinfo$?LoadMission@Sim@@QAEXPAVMission@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadMission@Sim@@QAEXPAVMission@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?LoadMission@Sim@@QAEXPAVMission@@_N@Z
_TEXT	SEGMENT
_all_models$118366 = -52				; size = 12
_elem_iter$118400 = -40					; size = 8
_model_iter$118448 = -32				; size = 8
_surf_iter$118487 = -24					; size = 8
__$EHRec$ = -12						; size = 12
tv89 = 8						; size = 4
_preload_textures$ = 8					; size = 1
?LoadMission@Sim@@QAEXPAVMission@@_N@Z PROC		; Sim::LoadMission, COMDAT
; _this$ = edx
; _m$ = ecx

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadMission@Sim@@QAEXPAVMission@@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	8b f2		 mov	 esi, edx

; 299  : 	cam_dir = CameraDirector::GetInstance();

  0002c	e8 00 00 00 00	 call	 ?GetInstance@CameraDirector@@SAPAV1@XZ ; CameraDirector::GetInstance

; 300  : 
; 301  : 	if (!mission) {

  00031	83 be c0 00 00
	00 00		 cmp	 DWORD PTR [esi+192], 0
  00038	89 46 54	 mov	 DWORD PTR [esi+84], eax
  0003b	0f 85 17 01 00
	00		 jne	 $LN39@LoadMissio

; 302  : 		mission = m;
; 303  : 		mission->SetActive(true);
; 304  : 
; 305  : 		if (preload_textures) {

  00041	80 7d 08 00	 cmp	 BYTE PTR _preload_textures$[ebp], 0
  00045	89 be c0 00 00
	00		 mov	 DWORD PTR [esi+192], edi
  0004b	c6 87 b9 00 00
	00 01		 mov	 BYTE PTR [edi+185], 1
  00052	0f 84 00 01 00
	00		 je	 $LN39@LoadMissio

; 306  : 			Video*         video = Game::GetVideo();

  00058	e8 00 00 00 00	 call	 ?GetVideo@Game@@SAPAVVideo@@XZ ; Game::GetVideo

; 307  : 			List<Model>    all_models;

  0005d	33 ff		 xor	 edi, edi
  0005f	8b d8		 mov	 ebx, eax
  00061	89 7d cc	 mov	 DWORD PTR _all_models$118366[ebp], edi
  00064	89 7d d0	 mov	 DWORD PTR _all_models$118366[ebp+4], edi
  00067	89 7d d4	 mov	 DWORD PTR _all_models$118366[ebp+8], edi
  0006a	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi

; 308  : 			//List<Bitmap>   all_textures;
; 309  : 
; 310  : 			ListIter<MissionElement> elem_iter = mission->GetElements();

  0006d	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00073	05 ec 00 00 00	 add	 eax, 236		; 000000ecH

; 311  : 			while (++elem_iter) {

  00078	8d 55 d8	 lea	 edx, DWORD PTR _elem_iter$118400[ebp]
  0007b	89 45 d8	 mov	 DWORD PTR _elem_iter$118400[ebp], eax
  0007e	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _elem_iter$118400[ebp+4], -1
  00085	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionElement@@@@QAEPAVMissionElement@@XZ ; ListIter<MissionElement>::next
  0008a	85 c0		 test	 eax, eax
  0008c	0f 84 ba 00 00
	00		 je	 $LN10@LoadMissio
$LL11@LoadMissio:

; 312  : 				MissionElement*   elem   = elem_iter.value();

  00092	8d 45 d8	 lea	 eax, DWORD PTR _elem_iter$118400[ebp]
  00095	e8 00 00 00 00	 call	 ?value@?$ListIter@VMissionElement@@@@QAEPAVMissionElement@@XZ ; ListIter<MissionElement>::value

; 313  : 				const ShipDesign* design = elem->GetDesign();

  0009a	8b 40 30	 mov	 eax, DWORD PTR [eax+48]

; 314  : 
; 315  : 				if (design) {

  0009d	3b c7		 cmp	 eax, edi
  0009f	0f 84 97 00 00
	00		 je	 $LN6@LoadMissio

; 316  : 					for (int i = 0; i < 4; i++) {

  000a5	8d b8 2c 01 00
	00		 lea	 edi, DWORD PTR [eax+300]
  000ab	c7 45 08 04 00
	00 00		 mov	 DWORD PTR tv89[ebp], 4
$LN8@LoadMissio:

; 317  : 						List<Model>& models = (List<Model>&) design->models[i]; // cast-away const
; 318  : 
; 319  : 						ListIter<Model> model_iter = models;
; 320  : 						while (++model_iter) {

  000b2	8d 4d e0	 lea	 ecx, DWORD PTR _model_iter$118448[ebp]
  000b5	89 7d e0	 mov	 DWORD PTR _model_iter$118448[ebp], edi
  000b8	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _model_iter$118448[ebp+4], -1
  000bf	e8 00 00 00 00	 call	 ?next@?$ListIter@VModel@@@@QAEPAVModel@@XZ ; ListIter<Model>::next
  000c4	85 c0		 test	 eax, eax
  000c6	74 66		 je	 SHORT $LN7@LoadMissio
$LL5@LoadMissio:

; 321  : 							Model* model = model_iter.value();

  000c8	8d 45 e0	 lea	 eax, DWORD PTR _model_iter$118448[ebp]
  000cb	e8 00 00 00 00	 call	 ?value@?$ListIter@VModel@@@@QAEPAVModel@@XZ ; ListIter<Model>::value
  000d0	8b f0		 mov	 esi, eax

; 322  : 							if (!all_models.contains(model)) {

  000d2	56		 push	 esi
  000d3	8d 4d cc	 lea	 ecx, DWORD PTR _all_models$118366[ebp]
  000d6	e8 00 00 00 00	 call	 ?contains@?$List@VModel@@@@QBE_NPBVModel@@@Z ; List<Model>::contains
  000db	84 c0		 test	 al, al
  000dd	75 43		 jne	 SHORT $LN1@LoadMissio

; 323  : 								all_models.append(model);

  000df	56		 push	 esi
  000e0	8d 4d cc	 lea	 ecx, DWORD PTR _all_models$118366[ebp]
  000e3	e8 00 00 00 00	 call	 ?append@?$List@VModel@@@@QAEXPBVModel@@@Z ; List<Model>::append

; 324  : 								//model->GetAllTextures(all_textures);
; 325  : 
; 326  : 								ListIter<Surface> surf_iter = model->GetSurfaces();

  000e8	83 c6 40	 add	 esi, 64			; 00000040H

; 327  : 								while (++surf_iter) {

  000eb	8d 4d e8	 lea	 ecx, DWORD PTR _surf_iter$118487[ebp]
  000ee	89 75 e8	 mov	 DWORD PTR _surf_iter$118487[ebp], esi
  000f1	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _surf_iter$118487[ebp+4], -1
  000f8	e8 00 00 00 00	 call	 ?next@?$ListIter@VSurface@@@@QAEPAVSurface@@XZ ; ListIter<Surface>::next
  000fd	85 c0		 test	 eax, eax
  000ff	74 21		 je	 SHORT $LN1@LoadMissio
$LL2@LoadMissio:

; 328  : 									Surface* surface = surf_iter.value();
; 329  : 									video->PreloadSurface(surface);

  00101	8b 33		 mov	 esi, DWORD PTR [ebx]
  00103	8d 4d e8	 lea	 ecx, DWORD PTR _surf_iter$118487[ebp]
  00106	e8 00 00 00 00	 call	 ?value@?$ListIter@VSurface@@@@QAEPAVSurface@@XZ ; ListIter<Surface>::value
  0010b	8b 96 e8 00 00
	00		 mov	 edx, DWORD PTR [esi+232]
  00111	50		 push	 eax
  00112	8b cb		 mov	 ecx, ebx
  00114	ff d2		 call	 edx
  00116	8d 4d e8	 lea	 ecx, DWORD PTR _surf_iter$118487[ebp]
  00119	e8 00 00 00 00	 call	 ?next@?$ListIter@VSurface@@@@QAEPAVSurface@@XZ ; ListIter<Surface>::next
  0011e	85 c0		 test	 eax, eax
  00120	75 df		 jne	 SHORT $LL2@LoadMissio
$LN1@LoadMissio:

; 317  : 						List<Model>& models = (List<Model>&) design->models[i]; // cast-away const
; 318  : 
; 319  : 						ListIter<Model> model_iter = models;
; 320  : 						while (++model_iter) {

  00122	8d 4d e0	 lea	 ecx, DWORD PTR _model_iter$118448[ebp]
  00125	e8 00 00 00 00	 call	 ?next@?$ListIter@VModel@@@@QAEPAVModel@@XZ ; ListIter<Model>::next
  0012a	85 c0		 test	 eax, eax
  0012c	75 9a		 jne	 SHORT $LL5@LoadMissio
$LN7@LoadMissio:

; 316  : 					for (int i = 0; i < 4; i++) {

  0012e	83 c7 0c	 add	 edi, 12			; 0000000cH
  00131	ff 4d 08	 dec	 DWORD PTR tv89[ebp]
  00134	0f 85 78 ff ff
	ff		 jne	 $LN8@LoadMissio
  0013a	33 ff		 xor	 edi, edi
$LN6@LoadMissio:

; 311  : 			while (++elem_iter) {

  0013c	8d 55 d8	 lea	 edx, DWORD PTR _elem_iter$118400[ebp]
  0013f	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionElement@@@@QAEPAVMissionElement@@XZ ; ListIter<MissionElement>::next
  00144	85 c0		 test	 eax, eax
  00146	0f 85 46 ff ff
	ff		 jne	 $LL11@LoadMissio
$LN10@LoadMissio:

; 330  : 								}
; 331  : 							}
; 332  : 						}
; 333  : 					}
; 334  : 				}
; 335  : 			}
; 336  : 
; 337  : 			/*
; 338  : 		if (video && all_textures.size() > 0) {
; 339  : 			::Print("Preloading %d textures into video texture cache\n", all_textures.size());
; 340  : 			ListIter<Bitmap> bmp_iter = all_textures;
; 341  : 			while (++bmp_iter) {
; 342  : 			Bitmap* bmp = bmp_iter.value();
; 343  : 			video->PreloadTexture(bmp);
; 344  : 			}
; 345  : 		}
; 346  : 		*/
; 347  : 		}

  0014c	8b 45 d4	 mov	 eax, DWORD PTR _all_models$118366[ebp+8]
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00155	83 c4 04	 add	 esp, 4
$LN39@LoadMissio:

; 348  : 	}
; 349  : }

  00158	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0015b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00162	59		 pop	 ecx
  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	5b		 pop	 ebx
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadMission@Sim@@QAEXPAVMission@@_N@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _all_models$118366[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$List@VModel@@@@QAE@XZ ; List<Model>::~List<Model>
__ehhandler$?LoadMission@Sim@@QAEXPAVMission@@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadMission@Sim@@QAEXPAVMission@@_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadMission@Sim@@QAEXPAVMission@@_N@Z ENDP		; Sim::LoadMission
PUBLIC	?CommitMission@SimRegion@@IAEXXZ		; SimRegion::CommitMission
;	COMDAT xdata$x
; File c:\matrix games\dev\stars45\combatunit.h
xdata$x	SEGMENT
__unwindtable$?CommitMission@SimRegion@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CommitMission@SimRegion@@IAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CommitMission@SimRegion@@IAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CommitMission@SimRegion@@IAEXXZ$5
__ehfuncinfo$?CommitMission@SimRegion@@IAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?CommitMission@SimRegion@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CommitMission@SimRegion@@IAEXXZ
_TEXT	SEGMENT
_u_loc$121417 = -68					; size = 24
$T331595 = -44						; size = 8
$T331587 = -36						; size = 8
$T331544 = -28						; size = 8
_i$121410 = -20						; size = 4
__$EHRec$ = -12						; size = 12
tv370 = 8						; size = 4
_this$ = 8						; size = 4
?CommitMission@SimRegion@@IAEXXZ PROC			; SimRegion::CommitMission, COMDAT

; 3753 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CommitMission@SimRegion@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 3754 : 	for (int i = 0; i < dead_ships.size(); i++) {

  00028	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0002b	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  0002e	33 ff		 xor	 edi, edi
  00030	85 c0		 test	 eax, eax
  00032	7e 37		 jle	 SHORT $LN16@CommitMiss
$LL18@CommitMiss:

; 3755 : 		Ship* s = dead_ships[i];

  00034	57		 push	 edi
  00035	8d 43 70	 lea	 eax, DWORD PTR [ebx+112]
  00038	e8 00 00 00 00	 call	 ??A?$List@VShip@@@@QAEAAPAVShip@@H@Z ; List<Ship>::operator[]
  0003d	8b 30		 mov	 esi, DWORD PTR [eax]

; 3756 : 
; 3757 : 		if (s->GetCombatUnit() && s->GetFlightPhase() != Ship::DOCKED)

  0003f	83 be e4 03 00
	00 00		 cmp	 DWORD PTR [esi+996], 0
  00046	74 1d		 je	 SHORT $LN17@CommitMiss
  00048	8b 06		 mov	 eax, DWORD PTR [esi]
  0004a	8b 90 d4 00 00
	00		 mov	 edx, DWORD PTR [eax+212]
  00050	8b ce		 mov	 ecx, esi
  00052	ff d2		 call	 edx
  00054	85 c0		 test	 eax, eax
  00056	74 0d		 je	 SHORT $LN17@CommitMiss

; 3758 : 		s->GetCombatUnit()->Kill(1);

  00058	8b 8e e4 03 00
	00		 mov	 ecx, DWORD PTR [esi+996]
  0005e	6a 01		 push	 1
  00060	e8 00 00 00 00	 call	 ?Kill@CombatUnit@@QAEHH@Z ; CombatUnit::Kill
$LN17@CommitMiss:

; 3754 : 	for (int i = 0; i < dead_ships.size(); i++) {

  00065	47		 inc	 edi
  00066	3b 7b 70	 cmp	 edi, DWORD PTR [ebx+112]
  00069	7c c9		 jl	 SHORT $LL18@CommitMiss
$LN16@CommitMiss:

; 3759 : 	}
; 3760 : 
; 3761 : 	for (int i = 0; i < ships.size(); i++) {

  0006b	8b c3		 mov	 eax, ebx
  0006d	33 c9		 xor	 ecx, ecx
  0006f	83 c0 4c	 add	 eax, 76			; 0000004cH
  00072	89 4d ec	 mov	 DWORD PTR _i$121410[ebp], ecx
  00075	89 45 08	 mov	 DWORD PTR tv370[ebp], eax
  00078	39 08		 cmp	 DWORD PTR [eax], ecx
  0007a	0f 8e a0 01 00
	00		 jle	 $LN12@CommitMiss
$LL14@CommitMiss:

; 3762 : 		Ship*       s = ships[i];

  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ??A?$List@VShip@@@@QAEAAPAVShip@@H@Z ; List<Ship>::operator[]
  00086	8b 18		 mov	 ebx, DWORD PTR [eax]

; 3763 : 		CombatUnit* u = s->GetCombatUnit();

  00088	8b bb e4 03 00
	00		 mov	 edi, DWORD PTR [ebx+996]

; 3764 : 
; 3765 : 		if (u) {

  0008e	85 ff		 test	 edi, edi
  00090	0f 84 78 01 00
	00		 je	 $LN13@CommitMiss

; 3766 : 			Point u_loc = s->Location().OtherHand();

  00096	f2 0f 10 43 48	 movsd	 xmm0, QWORD PTR [ebx+72]
  0009b	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  000a3	f2 0f 10 4b 50	 movsd	 xmm1, QWORD PTR [ebx+80]
  000a8	f2 0f 10 53 58	 movsd	 xmm2, QWORD PTR [ebx+88]
  000ad	f2 0f 11 45 bc	 movsd	 QWORD PTR _u_loc$121417[ebp], xmm0

; 3767 : 			if (u_loc.z > 20e3)

  000b2	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _BANK_SIZE
  000ba	66 0f 2f c8	 comisd	 xmm1, xmm0
  000be	f2 0f 11 55 c4	 movsd	 QWORD PTR _u_loc$121417[ebp+8], xmm2
  000c3	f2 0f 11 4d cc	 movsd	 QWORD PTR _u_loc$121417[ebp+16], xmm1

; 3768 : 			u_loc.z = 20e3;

  000c8	77 0e		 ja	 SHORT $LN90@CommitMiss

; 3769 : 			else if (u_loc.z < -20e3)

  000ca	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@c0d3880000000000
  000d2	66 0f 2f c1	 comisd	 xmm0, xmm1
  000d6	76 05		 jbe	 SHORT $LN8@CommitMiss
$LN90@CommitMiss:

; 3770 : 			u_loc.z = -20e3;

  000d8	f2 0f 11 45 cc	 movsd	 QWORD PTR _u_loc$121417[ebp+16], xmm0
$LN8@CommitMiss:

; 3771 : 
; 3772 : 			if (u->IsStarship()) {

  000dd	8b c7		 mov	 eax, edi
  000df	e8 00 00 00 00	 call	 ?IsStarship@CombatUnit@@QBE_NXZ ; CombatUnit::IsStarship
  000e4	84 c0		 test	 al, al
  000e6	74 44		 je	 SHORT $LN7@CommitMiss

; 3773 : 				u->SetRegion(s->GetRegion()->Name());

  000e8	8b 03		 mov	 eax, DWORD PTR [ebx]
  000ea	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  000f0	8b cb		 mov	 ecx, ebx
  000f2	ff d2		 call	 edx
  000f4	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000f7	50		 push	 eax
  000f8	8d 4d e4	 lea	 ecx, DWORD PTR $T331544[ebp]
  000fb	e8 00 00 00 00	 call	 ??0Text@@QAE@PBD@Z	; Text::Text
  00100	8d 45 e4	 lea	 eax, DWORD PTR $T331544[ebp]
  00103	50		 push	 eax
  00104	8d 4f 3c	 lea	 ecx, DWORD PTR [edi+60]
  00107	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0010e	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@ABV0@@Z ; Text::operator=
  00113	8d 4d e4	 lea	 ecx, DWORD PTR $T331544[ebp]
  00116	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0011d	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text

; 3774 : 				u->MoveTo(u_loc);

  00122	8d 55 bc	 lea	 edx, DWORD PTR _u_loc$121417[ebp]
  00125	8b c7		 mov	 eax, edi
  00127	e8 00 00 00 00	 call	 ?MoveTo@CombatUnit@@QAEXABUPoint@@@Z ; CombatUnit::MoveTo
$LN7@CommitMiss:

; 3775 : 			}
; 3776 : 
; 3777 : 			if (!u->IsDropship()) {

  0012c	8b c7		 mov	 eax, edi
  0012e	e8 00 00 00 00	 call	 ?IsDropship@CombatUnit@@QBE_NXZ ; CombatUnit::IsDropship
  00133	84 c0		 test	 al, al
  00135	75 3d		 jne	 SHORT $LN57@CommitMiss

; 3778 : 				if (s->Integrity() < 1)

  00137	f3 0f 10 8b b8
	01 00 00	 movss	 xmm1, DWORD PTR [ebx+440]
  0013f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00147	0f 2f c1	 comiss	 xmm0, xmm1
  0014a	76 0b		 jbe	 SHORT $LN5@CommitMiss

; 3779 : 				u->Kill(1);

  0014c	6a 01		 push	 1
  0014e	8b cf		 mov	 ecx, edi
  00150	e8 00 00 00 00	 call	 ?Kill@CombatUnit@@QAEHH@Z ; CombatUnit::Kill

; 3780 : 				else

  00155	eb 1d		 jmp	 SHORT $LN57@CommitMiss
$LN5@CommitMiss:

; 3781 : 				u->SetSustainedDamage(s->Design()->integrity - s->Integrity());

  00157	8b 83 00 02 00
	00		 mov	 eax, DWORD PTR [ebx+512]
  0015d	f3 0f 10 80 24
	02 00 00	 movss	 xmm0, DWORD PTR [eax+548]
  00165	0f 5a c0	 cvtps2pd xmm0, xmm0
  00168	0f 5a c9	 cvtps2pd xmm1, xmm1
  0016b	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0016f	f2 0f 11 47 78	 movsd	 QWORD PTR [edi+120], xmm0
$LN57@CommitMiss:

; 3782 : 			}
; 3783 : 
; 3784 : 			CombatGroup* g = u->GetCombatGroup();

  00174	8b b7 9c 00 00
	00		 mov	 esi, DWORD PTR [edi+156]

; 3785 : 			if (g && g->Type() > CombatGroup::FLEET && g->GetFirstUnit() == u) {

  0017a	85 f6		 test	 esi, esi
  0017c	0f 84 8c 00 00
	00		 je	 $LN13@CommitMiss
  00182	83 3e 07	 cmp	 DWORD PTR [esi], 7
  00185	0f 8e 83 00 00
	00		 jle	 $LN13@CommitMiss
  0018b	e8 00 00 00 00	 call	 ?GetFirstUnit@CombatGroup@@QAEPAVCombatUnit@@XZ ; CombatGroup::GetFirstUnit
  00190	3b c7		 cmp	 eax, edi
  00192	75 7a		 jne	 SHORT $LN13@CommitMiss

; 3786 : 				if (!g->IsZoneLocked())

  00194	83 be 94 00 00
	00 00		 cmp	 DWORD PTR [esi+148], 0
  0019b	74 09		 je	 SHORT $LN65@CommitMiss
  0019d	80 be 98 00 00
	00 00		 cmp	 BYTE PTR [esi+152], 0
  001a4	75 30		 jne	 SHORT $LN2@CommitMiss
$LN65@CommitMiss:

; 3787 : 				g->SetRegion(s->GetRegion()->Name());

  001a6	8b 13		 mov	 edx, DWORD PTR [ebx]
  001a8	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  001ae	8b cb		 mov	 ecx, ebx
  001b0	ff d0		 call	 eax
  001b2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001b5	50		 push	 eax
  001b6	8d 4d dc	 lea	 ecx, DWORD PTR $T331587[ebp]
  001b9	e8 00 00 00 00	 call	 ??0Text@@QAE@PBD@Z	; Text::Text
  001be	8d 4d dc	 lea	 ecx, DWORD PTR $T331587[ebp]
  001c1	51		 push	 ecx
  001c2	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
  001c5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  001cc	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@ABV0@@Z ; Text::operator=
  001d1	8d 4d dc	 lea	 ecx, DWORD PTR $T331587[ebp]

; 3788 : 				else

  001d4	eb 22		 jmp	 SHORT $LN91@CommitMiss
$LN2@CommitMiss:

; 3789 : 				u->SetRegion(g->GetRegion());

  001d6	8d 56 4c	 lea	 edx, DWORD PTR [esi+76]
  001d9	52		 push	 edx
  001da	8d 4d d4	 lea	 ecx, DWORD PTR $T331595[ebp]
  001dd	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  001e2	8d 45 d4	 lea	 eax, DWORD PTR $T331595[ebp]
  001e5	50		 push	 eax
  001e6	8d 4f 3c	 lea	 ecx, DWORD PTR [edi+60]
  001e9	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  001f0	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@ABV0@@Z ; Text::operator=
  001f5	8d 4d d4	 lea	 ecx, DWORD PTR $T331595[ebp]
$LN91@CommitMiss:
  001f8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ff	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text

; 3790 : 
; 3791 : 				g->MoveTo(u_loc);

  00204	8d 45 bc	 lea	 eax, DWORD PTR _u_loc$121417[ebp]
  00207	8b ce		 mov	 ecx, esi
  00209	e8 00 00 00 00	 call	 ?MoveTo@CombatGroup@@QAEXABUPoint@@@Z ; CombatGroup::MoveTo
$LN13@CommitMiss:

; 3759 : 	}
; 3760 : 
; 3761 : 	for (int i = 0; i < ships.size(); i++) {

  0020e	8b 4d ec	 mov	 ecx, DWORD PTR _i$121410[ebp]
  00211	8b 45 08	 mov	 eax, DWORD PTR tv370[ebp]
  00214	41		 inc	 ecx
  00215	89 4d ec	 mov	 DWORD PTR _i$121410[ebp], ecx
  00218	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0021a	0f 8c 60 fe ff
	ff		 jl	 $LL14@CommitMiss
$LN12@CommitMiss:

; 3792 : 			}
; 3793 : 		}
; 3794 : 	}
; 3795 : }

  00220	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00223	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0022a	59		 pop	 ecx
  0022b	5f		 pop	 edi
  0022c	5e		 pop	 esi
  0022d	5b		 pop	 ebx
  0022e	8b e5		 mov	 esp, ebp
  00230	5d		 pop	 ebp
  00231	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CommitMission@SimRegion@@IAEXXZ$3:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR $T331544[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CommitMission@SimRegion@@IAEXXZ$4:
  00008	8d 4d dc	 lea	 ecx, DWORD PTR $T331587[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CommitMission@SimRegion@@IAEXXZ$5:
  00010	8d 4d d4	 lea	 ecx, DWORD PTR $T331595[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__ehhandler$?CommitMission@SimRegion@@IAEXXZ:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CommitMission@SimRegion@@IAEXXZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CommitMission@SimRegion@@IAEXXZ ENDP			; SimRegion::CommitMission
PUBLIC	?CanTimeSkip@SimRegion@@QBE_NXZ			; SimRegion::CanTimeSkip
; Function compile flags: /Ogtp
;	COMDAT ?CanTimeSkip@SimRegion@@QBE_NXZ
_TEXT	SEGMENT
_i$121295 = -4						; size = 4
_this$ = 8						; size = 4
?CanTimeSkip@SimRegion@@QBE_NXZ PROC			; SimRegion::CanTimeSkip, COMDAT

; 3584 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]

; 3585 : 	bool ok = false;

  0000d	32 c0		 xor	 al, al

; 3586 : 
; 3587 : 	if (player_ship) {

  0000f	83 7f 44 00	 cmp	 DWORD PTR [edi+68], 0
  00013	0f 84 cd 00 00
	00		 je	 $LN4@CanTimeSki

; 3588 : 		ok = true;
; 3589 : 
; 3590 : 		for (int i = 0; ok && i < ships.size(); i++) {

  00019	33 c9		 xor	 ecx, ecx
  0001b	b3 01		 mov	 bl, 1
  0001d	89 4c 24 0c	 mov	 DWORD PTR _i$121295[esp+16], ecx
  00021	eb 04		 jmp	 SHORT $LN6@CanTimeSki
$LL39@CanTimeSki:
  00023	8b 4c 24 0c	 mov	 ecx, DWORD PTR _i$121295[esp+16]
$LN6@CanTimeSki:
  00027	3b 4f 4c	 cmp	 ecx, DWORD PTR [edi+76]
  0002a	8d 47 4c	 lea	 eax, DWORD PTR [edi+76]
  0002d	0f 8d b1 00 00
	00		 jge	 $LN36@CanTimeSki

; 3591 : 			Ship* s = ships[i];

  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??A?$List@VShip@@@@QBEPAVShip@@H@Z ; List<Ship>::operator[]
  00039	8b f0		 mov	 esi, eax

; 3592 : 
; 3593 : 			if (s != player_ship && s->GetIFF() && s->GetIFF() != player_ship->GetIFF()) {

  0003b	3b 77 44	 cmp	 esi, DWORD PTR [edi+68]
  0003e	0f 84 94 00 00
	00		 je	 $LN5@CanTimeSki
  00044	8b 06		 mov	 eax, DWORD PTR [esi]
  00046	8b 90 98 01 00
	00		 mov	 edx, DWORD PTR [eax+408]
  0004c	8b ce		 mov	 ecx, esi
  0004e	ff d2		 call	 edx
  00050	85 c0		 test	 eax, eax
  00052	0f 84 80 00 00
	00		 je	 $LN5@CanTimeSki
  00058	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  0005b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005d	8b 90 98 01 00
	00		 mov	 edx, DWORD PTR [eax+408]
  00063	ff d2		 call	 edx
  00065	8b f8		 mov	 edi, eax
  00067	8b 06		 mov	 eax, DWORD PTR [esi]
  00069	8b 90 98 01 00
	00		 mov	 edx, DWORD PTR [eax+408]
  0006f	8b ce		 mov	 ecx, esi
  00071	ff d2		 call	 edx
  00073	3b c7		 cmp	 eax, edi

; 3594 : 				double dist = Point(s->Location() - player_ship->Location()).length();

  00075	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  00078	74 5e		 je	 SHORT $LN5@CanTimeSki
  0007a	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  0007d	f2 0f 10 46 48	 movsd	 xmm0, QWORD PTR [esi+72]
  00082	f2 0f 5c 40 48	 subsd	 xmm0, QWORD PTR [eax+72]
  00087	f2 0f 10 4e 50	 movsd	 xmm1, QWORD PTR [esi+80]
  0008c	f2 0f 5c 48 50	 subsd	 xmm1, QWORD PTR [eax+80]
  00091	f2 0f 10 56 58	 movsd	 xmm2, QWORD PTR [esi+88]
  00096	f2 0f 5c 50 58	 subsd	 xmm2, QWORD PTR [eax+88]
  0009b	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  0009f	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  000a3	f2 0f 58 c8	 addsd	 xmm1, xmm0
  000a7	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  000ab	f2 0f 58 ca	 addsd	 xmm1, xmm2

; 3595 : 
; 3596 : 				if (s->IsStarship())

  000af	8b c6		 mov	 eax, esi
  000b1	f2 0f 51 c1	 sqrtsd	 xmm0, xmm1
  000b5	e8 00 00 00 00	 call	 ?IsStarship@Ship@@QBE_NXZ ; Ship::IsStarship
  000ba	84 c0		 test	 al, al
  000bc	74 0a		 je	 SHORT $LN2@CanTimeSki

; 3597 : 				ok = dist > 60e3;

  000be	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@40ed4c0000000000

; 3598 : 				else

  000c6	eb 08		 jmp	 SHORT $LN41@CanTimeSki
$LN2@CanTimeSki:

; 3599 : 				ok = dist > 30e3;

  000c8	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@40dd4c0000000000
$LN41@CanTimeSki:
  000d0	76 04		 jbe	 SHORT $LN12@CanTimeSki
  000d2	b3 01		 mov	 bl, 1
  000d4	eb 02		 jmp	 SHORT $LN5@CanTimeSki
$LN12@CanTimeSki:
  000d6	32 db		 xor	 bl, bl
$LN5@CanTimeSki:

; 3588 : 		ok = true;
; 3589 : 
; 3590 : 		for (int i = 0; ok && i < ships.size(); i++) {

  000d8	ff 44 24 0c	 inc	 DWORD PTR _i$121295[esp+16]
  000dc	84 db		 test	 bl, bl
  000de	0f 85 3f ff ff
	ff		 jne	 $LL39@CanTimeSki
$LN36@CanTimeSki:

; 3600 : 			}
; 3601 : 		}
; 3602 : 	}
; 3603 : 
; 3604 : 	return ok;

  000e4	8a c3		 mov	 al, bl
$LN4@CanTimeSki:

; 3605 : }

  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 04 00	 ret	 4
?CanTimeSkip@SimRegion@@QBE_NXZ ENDP			; SimRegion::CanTimeSkip
_TEXT	ENDS
PUBLIC	?UpdateSky@SimRegion@@IAEXNABUPoint@@@Z		; SimRegion::UpdateSky
; Function compile flags: /Ogtp
;	COMDAT ?UpdateSky@SimRegion@@IAEXNABUPoint@@@Z
_TEXT	SEGMENT
$T331684 = -36						; size = 24
_a$ = -12						; size = 8
_ref$ = 8						; size = 4
_seconds$ = 12						; size = 8
?UpdateSky@SimRegion@@IAEXNABUPoint@@@Z PROC		; SimRegion::UpdateSky, COMDAT
; _this$ = eax

; 2579 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax

; 2580 : 	Dust* dust = sim->dust;

  0000a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000d	8b 70 50	 mov	 esi, DWORD PTR [eax+80]

; 2581 : 
; 2582 : 	if (dust) {

  00010	85 f6		 test	 esi, esi
  00012	0f 84 8b 00 00
	00		 je	 $LN3@UpdateSky

; 2583 : 		if (orbital_region && orbital_region->Type() == Orbital::TERRAIN) {

  00018	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0001b	85 c0		 test	 eax, eax
  0001d	74 11		 je	 SHORT $LN5@UpdateSky
  0001f	83 78 10 05	 cmp	 DWORD PTR [eax+16], 5
  00023	75 0b		 jne	 SHORT $LN5@UpdateSky

; 2584 : 			dust->Hide();

  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  0002a	8b ce		 mov	 ecx, esi
  0002c	ff d0		 call	 eax

; 2585 : 		}
; 2586 : 		else {

  0002e	eb 73		 jmp	 SHORT $LN3@UpdateSky
$LN5@UpdateSky:

; 2587 : 			dust->Show();

  00030	8b 16		 mov	 edx, DWORD PTR [esi]
  00032	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00035	8b ce		 mov	 ecx, esi
  00037	ff d0		 call	 eax

; 2588 : 
; 2589 : 			dust->ExecFrame(seconds, ref);

  00039	8b 45 08	 mov	 eax, DWORD PTR _ref$[ebp]
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  00043	8b 92 8c 00 00
	00		 mov	 edx, DWORD PTR [edx+140]
  00049	50		 push	 eax
  0004a	83 ec 08	 sub	 esp, 8
  0004d	8b ce		 mov	 ecx, esi
  0004f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00054	ff d2		 call	 edx

; 2590 : 
; 2591 : 			if (player_ship && dust->Hidden()) {

  00056	83 7f 44 00	 cmp	 DWORD PTR [edi+68], 0
  0005a	74 47		 je	 SHORT $LN3@UpdateSky
  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  00061	8b ce		 mov	 ecx, esi
  00063	ff d2		 call	 edx
  00065	85 c0		 test	 eax, eax
  00067	74 3a		 je	 SHORT $LN3@UpdateSky

; 2592 : 				dust->Reset(player_ship->Location());

  00069	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  0006c	f2 0f 10 40 48	 movsd	 xmm0, QWORD PTR [eax+72]
  00071	f2 0f 11 45 dc	 movsd	 QWORD PTR $T331684[ebp], xmm0
  00076	f2 0f 10 40 50	 movsd	 xmm0, QWORD PTR [eax+80]
  0007b	f2 0f 11 45 e4	 movsd	 QWORD PTR $T331684[ebp+8], xmm0
  00080	f2 0f 10 40 58	 movsd	 xmm0, QWORD PTR [eax+88]
  00085	8b 06		 mov	 eax, DWORD PTR [esi]
  00087	8b 90 88 00 00
	00		 mov	 edx, DWORD PTR [eax+136]
  0008d	8d 4d dc	 lea	 ecx, DWORD PTR $T331684[ebp]
  00090	51		 push	 ecx
  00091	8b ce		 mov	 ecx, esi
  00093	f2 0f 11 45 ec	 movsd	 QWORD PTR $T331684[ebp+16], xmm0
  00098	ff d2		 call	 edx

; 2593 : 				dust->Show();

  0009a	8b 06		 mov	 eax, DWORD PTR [esi]
  0009c	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]
  0009f	8b ce		 mov	 ecx, esi
  000a1	ff d2		 call	 edx
$LN3@UpdateSky:

; 2594 : 			}
; 2595 : 		}
; 2596 : 	}
; 2597 : 
; 2598 : 	ListIter<Asteroid> a = asteroids;

  000a3	81 c7 ac 00 00
	00		 add	 edi, 172		; 000000acH

; 2599 : 	while (++a) {

  000a9	8d 55 f4	 lea	 edx, DWORD PTR _a$[ebp]
  000ac	89 7d f4	 mov	 DWORD PTR _a$[ebp], edi
  000af	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _a$[ebp+4], -1
  000b6	e8 00 00 00 00	 call	 ?next@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::next
  000bb	85 c0		 test	 eax, eax
  000bd	74 2b		 je	 SHORT $LN1@UpdateSky
  000bf	90		 npad	 1
$LL2@UpdateSky:

; 2600 : 		a->ExecFrame(seconds);

  000c0	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  000c3	e8 00 00 00 00	 call	 ?value@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::value
  000c8	8b 10		 mov	 edx, DWORD PTR [eax]
  000ca	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  000cf	83 ec 08	 sub	 esp, 8
  000d2	8b c8		 mov	 ecx, eax
  000d4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d7	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000dc	ff d0		 call	 eax
  000de	8d 55 f4	 lea	 edx, DWORD PTR _a$[ebp]
  000e1	e8 00 00 00 00	 call	 ?next@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::next
  000e6	85 c0		 test	 eax, eax
  000e8	75 d6		 jne	 SHORT $LL2@UpdateSky
$LN1@UpdateSky:

; 2601 : 	}
; 2602 : }

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 0c 00	 ret	 12			; 0000000cH
?UpdateSky@SimRegion@@IAEXNABUPoint@@@Z ENDP		; SimRegion::UpdateSky
_TEXT	ENDS
PUBLIC	?AttachPlayerShip@SimRegion@@IAEXH@Z		; SimRegion::AttachPlayerShip
; Function compile flags: /Ogtp
;	COMDAT ?AttachPlayerShip@SimRegion@@IAEXH@Z
_TEXT	SEGMENT
$T331719 = -24						; size = 24
?AttachPlayerShip@SimRegion@@IAEXH@Z PROC		; SimRegion::AttachPlayerShip, COMDAT
; _this$ = esi
; _index$ = edi

; 2339 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2340 : 	if (player_ship)

  00003	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	85 c9		 test	 ecx, ecx
  0000b	74 0c		 je	 SHORT $LN5@AttachPlay

; 2341 : 	player_ship->SetControls(0);

  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00015	6a 00		 push	 0
  00017	ff d2		 call	 edx
$LN5@AttachPlay:

; 2342 : 
; 2343 : 	current_view = index;
; 2344 : 	player_ship  = ships[current_view];

  00019	57		 push	 edi
  0001a	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  0001d	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  00020	e8 00 00 00 00	 call	 ??A?$List@VShip@@@@QAEAAPAVShip@@H@Z ; List<Ship>::operator[]
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 2345 : 
; 2346 : 	CameraDirector* cam_dir = CameraDirector::GetInstance();

  0002a	e8 00 00 00 00	 call	 ?GetInstance@CameraDirector@@SAPAV1@XZ ; CameraDirector::GetInstance

; 2347 : 	if (cam_dir)

  0002f	85 c0		 test	 eax, eax
  00031	74 0d		 je	 SHORT $LN4@AttachPlay

; 2348 : 	cam_dir->SetShip(player_ship);

  00033	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00036	8b 10		 mov	 edx, DWORD PTR [eax]
  00038	8b 52 28	 mov	 edx, DWORD PTR [edx+40]
  0003b	51		 push	 ecx
  0003c	8b c8		 mov	 ecx, eax
  0003e	ff d2		 call	 edx
$LN4@AttachPlay:

; 2349 : 
; 2350 : 	if (sim->dust)

  00040	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00043	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  00047	74 32		 je	 SHORT $LN3@AttachPlay

; 2351 : 	sim->dust->Reset(player_ship->Location());

  00049	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0004c	f2 0f 10 40 48	 movsd	 xmm0, QWORD PTR [eax+72]
  00051	f2 0f 11 45 e8	 movsd	 QWORD PTR $T331719[ebp], xmm0
  00056	f2 0f 10 40 50	 movsd	 xmm0, QWORD PTR [eax+80]
  0005b	f2 0f 11 45 f0	 movsd	 QWORD PTR $T331719[ebp+8], xmm0
  00060	f2 0f 10 40 58	 movsd	 xmm0, QWORD PTR [eax+88]
  00065	f2 0f 11 45 f8	 movsd	 QWORD PTR $T331719[ebp+16], xmm0
  0006a	8b 49 50	 mov	 ecx, DWORD PTR [ecx+80]
  0006d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [eax+136]
  00075	8d 55 e8	 lea	 edx, DWORD PTR $T331719[ebp]
  00078	52		 push	 edx
  00079	ff d0		 call	 eax
$LN3@AttachPlay:

; 2352 : 
; 2353 : 	if (!sim->IsTestMode())

  0007b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007e	80 b8 bc 00 00
	00 00		 cmp	 BYTE PTR [eax+188], 0
  00085	75 14		 jne	 SHORT $LN2@AttachPlay

; 2354 : 	player_ship->SetControls(sim->ctrl);

  00087	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0008a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008c	8b 80 b8 00 00
	00		 mov	 eax, DWORD PTR [eax+184]
  00092	8b 92 cc 00 00
	00		 mov	 edx, DWORD PTR [edx+204]
  00098	50		 push	 eax
  00099	ff d2		 call	 edx
$LN2@AttachPlay:

; 2355 : 
; 2356 : 	MouseController* mouse_con = MouseController::GetInstance();

  0009b	e8 00 00 00 00	 call	 ?GetInstance@MouseController@@SAPAV1@XZ ; MouseController::GetInstance

; 2357 : 	if (mouse_con)

  000a0	85 c0		 test	 eax, eax
  000a2	74 0b		 je	 SHORT $LN1@AttachPlay

; 2358 : 	mouse_con->SetActive(false);

  000a4	8b 10		 mov	 edx, DWORD PTR [eax]
  000a6	8b c8		 mov	 ecx, eax
  000a8	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  000ab	6a 00		 push	 0
  000ad	ff d0		 call	 eax
$LN1@AttachPlay:

; 2359 : }

  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?AttachPlayerShip@SimRegion@@IAEXH@Z ENDP		; SimRegion::AttachPlayerShip
_TEXT	ENDS
PUBLIC	__real@483d6329f1c35ca5
PUBLIC	?FindNearestRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@H@Z ; Sim::FindNearestRegion
;	COMDAT __real@483d6329f1c35ca5
; File c:\matrix games\dev\ngenex\geometry.h
CONST	SEGMENT
__real@483d6329f1c35ca5 DQ 0483d6329f1c35ca5r	; 1e+040
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
CONST	ENDS
;	COMDAT ?FindNearestRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@H@Z
_TEXT	SEGMENT
_rgn$ = -64						; size = 8
_distance$ = -56					; size = 8
_objloc$ = -48						; size = 24
$T331743 = -24						; size = 24
_this$ = 8						; size = 4
_type$ = 12						; size = 4
?FindNearestRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@H@Z PROC ; Sim::FindNearestRegion, COMDAT
; _object$ = esi

; 1388 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 40	 sub	 esp, 64			; 00000040H
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR _type$[ebp]
  0000d	57		 push	 edi

; 1389 : 	if (!object) return 0;

  0000e	85 f6		 test	 esi, esi
  00010	75 0a		 jne	 SHORT $LN7@FindNeares@2
  00012	33 c0		 xor	 eax, eax

; 1415 : }

  00014	5f		 pop	 edi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN7@FindNeares@2:

; 1390 : 
; 1391 : 	SimRegion*  result   = 0;
; 1392 : 	double      distance = 1.0e40;

  0001c	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@483d6329f1c35ca5

; 1393 : 	Point       objloc   = object->Location();
; 1394 : 
; 1395 : 	objloc = objloc.OtherHand();
; 1396 : 
; 1397 : 	if (object->GetRegion())

  00024	8b 06		 mov	 eax, DWORD PTR [esi]
  00026	f2 0f 10 4e 50	 movsd	 xmm1, QWORD PTR [esi+80]
  0002b	f2 0f 10 56 58	 movsd	 xmm2, QWORD PTR [esi+88]
  00030	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00036	f2 0f 11 44 24
	10		 movsd	 QWORD PTR _distance$[esp+72], xmm0
  0003c	f2 0f 10 46 48	 movsd	 xmm0, QWORD PTR [esi+72]
  00041	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00049	8b ce		 mov	 ecx, esi
  0004b	33 ff		 xor	 edi, edi
  0004d	f2 0f 11 44 24
	30		 movsd	 QWORD PTR $T331743[esp+72], xmm0
  00053	f2 0f 11 4c 24
	40		 movsd	 QWORD PTR $T331743[esp+88], xmm1
  00059	f2 0f 11 44 24
	18		 movsd	 QWORD PTR _objloc$[esp+72], xmm0
  0005f	f2 0f 11 54 24
	20		 movsd	 QWORD PTR _objloc$[esp+80], xmm2
  00065	f2 0f 11 4c 24
	28		 movsd	 QWORD PTR _objloc$[esp+88], xmm1
  0006b	ff d2		 call	 edx
  0006d	85 c0		 test	 eax, eax
  0006f	74 3f		 je	 SHORT $LN26@FindNeares@2

; 1398 : 	objloc += object->GetRegion()->Location();

  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00079	8b ce		 mov	 ecx, esi
  0007b	ff d2		 call	 edx
  0007d	f2 0f 10 40 20	 movsd	 xmm0, QWORD PTR [eax+32]
  00082	f2 0f 10 48 28	 movsd	 xmm1, QWORD PTR [eax+40]
  00087	f2 0f 10 50 30	 movsd	 xmm2, QWORD PTR [eax+48]
  0008c	f2 0f 58 44 24
	30		 addsd	 xmm0, QWORD PTR $T331743[esp+72]
  00092	f2 0f 58 4c 24
	20		 addsd	 xmm1, QWORD PTR _objloc$[esp+80]
  00098	f2 0f 58 54 24
	40		 addsd	 xmm2, QWORD PTR $T331743[esp+88]
  0009e	f2 0f 11 44 24
	18		 movsd	 QWORD PTR _objloc$[esp+72], xmm0
  000a4	f2 0f 11 4c 24
	20		 movsd	 QWORD PTR _objloc$[esp+80], xmm1
  000aa	f2 0f 11 54 24
	28		 movsd	 QWORD PTR _objloc$[esp+88], xmm2
$LN26@FindNeares@2:

; 1399 : 
; 1400 : 	ListIter<SimRegion> rgn = regions;

  000b0	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	83 c0 58	 add	 eax, 88			; 00000058H

; 1401 : 	while (++rgn) {

  000b6	8d 54 24 08	 lea	 edx, DWORD PTR _rgn$[esp+72]
  000ba	89 44 24 08	 mov	 DWORD PTR _rgn$[esp+72], eax
  000be	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _rgn$[esp+76], -1
  000c6	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  000cb	85 c0		 test	 eax, eax
  000cd	74 78		 je	 SHORT $LN4@FindNeares@2
  000cf	90		 npad	 1
$LL5@FindNeares@2:

; 1402 : 		if (rgn->Type() == type) {

  000d0	8d 44 24 08	 lea	 eax, DWORD PTR _rgn$[esp+72]
  000d4	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  000d9	39 58 14	 cmp	 DWORD PTR [eax+20], ebx
  000dc	75 5c		 jne	 SHORT $LN1@FindNeares@2

; 1403 : 			OrbitalRegion* orgn = rgn->GetOrbitalRegion();

  000de	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]

; 1404 : 			if (orgn) {

  000e1	85 c9		 test	 ecx, ecx
  000e3	74 55		 je	 SHORT $LN1@FindNeares@2

; 1405 : 				double test = fabs((orgn->Location() - objloc).length());

  000e5	f2 0f 10 41 60	 movsd	 xmm0, QWORD PTR [ecx+96]
  000ea	f2 0f 5c 44 24
	18		 subsd	 xmm0, QWORD PTR _objloc$[esp+72]
  000f0	f2 0f 10 49 68	 movsd	 xmm1, QWORD PTR [ecx+104]
  000f5	f2 0f 5c 4c 24
	20		 subsd	 xmm1, QWORD PTR _objloc$[esp+80]
  000fb	f2 0f 10 51 70	 movsd	 xmm2, QWORD PTR [ecx+112]
  00100	f2 0f 5c 54 24
	28		 subsd	 xmm2, QWORD PTR _objloc$[esp+88]
  00106	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  0010a	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0010e	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00112	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  00116	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0011a	f2 0f 51 c1	 sqrtsd	 xmm0, xmm1
  0011e	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@

; 1406 : 				if (test < distance) {

  00126	f2 0f 10 4c 24
	10		 movsd	 xmm1, QWORD PTR _distance$[esp+72]
  0012c	66 0f 2f c8	 comisd	 xmm1, xmm0
  00130	76 08		 jbe	 SHORT $LN1@FindNeares@2

; 1407 : 					result = rgn.value();

  00132	8b f8		 mov	 edi, eax

; 1408 : 					distance = test;

  00134	f2 0f 11 44 24
	10		 movsd	 QWORD PTR _distance$[esp+72], xmm0
$LN1@FindNeares@2:

; 1401 : 	while (++rgn) {

  0013a	8d 54 24 08	 lea	 edx, DWORD PTR _rgn$[esp+72]
  0013e	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00143	85 c0		 test	 eax, eax
  00145	75 89		 jne	 SHORT $LL5@FindNeares@2
$LN4@FindNeares@2:

; 1409 : 				}
; 1410 : 			}
; 1411 : 		}
; 1412 : 	}
; 1413 : 	
; 1414 : 	return result;

  00147	8b c7		 mov	 eax, edi

; 1415 : }

  00149	5f		 pop	 edi
  0014a	5b		 pop	 ebx
  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c2 08 00	 ret	 8
?FindNearestRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@H@Z ENDP ; Sim::FindNearestRegion
_TEXT	ENDS
PUBLIC	?FindNearestTerrainRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@@Z ; Sim::FindNearestTerrainRegion
; Function compile flags: /Ogtp
;	COMDAT ?FindNearestTerrainRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@@Z
_TEXT	SEGMENT
?FindNearestTerrainRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@@Z PROC ; Sim::FindNearestTerrainRegion, COMDAT
; _this$ = eax
; _object$ = esi

; 1382 : {

  00000	51		 push	 ecx

; 1383 : 	return FindNearestRegion(object, AIR_SPACE);

  00001	6a 01		 push	 1
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ?FindNearestRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@H@Z ; Sim::FindNearestRegion
  00009	59		 pop	 ecx

; 1384 : }

  0000a	c3		 ret	 0
?FindNearestTerrainRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@@Z ENDP ; Sim::FindNearestTerrainRegion
_TEXT	ENDS
PUBLIC	?FindNearestSpaceRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@@Z ; Sim::FindNearestSpaceRegion
; Function compile flags: /Ogtp
;	COMDAT ?FindNearestSpaceRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@@Z
_TEXT	SEGMENT
?FindNearestSpaceRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@@Z PROC ; Sim::FindNearestSpaceRegion, COMDAT
; _this$ = eax
; _object$ = esi

; 1376 : {

  00000	51		 push	 ecx

; 1377 : 	return FindNearestRegion(object, REAL_SPACE);

  00001	6a 00		 push	 0
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ?FindNearestRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@H@Z ; Sim::FindNearestRegion
  00009	59		 pop	 ecx

; 1378 : }

  0000a	c3		 ret	 0
?FindNearestSpaceRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@@Z ENDP ; Sim::FindNearestSpaceRegion
_TEXT	ENDS
PUBLIC	?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z	; Sim::CreateSplashDamage
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\physical.h
xdata$x	SEGMENT
__unwindtable$?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z$0
__ehfuncinfo$?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z
_TEXT	SEGMENT
$T331848 = -40						; size = 24
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T331847 = 12						; size = 4
_ship$ = 12						; size = 4
?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z PROC		; Sim::CreateSplashDamage, COMDAT

; 1171 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b 5d 0c	 mov	 ebx, DWORD PTR _ship$[ebp]

; 1172 : 	if (ship && ship->GetRegion() && ship->Design()->splash_radius > 1) {

  0002b	33 ff		 xor	 edi, edi
  0002d	3b df		 cmp	 ebx, edi
  0002f	0f 84 c9 00 00
	00		 je	 $LN1@CreateSpla
  00035	8b 03		 mov	 eax, DWORD PTR [ebx]
  00037	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  0003d	8b cb		 mov	 ecx, ebx
  0003f	ff d2		 call	 edx
  00041	85 c0		 test	 eax, eax
  00043	0f 84 b5 00 00
	00		 je	 $LN1@CreateSpla
  00049	8b 83 00 02 00
	00		 mov	 eax, DWORD PTR [ebx+512]
  0004f	f3 0f 10 80 cc
	07 00 00	 movss	 xmm0, DWORD PTR [eax+1996]
  00057	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0005e	0f 86 9a 00 00
	00		 jbe	 $LN1@CreateSpla

; 1173 : 		SimSplash* splash = new(__FILE__,__LINE__)
; 1174 : 		SimSplash(ship->GetRegion(),
; 1175 : 		ship->Location(),
; 1176 : 		ship->Design()->integrity / 4,
; 1177 : 		ship->Design()->splash_radius);

  00064	6a 38		 push	 56			; 00000038H
  00066	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0006b	8b f0		 mov	 esi, eax
  0006d	83 c4 04	 add	 esp, 4
  00070	89 75 0c	 mov	 DWORD PTR $T331847[ebp], esi
  00073	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00076	3b f7		 cmp	 esi, edi
  00078	74 67		 je	 SHORT $LN4@CreateSpla
  0007a	f2 0f 10 43 48	 movsd	 xmm0, QWORD PTR [ebx+72]
  0007f	8b 83 00 02 00
	00		 mov	 eax, DWORD PTR [ebx+512]
  00085	f2 0f 11 45 d8	 movsd	 QWORD PTR $T331848[ebp], xmm0
  0008a	f2 0f 10 43 50	 movsd	 xmm0, QWORD PTR [ebx+80]
  0008f	f2 0f 11 45 e0	 movsd	 QWORD PTR $T331848[ebp+8], xmm0
  00094	f2 0f 10 43 58	 movsd	 xmm0, QWORD PTR [ebx+88]
  00099	f2 0f 11 45 e8	 movsd	 QWORD PTR $T331848[ebp+16], xmm0
  0009e	f3 0f 10 80 cc
	07 00 00	 movss	 xmm0, DWORD PTR [eax+1996]
  000a6	0f 5a c0	 cvtps2pd xmm0, xmm0
  000a9	83 ec 10	 sub	 esp, 16			; 00000010H
  000ac	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  000b2	f3 0f 10 80 24
	02 00 00	 movss	 xmm0, DWORD PTR [eax+548]
  000ba	8b 03		 mov	 eax, DWORD PTR [ebx]
  000bc	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  000c2	0f 5a c0	 cvtps2pd xmm0, xmm0
  000c5	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR _SENSOR_THRESHOLD
  000cd	8b cb		 mov	 ecx, ebx
  000cf	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000d4	ff d2		 call	 edx
  000d6	50		 push	 eax
  000d7	8d 7d d8	 lea	 edi, DWORD PTR $T331848[ebp]
  000da	e8 00 00 00 00	 call	 ??0SimSplash@@QAE@PAVSimRegion@@ABUPoint@@NN@Z ; SimSplash::SimSplash
  000df	8b f8		 mov	 edi, eax
$LN4@CreateSpla:

; 1178 : 
; 1179 : 		splash->owner_name = ship->Name();

  000e1	83 c3 10	 add	 ebx, 16			; 00000010H
  000e4	53		 push	 ebx
  000e5	8b cf		 mov	 ecx, edi
  000e7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ee	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=

; 1180 : 		splashlist.append(splash);

  000f3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	83 c0 7c	 add	 eax, 124		; 0000007cH
  000f9	e8 00 00 00 00	 call	 ?append@?$List@VSimSplash@@@@QAEXPBVSimSplash@@@Z ; List<SimSplash>::append
$LN1@CreateSpla:

; 1181 : 	}
; 1182 : }

  000fe	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00101	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00108	59		 pop	 ecx
  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z$0:
  00000	68 95 04 00 00	 push	 1173			; 00000495H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 0c	 mov	 eax, DWORD PTR $T331847[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__ehhandler$?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateSplashDamage@Sim@@QAEXPAVShip@@@Z ENDP		; Sim::CreateSplashDamage
PUBLIC	?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z ; Sim::CreateAsteroid
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\geometry.h
xdata$x	SEGMENT
__unwindtable$?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z$0
__ehfuncinfo$?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z
_TEXT	SEGMENT
$T331896 = -28						; size = 12
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_t$ = 12						; size = 4
$T331895 = 16						; size = 4
_rgn$ = 16						; size = 4
_mass$ = 20						; size = 8
?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z PROC ; Sim::CreateAsteroid, COMDAT
; _pos$ = ecx

; 1155 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b 5d 10	 mov	 ebx, DWORD PTR _rgn$[ebp]
  0002b	8b f1		 mov	 esi, ecx

; 1156 : 	Asteroid* asteroid = new(__FILE__,__LINE__) Asteroid(t, pos, mass);

  0002d	68 e0 01 00 00	 push	 480			; 000001e0H
  00032	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 10	 mov	 DWORD PTR $T331895[ebp], eax
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	85 c0		 test	 eax, eax
  00046	74 47		 je	 SHORT $LN6@CreateAste
  00048	f2 0f 10 06	 movsd	 xmm0, QWORD PTR [esi]
  0004c	f2 0f 10 4e 08	 movsd	 xmm1, QWORD PTR [esi+8]
  00051	f2 0f 10 56 10	 movsd	 xmm2, QWORD PTR [esi+16]
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00059	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0005d	f3 0f 11 45 e4	 movss	 DWORD PTR $T331896[ebp], xmm0
  00062	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _mass$[ebp]
  00067	83 ec 08	 sub	 esp, 8
  0006a	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  0006e	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  00072	8d 7d e4	 lea	 edi, DWORD PTR $T331896[ebp]
  00075	8b f0		 mov	 esi, eax
  00077	f3 0f 11 4d e8	 movss	 DWORD PTR $T331896[ebp+4], xmm1
  0007c	f3 0f 11 55 ec	 movss	 DWORD PTR $T331896[ebp+8], xmm2
  00081	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00086	e8 00 00 00 00	 call	 ??0Asteroid@@QAE@HABUVec3@@N@Z ; Asteroid::Asteroid
  0008b	8b f0		 mov	 esi, eax
  0008d	eb 02		 jmp	 SHORT $LN7@CreateAste
$LN6@CreateAste:
  0008f	33 f6		 xor	 esi, esi
$LN7@CreateAste:
  00091	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 1157 : 
; 1158 : 	if (rgn)

  00098	85 db		 test	 ebx, ebx
  0009a	74 06		 je	 SHORT $LN3@CreateAste

; 1159 : 	rgn->InsertObject(asteroid);

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	8b cb		 mov	 ecx, ebx
  000a0	eb 0e		 jmp	 SHORT $LN17@CreateAste
$LN3@CreateAste:

; 1160 : 
; 1161 : 	else if (active_region)

  000a2	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000a9	74 0b		 je	 SHORT $LN15@CreateAste

; 1162 : 	active_region->InsertObject(asteroid);

  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	8b 01		 mov	 eax, DWORD PTR [ecx]
$LN17@CreateAste:
  000b0	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000b3	56		 push	 esi
  000b4	ff d2		 call	 edx
$LN15@CreateAste:

; 1163 : 
; 1164 : 	return asteroid;

  000b6	8b c6		 mov	 eax, esi

; 1165 : }

  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c2	59		 pop	 ecx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z$0:
  00000	68 84 04 00 00	 push	 1156			; 00000484H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 10	 mov	 eax, DWORD PTR $T331895[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__ehhandler$?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z ENDP ; Sim::CreateAsteroid
PUBLIC	?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z ; Sim::CreateShot
;	COMDAT xdata$x
; File c:\matrix games\dev\foundationex\memdebug.h
xdata$x	SEGMENT
__unwindtable$?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z$1
__ehfuncinfo$?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_pos$ = 12						; size = 4
_shot_cam$ = 16						; size = 4
$T331929 = 20						; size = 4
$T331925 = 20						; size = 4
_ship$ = 20						; size = 4
_rgn$ = 24						; size = 4
?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z PROC ; Sim::CreateShot, COMDAT
; _design$ = ecx

; 1098 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b 5d 14	 mov	 ebx, DWORD PTR _ship$[ebp]
  00028	8b f9		 mov	 edi, ecx

; 1099 : 	Shot* shot = 0;
; 1100 : 
; 1101 : 	if (design->drone)

  0002a	80 7f 1d 00	 cmp	 BYTE PTR [edi+29], 0
  0002e	74 2b		 je	 SHORT $LN5@CreateShot

; 1102 : 	shot = new(__FILE__,__LINE__) Drone(pos, shot_cam, design, ship);

  00030	68 50 02 00 00	 push	 592			; 00000250H
  00035	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003a	8b f0		 mov	 esi, eax
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 75 14	 mov	 DWORD PTR $T331925[ebp], esi
  00042	33 c0		 xor	 eax, eax
  00044	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00047	3b f0		 cmp	 esi, eax
  00049	74 3f		 je	 SHORT $LN11@CreateShot
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _shot_cam$[ebp]
  00051	50		 push	 eax
  00052	8b c3		 mov	 eax, ebx
  00054	e8 00 00 00 00	 call	 ??0Drone@@QAE@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@@Z ; Drone::Drone

; 1103 : 	else

  00059	eb 2f		 jmp	 SHORT $LN11@CreateShot
$LN5@CreateShot:

; 1104 : 	shot = new(__FILE__,__LINE__) Shot( pos, shot_cam, design, ship);

  0005b	68 40 02 00 00	 push	 576			; 00000240H
  00060	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00065	83 c4 04	 add	 esp, 4
  00068	89 45 14	 mov	 DWORD PTR $T331929[ebp], eax
  0006b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00072	85 c0		 test	 eax, eax
  00074	74 12		 je	 SHORT $LN10@CreateShot
  00076	8b 4d 10	 mov	 ecx, DWORD PTR _shot_cam$[ebp]
  00079	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp]
  0007c	53		 push	 ebx
  0007d	57		 push	 edi
  0007e	51		 push	 ecx
  0007f	52		 push	 edx
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??0Shot@@QAE@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@@Z ; Shot::Shot
  00086	eb 02		 jmp	 SHORT $LN11@CreateShot
$LN10@CreateShot:
  00088	33 c0		 xor	 eax, eax
$LN11@CreateShot:

; 1105 : 
; 1106 : 	if (rgn)

  0008a	8b 4d 18	 mov	 ecx, DWORD PTR _rgn$[ebp]
  0008d	8b f0		 mov	 esi, eax
  0008f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00096	85 c9		 test	 ecx, ecx

; 1107 : 	rgn->InsertObject(shot);

  00098	75 0b		 jne	 SHORT $LN20@CreateShot

; 1108 : 
; 1109 : 	else if (active_region)

  0009a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  000a0	74 0b		 je	 SHORT $LN18@CreateShot

; 1110 : 	active_region->InsertObject(shot);

  000a2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
$LN20@CreateShot:
  000a5	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a7	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  000aa	56		 push	 esi
  000ab	ff d2		 call	 edx
$LN18@CreateShot:

; 1111 : 
; 1112 : 	return shot;

  000ad	8b c6		 mov	 eax, esi

; 1113 : }

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z$0:
  00000	68 4e 04 00 00	 push	 1102			; 0000044eH
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 14	 mov	 eax, DWORD PTR $T331925[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__unwindfunclet$?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z$1:
  00017	68 50 04 00 00	 push	 1104			; 00000450H
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  00021	8b 45 14	 mov	 eax, DWORD PTR $T331929[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	c3		 ret	 0
__ehhandler$?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z:
  0002e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00032	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00035	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateShot@Sim@@QAEPAVShot@@ABUPoint@@ABVCamera@@PAVWeaponDesign@@PBVShip@@PAVSimRegion@@@Z ENDP ; Sim::CreateShot
PUBLIC	?UnloadMission@Sim@@QAEXXZ			; Sim::UnloadMission
; Function compile flags: /Ogtp
;	COMDAT ?UnloadMission@Sim@@QAEXXZ
_TEXT	SEGMENT
?UnloadMission@Sim@@QAEXXZ PROC				; Sim::UnloadMission, COMDAT
; _this$ = edi

; 230  : {

  00000	51		 push	 ecx

; 231  : 	if (netgame) {

  00001	8b 8f c4 00 00
	00		 mov	 ecx, DWORD PTR [edi+196]
  00007	53		 push	 ebx
  00008	33 db		 xor	 ebx, ebx
  0000a	56		 push	 esi
  0000b	3b cb		 cmp	 ecx, ebx
  0000d	74 0e		 je	 SHORT $LN8@UnloadMiss

; 232  : 		delete netgame;

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	6a 01		 push	 1
  00015	ff d2		 call	 edx

; 233  : 		netgame = 0;

  00017	89 9f c4 00 00
	00		 mov	 DWORD PTR [edi+196], ebx
$LN8@UnloadMiss:

; 234  : 	}
; 235  : 
; 236  : 	HUDView* hud = HUDView::GetInstance();

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hud_view@HUDView@@1PAV1@A ; HUDView::hud_view

; 237  : 	if (hud)

  00023	3b cb		 cmp	 ecx, ebx
  00025	74 07		 je	 SHORT $LN7@UnloadMiss

; 238  : 	hud->HideAll();

  00027	8b 01		 mov	 eax, DWORD PTR [ecx]
  00029	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  0002c	ff d2		 call	 edx
$LN7@UnloadMiss:

; 239  : 
; 240  : 	ShipStats::Initialize();

  0002e	e8 00 00 00 00	 call	 ?Initialize@ShipStats@@SAXXZ ; ShipStats::Initialize

; 241  : 
; 242  : 	events.destroy();

  00033	8d b7 a0 00 00
	00		 lea	 esi, DWORD PTR [edi+160]
  00039	e8 00 00 00 00	 call	 ?destroy@?$List@VMissionEvent@@@@QAEXXZ ; List<MissionEvent>::destroy

; 243  : 	mission_elements.destroy();

  0003e	8d b7 ac 00 00
	00		 lea	 esi, DWORD PTR [edi+172]
  00044	e8 00 00 00 00	 call	 ?destroy@?$List@VMissionElement@@@@QAEXXZ ; List<MissionElement>::destroy

; 244  : 	elements.destroy();

  00049	8d b7 88 00 00
	00		 lea	 esi, DWORD PTR [edi+136]
  0004f	e8 00 00 00 00	 call	 ?destroy@?$List@VElement@@@@QAEXXZ ; List<Element>::destroy

; 245  : 	finished.destroy();

  00054	8d b7 94 00 00
	00		 lea	 esi, DWORD PTR [edi+148]
  0005a	e8 00 00 00 00	 call	 ?destroy@?$List@VElement@@@@QAEXXZ ; List<Element>::destroy

; 246  : 
; 247  : 	if (active_region)

  0005f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00062	3b cb		 cmp	 ecx, ebx
  00064	74 07		 je	 SHORT $LN6@UnloadMiss

; 248  : 	active_region->Deactivate();

  00066	8b 01		 mov	 eax, DWORD PTR [ecx]
  00068	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0006b	ff d2		 call	 edx
$LN6@UnloadMiss:

; 249  : 
; 250  : 	if (star_system)

  0006d	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00070	3b cb		 cmp	 ecx, ebx
  00072	74 07		 je	 SHORT $LN5@UnloadMiss

; 251  : 	star_system->Deactivate();

  00074	8b 01		 mov	 eax, DWORD PTR [ecx]
  00076	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00079	ff d2		 call	 edx
$LN5@UnloadMiss:

; 252  : 
; 253  : 	if (mission) {

  0007b	8b 87 c0 00 00
	00		 mov	 eax, DWORD PTR [edi+192]
  00081	3b c3		 cmp	 eax, ebx
  00083	74 13		 je	 SHORT $LN17@UnloadMiss

; 254  : 		mission->SetActive(false);

  00085	88 98 b9 00 00
	00		 mov	 BYTE PTR [eax+185], bl

; 255  : 		mission->SetComplete(true);

  0008b	8b 87 c0 00 00
	00		 mov	 eax, DWORD PTR [edi+192]
  00091	c6 80 ba 00 00
	00 01		 mov	 BYTE PTR [eax+186], 1
$LN17@UnloadMiss:

; 256  : 	}
; 257  : 
; 258  : 	regions.destroy();

  00098	8d 77 58	 lea	 esi, DWORD PTR [edi+88]
  0009b	e8 00 00 00 00	 call	 ?destroy@?$List@VSimRegion@@@@QAEXXZ ; List<SimRegion>::destroy

; 259  : 	scene.Collect();

  000a0	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  000a3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a6	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  000a9	ff d0		 call	 eax

; 260  : 
; 261  : 	GRAPHIC_DESTROY(dust);

  000ab	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  000ae	3b cb		 cmp	 ecx, ebx
  000b0	74 0a		 je	 SHORT $LN3@UnloadMiss
  000b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b4	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000b7	ff d0		 call	 eax
  000b9	89 5f 50	 mov	 DWORD PTR [edi+80], ebx
$LN3@UnloadMiss:

; 262  : 
; 263  : 	star_system   = 0;

  000bc	89 5f 08	 mov	 DWORD PTR [edi+8], ebx

; 264  : 	active_region = 0;

  000bf	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 265  : 	mission       = 0;

  000c2	89 9f c0 00 00
	00		 mov	 DWORD PTR [edi+192], ebx

; 266  : 
; 267  : 	// reclaim memory used by radio traffic:
; 268  : 	RadioTraffic::DiscardMessages();

  000c8	e8 00 00 00 00	 call	 ?DiscardMessages@RadioTraffic@@SAXXZ ; RadioTraffic::DiscardMessages

; 269  : 
; 270  : 	// release texture memory for 2D screens:
; 271  : 	Starshatter* stars = Starshatter::GetInstance();

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@Starshatter@@1PAV1@A ; Starshatter::instance

; 272  : 	if (stars)

  000d2	3b c3		 cmp	 eax, ebx
  000d4	74 05		 je	 SHORT $LN2@UnloadMiss

; 273  : 	stars->InvalidateTextureCache();

  000d6	e8 00 00 00 00	 call	 ?InvalidateTextureCache@Starshatter@@QAEXXZ ; Starshatter::InvalidateTextureCache
$LN2@UnloadMiss:

; 274  : 
; 275  : 	cam_dir = CameraDirector::GetInstance();

  000db	e8 00 00 00 00	 call	 ?GetInstance@CameraDirector@@SAPAV1@XZ ; CameraDirector::GetInstance
  000e0	89 47 54	 mov	 DWORD PTR [edi+84], eax

; 276  : 	if (cam_dir)

  000e3	3b c3		 cmp	 eax, ebx
  000e5	74 0a		 je	 SHORT $LN1@UnloadMiss

; 277  : 	cam_dir->SetShip(0);

  000e7	8b 10		 mov	 edx, DWORD PTR [eax]
  000e9	8b c8		 mov	 ecx, eax
  000eb	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000ee	53		 push	 ebx
  000ef	ff d0		 call	 eax
$LN1@UnloadMiss:

; 278  : 
; 279  : 	AudioConfig::SetTraining(false);

  000f1	32 c9		 xor	 cl, cl
  000f3	e8 00 00 00 00	 call	 ?SetTraining@AudioConfig@@SAX_N@Z ; AudioConfig::SetTraining

; 280  : }

  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	59		 pop	 ecx
  000fb	c3		 ret	 0
?UnloadMission@Sim@@QAEXXZ ENDP				; Sim::UnloadMission
_TEXT	ENDS
PUBLIC	?CommitMission@Sim@@QAEXXZ			; Sim::CommitMission
; Function compile flags: /Ogtp
;	COMDAT ?CommitMission@Sim@@QAEXXZ
_TEXT	SEGMENT
_tk2$118317 = -16					; size = 4
_td$118318 = -12					; size = 4
_tc$118319 = -8						; size = 4
_i$118320 = -4						; size = 4
_this$ = 8						; size = 4
?CommitMission@Sim@@QAEXXZ PROC				; Sim::CommitMission, COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 161  : 	for (int i = 0; i < regions.size(); i++)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000a	56		 push	 esi
  0000b	33 f6		 xor	 esi, esi
  0000d	57		 push	 edi
  0000e	39 73 58	 cmp	 DWORD PTR [ebx+88], esi
  00011	7e 17		 jle	 SHORT $LN10@CommitMiss@2
$LL12@CommitMiss@2:

; 162  : 	regions[i]->CommitMission();

  00013	56		 push	 esi
  00014	8d 43 58	 lea	 eax, DWORD PTR [ebx+88]
  00017	e8 00 00 00 00	 call	 ??A?$List@VSimRegion@@@@QAEAAPAVSimRegion@@H@Z ; List<SimRegion>::operator[]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?CommitMission@SimRegion@@IAEXXZ ; SimRegion::CommitMission
  00024	46		 inc	 esi
  00025	3b 73 58	 cmp	 esi, DWORD PTR [ebx+88]
  00028	7c e9		 jl	 SHORT $LL12@CommitMiss@2
$LN10@CommitMiss@2:

; 163  : 
; 164  : 	if (ShipStats::NumStats() > 0) {

  0002a	e8 00 00 00 00	 call	 ?NumStats@ShipStats@@SAHXZ ; ShipStats::NumStats
  0002f	85 c0		 test	 eax, eax
  00031	0f 8e 5a 01 00
	00		 jle	 $LN9@CommitMiss@2

; 165  : 		Print("\n\nFINAL SCORE '%s'\n", (const char*) mission->Name());

  00037	8b 8b c0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+192]
  0003d	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00043	52		 push	 edx
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MDJAGKKE@?6?6FINAL?5SCORE?5?8?$CFs?8?6?$AA@
  00049	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 166  : 		Print("Name              Kill1  Kill2  Died   Colls  Points  Cmd Pts\n");

  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@BCONEFGH@Name?5?5?5?5?5?5?5?5?5?5?5?5?5?5Kill1?5?5Kill2?5?5@
  00053	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : 		Print("----------------  -----  -----  -----  -----  ------  ------\n");

  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@BFFMOOLB@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5?5?9?9?9?9?9?5?5?9?9?9?9?9?5?5@
  00060	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 168  : 
; 169  : 		int tk1 = 0;
; 170  : 		int tk2 = 0;

  00065	33 ff		 xor	 edi, edi
  00067	83 c4 04	 add	 esp, 4
  0006a	33 db		 xor	 ebx, ebx

; 171  : 		int td  = 0;

  0006c	89 7d f4	 mov	 DWORD PTR _td$118318[ebp], edi

; 172  : 		int tc  = 0;

  0006f	89 7d f8	 mov	 DWORD PTR _tc$118319[ebp], edi

; 173  : 
; 174  : 		for (int i = 0; i < ShipStats::NumStats(); i++) {

  00072	89 7d fc	 mov	 DWORD PTR _i$118320[ebp], edi
  00075	e8 00 00 00 00	 call	 ?NumStats@ShipStats@@SAHXZ ; ShipStats::NumStats
  0007a	85 c0		 test	 eax, eax
  0007c	0f 8e e6 00 00
	00		 jle	 $LN6@CommitMiss@2
$LN8@CommitMiss@2:

; 175  : 			ShipStats* s = ShipStats::GetStats(i);

  00082	8b 45 fc	 mov	 eax, DWORD PTR _i$118320[ebp]
  00085	e8 00 00 00 00	 call	 ?GetStats@ShipStats@@SAPAV1@H@Z ; ShipStats::GetStats
  0008a	8b f0		 mov	 esi, eax

; 176  : 			s->Summarize();

  0008c	e8 00 00 00 00	 call	 ?Summarize@ShipStats@@QAEXXZ ; ShipStats::Summarize

; 177  : 
; 178  : 			Print("%-16s  %5d  %5d  %5d  %5d  %6d  %6d\n",
; 179  : 			s->GetName(),
; 180  : 			s->GetGunKills(),
; 181  : 			s->GetMissileKills(),
; 182  : 			s->GetDeaths(),
; 183  : 			s->GetColls(),
; 184  : 			s->GetPoints(),
; 185  : 			s->GetCommandPoints());

  00091	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00094	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00097	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  0009a	50		 push	 eax
  0009b	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0009e	51		 push	 ecx
  0009f	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  000a2	52		 push	 edx
  000a3	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  000a6	50		 push	 eax
  000a7	8b 06		 mov	 eax, DWORD PTR [esi]
  000a9	51		 push	 ecx
  000aa	52		 push	 edx
  000ab	50		 push	 eax
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KFDPBJH@?$CF?916s?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5?5?$CF6d?5?5@
  000b1	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 186  : 
; 187  : 			tk1 += s->GetGunKills();
; 188  : 			tk2 += s->GetMissileKills();

  000b6	03 7e 3c	 add	 edi, DWORD PTR [esi+60]

; 189  : 			td  += s->GetDeaths();

  000b9	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]

; 190  : 			tc  += s->GetColls();

  000bc	8b 56 44	 mov	 edx, DWORD PTR [esi+68]

; 191  : 
; 192  : 			CombatGroup* group = s->GetCombatGroup();

  000bf	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000c2	03 5e 38	 add	 ebx, DWORD PTR [esi+56]
  000c5	01 4d f4	 add	 DWORD PTR _td$118318[ebp], ecx
  000c8	01 55 f8	 add	 DWORD PTR _tc$118319[ebp], edx
  000cb	83 c4 20	 add	 esp, 32			; 00000020H
  000ce	89 7d f0	 mov	 DWORD PTR _tk2$118317[ebp], edi

; 193  : 
; 194  : 			if (group) {

  000d1	85 c0		 test	 eax, eax
  000d3	74 2c		 je	 SHORT $LN71@CommitMiss@2

; 195  : 				Combatant* c = group->GetCombatant();

  000d5	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]

; 196  : 
; 197  : 				if (c)

  000d8	85 c9		 test	 ecx, ecx
  000da	74 06		 je	 SHORT $LN51@CommitMiss@2

; 198  : 				c->AddScore(s->GetPoints());

  000dc	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  000df	01 51 0c	 add	 DWORD PTR [ecx+12], edx
$LN51@CommitMiss@2:

; 199  : 
; 200  : 				if (s->GetElementIndex() == 1)

  000e2	b9 01 00 00 00	 mov	 ecx, 1
  000e7	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  000ea	75 03		 jne	 SHORT $LN57@CommitMiss@2

; 201  : 				group->SetSorties(group->Sorties() + 1);

  000ec	01 48 78	 add	 DWORD PTR [eax+120], ecx
$LN57@CommitMiss@2:

; 202  : 
; 203  : 				group->SetKills(group->Kills() + s->GetGunKills() + s->GetMissileKills());

  000ef	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  000f2	03 4e 38	 add	 ecx, DWORD PTR [esi+56]
  000f5	01 48 7c	 add	 DWORD PTR [eax+124], ecx

; 204  : 				group->SetPoints(group->Points() + s->GetPoints());

  000f8	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  000fb	01 90 80 00 00
	00		 add	 DWORD PTR [eax+128], edx
$LN71@CommitMiss@2:

; 205  : 			}
; 206  : 
; 207  : 			if (s->IsPlayer()) {

  00101	80 7e 28 00	 cmp	 BYTE PTR [esi+40], 0
  00105	74 4d		 je	 SHORT $LN7@CommitMiss@2

; 208  : 				Player* p = Player::GetCurrentPlayer();

  00107	e8 00 00 00 00	 call	 ?GetCurrentPlayer@Player@@SAPAV1@XZ ; Player::GetCurrentPlayer
  0010c	8b f8		 mov	 edi, eax

; 209  : 				p->ProcessStats(s, start_time);

  0010e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00111	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00117	51		 push	 ecx
  00118	56		 push	 esi
  00119	8b c7		 mov	 eax, edi
  0011b	e8 00 00 00 00	 call	 ?ProcessStats@Player@@QAEXPAVShipStats@@K@Z ; Player::ProcessStats

; 210  : 
; 211  : 				if (mission && mission->Type() == Mission::TRAINING && 
; 212  : 						s->GetDeaths() == 0 && s->GetColls() == 0)

  00120	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00123	8b 82 c0 00 00
	00		 mov	 eax, DWORD PTR [edx+192]
  00129	85 c0		 test	 eax, eax
  0012b	74 1f		 je	 SHORT $LN1@CommitMiss@2
  0012d	83 b8 a4 00 00
	00 16		 cmp	 DWORD PTR [eax+164], 22	; 00000016H
  00134	75 16		 jne	 SHORT $LN1@CommitMiss@2
  00136	83 7e 40 00	 cmp	 DWORD PTR [esi+64], 0
  0013a	75 10		 jne	 SHORT $LN1@CommitMiss@2
  0013c	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  00140	75 0a		 jne	 SHORT $LN1@CommitMiss@2

; 213  : 				p->SetTrained(mission->Identity());

  00142	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00145	8b d7		 mov	 edx, edi
  00147	e8 00 00 00 00	 call	 ?SetTrained@Player@@QAEXH@Z ; Player::SetTrained
$LN1@CommitMiss@2:

; 214  : 
; 215  : 				Player::Save(); // save training state right now before we forget!

  0014c	e8 00 00 00 00	 call	 ?Save@Player@@SAXXZ	; Player::Save
  00151	8b 7d f0	 mov	 edi, DWORD PTR _tk2$118317[ebp]
$LN7@CommitMiss@2:

; 173  : 
; 174  : 		for (int i = 0; i < ShipStats::NumStats(); i++) {

  00154	8b 4d fc	 mov	 ecx, DWORD PTR _i$118320[ebp]
  00157	41		 inc	 ecx
  00158	89 4d fc	 mov	 DWORD PTR _i$118320[ebp], ecx
  0015b	e8 00 00 00 00	 call	 ?NumStats@ShipStats@@SAHXZ ; ShipStats::NumStats
  00160	3b c8		 cmp	 ecx, eax
  00162	0f 8c 1a ff ff
	ff		 jl	 $LN8@CommitMiss@2
$LN6@CommitMiss@2:

; 216  : 			}
; 217  : 		}
; 218  : 
; 219  : 		Print("--------------------------------------------\n");

  00168	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@IHAFINE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
  0016d	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 220  : 		Print("TOTAL             %5d  %5d  %5d  %5d\n\n", tk1, tk2, td, tc);

  00172	8b 45 f8	 mov	 eax, DWORD PTR _tc$118319[ebp]
  00175	8b 4d f4	 mov	 ecx, DWORD PTR _td$118318[ebp]
  00178	83 c4 04	 add	 esp, 4
  0017b	50		 push	 eax
  0017c	51		 push	 ecx
  0017d	57		 push	 edi
  0017e	53		 push	 ebx
  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GLANDEFM@TOTAL?5?5?5?5?5?5?5?5?5?5?5?5?5?$CF5d?5?5?$CF5d?5?5?$CF5d?5@
  00184	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00189	83 c4 14	 add	 esp, 20			; 00000014H

; 221  : 
; 222  : 		ShipStats::Initialize();

  0018c	e8 00 00 00 00	 call	 ?Initialize@ShipStats@@SAXXZ ; ShipStats::Initialize
$LN9@CommitMiss@2:

; 223  : 	}
; 224  : }

  00191	5f		 pop	 edi
  00192	5e		 pop	 esi
  00193	5b		 pop	 ebx
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 04 00	 ret	 4
?CommitMission@Sim@@QAEXXZ ENDP				; Sim::CommitMission
_TEXT	ENDS
PUBLIC	??1Sim@@UAE@XZ					; Sim::~Sim
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\universe.h
xdata$x	SEGMENT
__unwindtable$??1Sim@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Sim@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Sim@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1Sim@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1Sim@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1Sim@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1Sim@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1Sim@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1Sim@@UAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1Sim@@UAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1Sim@@UAE@XZ$9
__ehfuncinfo$??1Sim@@UAE@XZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??1Sim@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ??1Sim@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Sim@@UAE@XZ PROC					; Sim::~Sim, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1Sim@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  00029	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7Sim@@6B@
  0002f	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9

; 144  : 	UnloadMission();

  00036	e8 00 00 00 00	 call	 ?UnloadMission@Sim@@QAEXXZ ; Sim::UnloadMission

; 145  : 
; 146  : 	Shot::Close();
; 147  : 	FlightDeck::Close();

  0003b	e8 00 00 00 00	 call	 ?Close@FlightDeck@@SAXXZ ; FlightDeck::Close

; 148  : 	NavLight::Close();
; 149  : 	Token::close();

  00040	e8 00 00 00 00	 call	 ?close@Token@@SAXXZ	; Token::close

; 150  : 	Asteroid::Close();

  00045	e8 00 00 00 00	 call	 ?Close@Asteroid@@SAXXZ	; Asteroid::Close

; 151  : 
; 152  : 	if (sim == this)

  0004a	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?sim@Sim@@1PAV1@A, edi ; Sim::sim
  00050	75 0a		 jne	 SHORT $LN1@Sim

; 153  : 	sim = 0;

  00052	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?sim@Sim@@1PAV1@A, 0 ; Sim::sim
$LN1@Sim:

; 154  : }

  0005c	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00060	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [edi+180]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006c	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00078	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0007c	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00088	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0008c	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00098	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000a4	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000ad	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000b1	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ba	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000be	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c7	83 c4 20	 add	 esp, 32			; 00000020H
  000ca	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  000cd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000d1	e8 00 00 00 00	 call	 ??1Scene@@UAE@XZ	; Scene::~Scene
  000d6	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7Universe@@6B@
  000dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e6	59		 pop	 ecx
  000e7	5f		 pop	 edi
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Sim@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Universe@@UAE@XZ	; Universe::~Universe
__unwindfunclet$??1Sim@@UAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000e	e9 00 00 00 00	 jmp	 ??1Scene@@UAE@XZ	; Scene::~Scene
__unwindfunclet$??1Sim@@UAE@XZ$2:
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 58	 add	 eax, 88			; 00000058H
  00019	e9 00 00 00 00	 jmp	 ??1?$List@VSimRegion@@@@QAE@XZ ; List<SimRegion>::~List<SimRegion>
__unwindfunclet$??1Sim@@UAE@XZ$3:
  0001e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c0 64	 add	 eax, 100		; 00000064H
  00024	e9 00 00 00 00	 jmp	 ??1?$List@VSimRegion@@@@QAE@XZ ; List<SimRegion>::~List<SimRegion>
__unwindfunclet$??1Sim@@UAE@XZ$4:
  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 c0 70	 add	 eax, 112		; 00000070H
  0002f	e9 00 00 00 00	 jmp	 ??1?$List@VSimHyper@@@@QAE@XZ ; List<SimHyper>::~List<SimHyper>
__unwindfunclet$??1Sim@@UAE@XZ$5:
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 7c	 add	 eax, 124		; 0000007cH
  0003a	e9 00 00 00 00	 jmp	 ??1?$List@VSimSplash@@@@QAE@XZ ; List<SimSplash>::~List<SimSplash>
__unwindfunclet$??1Sim@@UAE@XZ$6:
  0003f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00042	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00047	e9 00 00 00 00	 jmp	 ??1?$List@VElement@@@@QAE@XZ ; List<Element>::~List<Element>
__unwindfunclet$??1Sim@@UAE@XZ$7:
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	05 94 00 00 00	 add	 eax, 148		; 00000094H
  00054	e9 00 00 00 00	 jmp	 ??1?$List@VElement@@@@QAE@XZ ; List<Element>::~List<Element>
__unwindfunclet$??1Sim@@UAE@XZ$8:
  00059	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00061	e9 00 00 00 00	 jmp	 ??1?$List@VMissionEvent@@@@QAE@XZ ; List<MissionEvent>::~List<MissionEvent>
__unwindfunclet$??1Sim@@UAE@XZ$9:
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	05 ac 00 00 00	 add	 eax, 172		; 000000acH
  0006e	e9 00 00 00 00	 jmp	 ??1?$List@VMissionElement@@@@QAE@XZ ; List<MissionElement>::~List<MissionElement>
__ehhandler$??1Sim@@UAE@XZ:
  00073	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00077	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0007a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0007d	33 c8		 xor	 ecx, eax
  0007f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00084	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1Sim@@UAE@XZ
  00089	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1Sim@@UAE@XZ ENDP					; Sim::~Sim
; Function compile flags: /Ogtp
;	COMDAT ??_GSim@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSim@@UAEPAXI@Z PROC					; Sim::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1Sim@@UAE@XZ		; Sim::~Sim
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@7
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@7:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GSim@@UAEPAXI@Z ENDP					; Sim::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0Sim@@QAE@PAVMotionController@@@Z		; Sim::Sim
;	COMDAT xdata$x
; File c:\matrix games\dev\foundationex\list.h
xdata$x	SEGMENT
__unwindtable$??0Sim@@QAE@PAVMotionController@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$9
__ehfuncinfo$??0Sim@@QAE@PAVMotionController@@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??0Sim@@QAE@PAVMotionController@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ??0Sim@@QAE@PAVMotionController@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_c$ = 12						; size = 4
??0Sim@@QAE@PAVMotionController@@@Z PROC		; Sim::Sim, COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Sim@@QAE@PAVMotionController@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00027	33 db		 xor	 ebx, ebx
  00029	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0002c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Sim@@6B@
  00035	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00038	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0003b	e8 00 00 00 00	 call	 ??0Scene@@QAE@XZ	; Scene::Scene
  00040	89 5e 50	 mov	 DWORD PTR [esi+80], ebx
  00043	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  00046	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx
  00049	89 5e 60	 mov	 DWORD PTR [esi+96], ebx
  0004c	89 5e 64	 mov	 DWORD PTR [esi+100], ebx
  0004f	89 5e 68	 mov	 DWORD PTR [esi+104], ebx
  00052	89 5e 6c	 mov	 DWORD PTR [esi+108], ebx
  00055	89 5e 70	 mov	 DWORD PTR [esi+112], ebx
  00058	89 5e 74	 mov	 DWORD PTR [esi+116], ebx
  0005b	89 5e 78	 mov	 DWORD PTR [esi+120], ebx
  0005e	89 5e 7c	 mov	 DWORD PTR [esi+124], ebx
  00061	89 9e 80 00 00
	00		 mov	 DWORD PTR [esi+128], ebx
  00067	89 9e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ebx
  0006d	89 9e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ebx
  00073	89 9e 8c 00 00
	00		 mov	 DWORD PTR [esi+140], ebx
  00079	89 9e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ebx
  0007f	89 9e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ebx
  00085	89 9e 98 00 00
	00		 mov	 DWORD PTR [esi+152], ebx
  0008b	89 9e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ebx
  00091	89 9e a0 00 00
	00		 mov	 DWORD PTR [esi+160], ebx
  00097	89 9e a4 00 00
	00		 mov	 DWORD PTR [esi+164], ebx
  0009d	89 9e a8 00 00
	00		 mov	 DWORD PTR [esi+168], ebx
  000a3	89 9e ac 00 00
	00		 mov	 DWORD PTR [esi+172], ebx
  000a9	89 9e b0 00 00
	00		 mov	 DWORD PTR [esi+176], ebx
  000af	89 9e b4 00 00
	00		 mov	 DWORD PTR [esi+180], ebx
  000b5	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000b8	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  000bc	89 86 b8 00 00
	00		 mov	 DWORD PTR [esi+184], eax
  000c2	66 89 9e bc 00
	00 00		 mov	 WORD PTR [esi+188], bx
  000c9	89 9e c0 00 00
	00		 mov	 DWORD PTR [esi+192], ebx
  000cf	89 9e c4 00 00
	00		 mov	 DWORD PTR [esi+196], ebx
  000d5	89 9e c8 00 00
	00		 mov	 DWORD PTR [esi+200], ebx

; 128  : 	Drive::Initialize();

  000db	e8 00 00 00 00	 call	 ?Initialize@Drive@@SAXXZ ; Drive::Initialize

; 129  : 	Explosion::Initialize();

  000e0	e8 00 00 00 00	 call	 ?Initialize@Explosion@@SAXXZ ; Explosion::Initialize

; 130  : 	FlightDeck::Initialize();

  000e5	e8 00 00 00 00	 call	 ?Initialize@FlightDeck@@SAXXZ ; FlightDeck::Initialize

; 131  : 	NavLight::Initialize();

  000ea	e8 00 00 00 00	 call	 ?Initialize@NavLight@@SAXXZ ; NavLight::Initialize

; 132  : 	Shot::Initialize();
; 133  : 	MFD::Initialize();

  000ef	e8 00 00 00 00	 call	 ?Initialize@MFD@@SAXXZ	; MFD::Initialize

; 134  : 	Asteroid::Initialize();

  000f4	e8 00 00 00 00	 call	 ?Initialize@Asteroid@@SAXXZ ; Asteroid::Initialize

; 135  : 
; 136  : 	if (!sim)

  000f9	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?sim@Sim@@1PAV1@A, ebx ; Sim::sim
  000ff	75 06		 jne	 SHORT $LN1@Sim@2

; 137  : 	sim = this;

  00101	89 35 00 00 00
	00		 mov	 DWORD PTR ?sim@Sim@@1PAV1@A, esi ; Sim::sim
$LN1@Sim@2:

; 138  : 
; 139  : 	cam_dir = CameraDirector::GetInstance();

  00107	e8 00 00 00 00	 call	 ?GetInstance@CameraDirector@@SAPAV1@XZ ; CameraDirector::GetInstance
  0010c	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 140  : }

  0010f	8b c6		 mov	 eax, esi
  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$0:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Universe@@UAE@XZ	; Universe::~Universe
__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$1:
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000e	e9 00 00 00 00	 jmp	 ??1Scene@@UAE@XZ	; Scene::~Scene
__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$2:
  00013	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 58	 add	 eax, 88			; 00000058H
  00019	e9 00 00 00 00	 jmp	 ??1?$List@VSimRegion@@@@QAE@XZ ; List<SimRegion>::~List<SimRegion>
__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$3:
  0001e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c0 64	 add	 eax, 100		; 00000064H
  00024	e9 00 00 00 00	 jmp	 ??1?$List@VSimRegion@@@@QAE@XZ ; List<SimRegion>::~List<SimRegion>
__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$4:
  00029	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 c0 70	 add	 eax, 112		; 00000070H
  0002f	e9 00 00 00 00	 jmp	 ??1?$List@VSimHyper@@@@QAE@XZ ; List<SimHyper>::~List<SimHyper>
__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$5:
  00034	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 7c	 add	 eax, 124		; 0000007cH
  0003a	e9 00 00 00 00	 jmp	 ??1?$List@VSimSplash@@@@QAE@XZ ; List<SimSplash>::~List<SimSplash>
__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$6:
  0003f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00042	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00047	e9 00 00 00 00	 jmp	 ??1?$List@VElement@@@@QAE@XZ ; List<Element>::~List<Element>
__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$7:
  0004c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	05 94 00 00 00	 add	 eax, 148		; 00000094H
  00054	e9 00 00 00 00	 jmp	 ??1?$List@VElement@@@@QAE@XZ ; List<Element>::~List<Element>
__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$8:
  00059	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00061	e9 00 00 00 00	 jmp	 ??1?$List@VMissionEvent@@@@QAE@XZ ; List<MissionEvent>::~List<MissionEvent>
__unwindfunclet$??0Sim@@QAE@PAVMotionController@@@Z$9:
  00066	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00069	05 ac 00 00 00	 add	 eax, 172		; 000000acH
  0006e	e9 00 00 00 00	 jmp	 ??1?$List@VMissionElement@@@@QAE@XZ ; List<MissionElement>::~List<MissionElement>
__ehhandler$??0Sim@@QAE@PAVMotionController@@@Z:
  00073	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00077	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0007a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0007d	33 c8		 xor	 ecx, eax
  0007f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00084	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Sim@@QAE@PAVMotionController@@@Z
  00089	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Sim@@QAE@PAVMotionController@@@Z ENDP		; Sim::Sim
PUBLIC	?NextView@SimRegion@@QAEXXZ			; SimRegion::NextView
; Function compile flags: /Ogtp
;	COMDAT ?NextView@SimRegion@@QAEXXZ
_TEXT	SEGMENT
?NextView@SimRegion@@QAEXXZ PROC			; SimRegion::NextView, COMDAT
; _this$ = eax

; 2363 : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 2364 : 	if (ships.size()) {

  00003	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00007	57		 push	 edi
  00008	0f 84 85 00 00
	00		 je	 $LN3@NextView

; 2365 : 		int original_view = current_view;

  0000e	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00011	53		 push	 ebx
  00012	8b d8		 mov	 ebx, eax
$LL8@NextView:

; 2366 : 
; 2367 : 		do {
; 2368 : 			current_view++;

  00014	40		 inc	 eax
  00015	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 2369 : 			if (current_view >= ships.size()) {

  00018	3b 46 4c	 cmp	 eax, DWORD PTR [esi+76]
  0001b	7c 07		 jl	 SHORT $LN7@NextView

; 2370 : 				current_view = 0;

  0001d	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
$LN7@NextView:

; 2371 : 			}
; 2372 : 		}
; 2373 : 		while (ships[current_view]->Life() == 0 && current_view != original_view);

  00024	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00027	50		 push	 eax
  00028	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  0002b	e8 00 00 00 00	 call	 ??A?$List@VShip@@@@QAEAAPAVShip@@H@Z ; List<Ship>::operator[]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	f2 0f 10 80 a8
	01 00 00	 movsd	 xmm0, QWORD PTR [eax+424]
  0003a	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00042	9f		 lahf
  00043	f6 c4 44	 test	 ah, 68			; 00000044H
  00046	7a 07		 jp	 SHORT $LN4@NextView
  00048	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  0004b	3b c3		 cmp	 eax, ebx
  0004d	75 c5		 jne	 SHORT $LL8@NextView
$LN4@NextView:

; 2374 : 
; 2375 : 		if (current_view != original_view) {

  0004f	39 5e 48	 cmp	 DWORD PTR [esi+72], ebx
  00052	5b		 pop	 ebx
  00053	74 3e		 je	 SHORT $LN3@NextView

; 2376 : 			ClearSelection();

  00055	8b c6		 mov	 eax, esi
  00057	e8 00 00 00 00	 call	 ?ClearSelection@SimRegion@@QAEXXZ ; SimRegion::ClearSelection

; 2377 : 
; 2378 : 			if (!sim->IsTestMode())

  0005c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005f	80 b9 bc 00 00
	00 00		 cmp	 BYTE PTR [ecx+188], 0
  00066	75 0f		 jne	 SHORT $LN26@NextView

; 2379 : 			player_ship->SetControls(0);

  00068	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0006b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006d	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  00073	6a 00		 push	 0
  00075	ff d0		 call	 eax
$LN26@NextView:

; 2380 : 
; 2381 : 			if (player_ship->Rep())

  00077	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0007a	8b 89 bc 01 00
	00		 mov	 ecx, DWORD PTR [ecx+444]
  00080	85 c9		 test	 ecx, ecx
  00082	74 07		 je	 SHORT $LN1@NextView

; 2382 : 			player_ship->Rep()->Show();

  00084	8b 11		 mov	 edx, DWORD PTR [ecx]
  00086	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00089	ff d0		 call	 eax
$LN1@NextView:

; 2383 : 
; 2384 : 			AttachPlayerShip(current_view);

  0008b	8b 7e 48	 mov	 edi, DWORD PTR [esi+72]
  0008e	e8 00 00 00 00	 call	 ?AttachPlayerShip@SimRegion@@IAEXH@Z ; SimRegion::AttachPlayerShip
$LN3@NextView:

; 2385 : 		}
; 2386 : 	}
; 2387 : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	c3		 ret	 0
?NextView@SimRegion@@QAEXXZ ENDP			; SimRegion::NextView
_TEXT	ENDS
PUBLIC	??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z	; SimRegion::SimRegion
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\geometry.h
xdata$x	SEGMENT
__unwindtable$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$13
	DD	0bH
	DD	FLAT:__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$14
__ehfuncinfo$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z
_TEXT	SEGMENT
_init_loc$120326 = -52					; size = 24
$T374449 = -24						; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_s$ = 12						; size = 4
$T374446 = 16						; size = 4
$T374442 = 16						; size = 4
_r$ = 16						; size = 4
??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z PROC	; SimRegion::SimRegion, COMDAT

; 2244 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0002e	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  00031	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7SimRegion@@6B@
  00037	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0003a	e8 00 00 00 00	 call	 ??0Text@@QAE@XZ		; Text::Text
  0003f	33 ff		 xor	 edi, edi
  00041	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00044	8b 4d 10	 mov	 ecx, DWORD PTR _r$[ebp]
  00047	0f 57 c0	 xorps	 xmm0, xmm0
  0004a	89 7b 14	 mov	 DWORD PTR [ebx+20], edi
  0004d	89 7b 18	 mov	 DWORD PTR [ebx+24], edi
  00050	89 4b 1c	 mov	 DWORD PTR [ebx+28], ecx
  00053	f2 0f 11 43 20	 movsd	 QWORD PTR [ebx+32], xmm0
  00058	f2 0f 11 43 28	 movsd	 QWORD PTR [ebx+40], xmm0
  0005d	f2 0f 11 43 30	 movsd	 QWORD PTR [ebx+48], xmm0
  00062	89 7b 38	 mov	 DWORD PTR [ebx+56], edi
  00065	89 7b 3c	 mov	 DWORD PTR [ebx+60], edi
  00068	c6 43 40 00	 mov	 BYTE PTR [ebx+64], 0
  0006c	89 7b 44	 mov	 DWORD PTR [ebx+68], edi
  0006f	89 7b 48	 mov	 DWORD PTR [ebx+72], edi
  00072	89 7b 4c	 mov	 DWORD PTR [ebx+76], edi
  00075	89 7b 50	 mov	 DWORD PTR [ebx+80], edi
  00078	89 7b 54	 mov	 DWORD PTR [ebx+84], edi
  0007b	89 7b 58	 mov	 DWORD PTR [ebx+88], edi
  0007e	89 7b 5c	 mov	 DWORD PTR [ebx+92], edi
  00081	89 7b 60	 mov	 DWORD PTR [ebx+96], edi
  00084	89 7b 64	 mov	 DWORD PTR [ebx+100], edi
  00087	89 7b 68	 mov	 DWORD PTR [ebx+104], edi
  0008a	89 7b 6c	 mov	 DWORD PTR [ebx+108], edi
  0008d	89 7b 70	 mov	 DWORD PTR [ebx+112], edi
  00090	89 7b 74	 mov	 DWORD PTR [ebx+116], edi
  00093	89 7b 78	 mov	 DWORD PTR [ebx+120], edi
  00096	89 7b 7c	 mov	 DWORD PTR [ebx+124], edi
  00099	89 bb 80 00 00
	00		 mov	 DWORD PTR [ebx+128], edi
  0009f	89 bb 84 00 00
	00		 mov	 DWORD PTR [ebx+132], edi
  000a5	89 bb 88 00 00
	00		 mov	 DWORD PTR [ebx+136], edi
  000ab	89 bb 8c 00 00
	00		 mov	 DWORD PTR [ebx+140], edi
  000b1	89 bb 90 00 00
	00		 mov	 DWORD PTR [ebx+144], edi
  000b7	89 bb 94 00 00
	00		 mov	 DWORD PTR [ebx+148], edi
  000bd	89 bb 98 00 00
	00		 mov	 DWORD PTR [ebx+152], edi
  000c3	89 bb 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], edi
  000c9	89 bb a0 00 00
	00		 mov	 DWORD PTR [ebx+160], edi
  000cf	89 bb a4 00 00
	00		 mov	 DWORD PTR [ebx+164], edi
  000d5	89 bb a8 00 00
	00		 mov	 DWORD PTR [ebx+168], edi
  000db	89 bb ac 00 00
	00		 mov	 DWORD PTR [ebx+172], edi
  000e1	89 bb b0 00 00
	00		 mov	 DWORD PTR [ebx+176], edi
  000e7	89 bb b4 00 00
	00		 mov	 DWORD PTR [ebx+180], edi
  000ed	68 00 00 00 00	 push	 OFFSET ??1?$List@VContact@@@@QAE@XZ ; List<Contact>::~List<Contact>
  000f2	68 00 00 00 00	 push	 OFFSET ??0?$List@VContact@@@@QAE@XZ ; List<Contact>::List<Contact>
  000f7	6a 05		 push	 5
  000f9	6a 0c		 push	 12			; 0000000cH
  000fb	8d 93 b8 00 00
	00		 lea	 edx, DWORD PTR [ebx+184]
  00101	52		 push	 edx
  00102	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00106	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0010b	89 bb f4 00 00
	00		 mov	 DWORD PTR [ebx+244], edi
  00111	89 bb f8 00 00
	00		 mov	 DWORD PTR [ebx+248], edi
  00117	89 bb fc 00 00
	00		 mov	 DWORD PTR [ebx+252], edi
  0011d	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH

; 2245 : 	if (r) {

  00121	8b 45 10	 mov	 eax, DWORD PTR _r$[ebp]
  00124	89 bb 00 01 00
	00		 mov	 DWORD PTR [ebx+256], edi
  0012a	89 bb 04 01 00
	00		 mov	 DWORD PTR [ebx+260], edi
  00130	3b c7		 cmp	 eax, edi
  00132	74 09		 je	 SHORT $LN9@SimRegion@3

; 2246 : 		star_system = r->System();

  00134	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [eax+232]
  0013a	89 43 18	 mov	 DWORD PTR [ebx+24], eax
$LN9@SimRegion@3:

; 2247 : 	}
; 2248 : 
; 2249 : 	if (orbital_region) {

  0013d	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00140	3b c7		 cmp	 eax, edi
  00142	0f 84 57 01 00
	00		 je	 $LN8@SimRegion@3

; 2250 : 		name = orbital_region->Name();

  00148	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0014b	50		 push	 eax
  0014c	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  0014f	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=

; 2251 : 		grid = new(__FILE__,__LINE__) Grid((int) orbital_region->Radius(),
; 2252 : 		(int) orbital_region->GridSpace());

  00154	68 80 00 00 00	 push	 128			; 00000080H
  00159	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0015e	83 c4 04	 add	 esp, 4
  00161	89 45 10	 mov	 DWORD PTR $T374442[ebp], eax
  00164	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00168	3b c7		 cmp	 eax, edi
  0016a	74 20		 je	 SHORT $LN12@SimRegion@3
  0016c	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  0016f	f2 0f 10 49 28	 movsd	 xmm1, QWORD PTR [ecx+40]
  00174	f2 0f 2c 89 00
	01 00 00	 cvttsd2si ecx, QWORD PTR [ecx+256]
  0017c	51		 push	 ecx
  0017d	8b f0		 mov	 esi, eax
  0017f	f2 0f 2c f9	 cvttsd2si edi, xmm1
  00183	e8 00 00 00 00	 call	 ??0Grid@@QAE@HH@Z	; Grid::Grid
  00188	33 ff		 xor	 edi, edi
  0018a	eb 02		 jmp	 SHORT $LN13@SimRegion@3
$LN12@SimRegion@3:
  0018c	33 c0		 xor	 eax, eax
$LN13@SimRegion@3:
  0018e	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH

; 2253 : 
; 2254 : 
; 2255 : 		if (orbital_region->Type() == Orbital::TERRAIN) {

  00192	8b 73 1c	 mov	 esi, DWORD PTR [ebx+28]
  00195	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  00198	83 7e 10 05	 cmp	 DWORD PTR [esi+16], 5
  0019c	75 3f		 jne	 SHORT $LN7@SimRegion@3

; 2256 : 			TerrainRegion* trgn = (TerrainRegion*) orbital_region;
; 2257 : 			terrain = new(__FILE__,__LINE__) Terrain(trgn);

  0019e	68 70 05 00 00	 push	 1392			; 00000570H
  001a3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001a8	83 c4 04	 add	 esp, 4
  001ab	89 45 10	 mov	 DWORD PTR $T374446[ebp], eax
  001ae	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  001b2	3b c7		 cmp	 eax, edi
  001b4	74 16		 je	 SHORT $LN14@SimRegion@3
  001b6	56		 push	 esi
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 ??0Terrain@@QAE@PAVTerrainRegion@@@Z ; Terrain::Terrain
  001bd	89 43 3c	 mov	 DWORD PTR [ebx+60], eax

; 2258 : 
; 2259 : 			type = AIR_SPACE;

  001c0	c7 43 14 01 00
	00 00		 mov	 DWORD PTR [ebx+20], 1
  001c7	e9 fd 00 00 00	 jmp	 $LN78@SimRegion@3
$LN14@SimRegion@3:

; 2256 : 			TerrainRegion* trgn = (TerrainRegion*) orbital_region;
; 2257 : 			terrain = new(__FILE__,__LINE__) Terrain(trgn);

  001cc	33 c0		 xor	 eax, eax
  001ce	89 43 3c	 mov	 DWORD PTR [ebx+60], eax

; 2258 : 
; 2259 : 			type = AIR_SPACE;

  001d1	c7 43 14 01 00
	00 00		 mov	 DWORD PTR [ebx+20], 1
  001d8	e9 ec 00 00 00	 jmp	 $LN78@SimRegion@3
$LN7@SimRegion@3:

; 2260 : 		}
; 2261 : 
; 2262 : 		else if (orbital_region->Asteroids() > 0) {

  001dd	8b b6 10 01 00
	00		 mov	 esi, DWORD PTR [esi+272]
  001e3	3b f7		 cmp	 esi, edi
  001e5	0f 8e de 00 00
	00		 jle	 $LN78@SimRegion@3
  001eb	eb 03 8d 49 00	 npad	 5
$LL4@SimRegion@3:

; 2263 : 			int asteroids = orbital_region->Asteroids();
; 2264 : 
; 2265 : 			for (int i = 0; i < asteroids; i++) {
; 2266 : 				Point init_loc((rand()-16384.0f) * 30,
; 2267 : 				(rand()-16384.0f) * 3,
; 2268 : 				(rand()-16384.0f) * 30);

  001f0	e8 00 00 00 00	 call	 _rand
  001f5	0f 57 c0	 xorps	 xmm0, xmm0
  001f8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001fc	0f 5a c0	 cvtps2pd xmm0, xmm0
  001ff	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@40d0000000000000
  00207	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR _TIME_TO_DOCK
  0020f	f2 0f 11 45 cc	 movsd	 QWORD PTR _init_loc$120326[ebp], xmm0
  00214	e8 00 00 00 00	 call	 _rand
  00219	0f 57 c0	 xorps	 xmm0, xmm0
  0021c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00220	0f 5a c0	 cvtps2pd xmm0, xmm0
  00223	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@40d0000000000000
  0022b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4008000000000000
  00233	f2 0f 11 45 d4	 movsd	 QWORD PTR _init_loc$120326[ebp+8], xmm0
  00238	e8 00 00 00 00	 call	 _rand
  0023d	0f 57 c0	 xorps	 xmm0, xmm0
  00240	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00244	0f 5a c0	 cvtps2pd xmm0, xmm0
  00247	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@40d0000000000000
  0024f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR _TIME_TO_DOCK
  00257	f2 0f 11 45 dc	 movsd	 QWORD PTR _init_loc$120326[ebp+16], xmm0

; 2269 : 				sim->CreateAsteroid(init_loc, i, Random(1e7, 1e8), this); 

  0025c	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4197d78400000000
  00264	83 ec 10	 sub	 esp, 16			; 00000010H
  00267	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  0026d	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@416312d000000000
  00275	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0027a	e8 00 00 00 00	 call	 ?Random@@YANNN@Z	; Random
  0027f	dd 5c 24 08	 fstp	 QWORD PTR [esp+8]
  00283	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00286	83 c4 08	 add	 esp, 8
  00289	53		 push	 ebx
  0028a	57		 push	 edi
  0028b	52		 push	 edx
  0028c	8d 4d cc	 lea	 ecx, DWORD PTR _init_loc$120326[ebp]
  0028f	e8 00 00 00 00	 call	 ?CreateAsteroid@Sim@@QAEPAVAsteroid@@ABUPoint@@HNPAVSimRegion@@@Z ; Sim::CreateAsteroid
  00294	47		 inc	 edi
  00295	3b fe		 cmp	 edi, esi
  00297	0f 8c 53 ff ff
	ff		 jl	 $LL4@SimRegion@3

; 2270 : 			}
; 2271 : 		}
; 2272 : 	}
; 2273 : 	else {

  0029d	eb 2a		 jmp	 SHORT $LN78@SimRegion@3
$LN8@SimRegion@3:

; 2274 : 		name = Game::GetText("Unknown");

  0029f	8d 45 e8	 lea	 eax, DWORD PTR $T374449[ebp]
  002a2	68 00 00 00 00	 push	 OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
  002a7	50		 push	 eax
  002a8	e8 00 00 00 00	 call	 ?GetText@Game@@SA?AVText@@PBD@Z ; Game::GetText
  002ad	83 c4 08	 add	 esp, 8
  002b0	50		 push	 eax
  002b1	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  002b4	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  002b8	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@ABV0@@Z ; Text::operator=
  002bd	8d 4d e8	 lea	 ecx, DWORD PTR $T374449[ebp]
  002c0	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  002c4	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
$LN78@SimRegion@3:

; 2275 : 	}
; 2276 : }

  002c9	8b c3		 mov	 eax, ebx
  002cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002d5	59		 pop	 ecx
  002d6	5f		 pop	 edi
  002d7	5e		 pop	 esi
  002d8	5b		 pop	 ebx
  002d9	8b e5		 mov	 esp, ebp
  002db	5d		 pop	 ebp
  002dc	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$0:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$1:
  0000b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	83 c0 4c	 add	 eax, 76			; 0000004cH
  00011	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$2:
  00016	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c0 58	 add	 eax, 88			; 00000058H
  0001c	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$3:
  00021	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c0 64	 add	 eax, 100		; 00000064H
  00027	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$4:
  0002c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c0 70	 add	 eax, 112		; 00000070H
  00032	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$5:
  00037	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 c0 7c	 add	 eax, 124		; 0000007cH
  0003d	e9 00 00 00 00	 jmp	 ??1?$List@VShot@@@@QAE@XZ ; List<Shot>::~List<Shot>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$6:
  00042	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00045	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0004a	e9 00 00 00 00	 jmp	 ??1?$List@VDrone@@@@QAE@XZ ; List<Drone>::~List<Drone>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$7:
  0004f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00052	05 94 00 00 00	 add	 eax, 148		; 00000094H
  00057	e9 00 00 00 00	 jmp	 ??1?$List@VExplosion@@@@QAE@XZ ; List<Explosion>::~List<Explosion>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$8:
  0005c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00064	e9 00 00 00 00	 jmp	 ??1?$List@VDebris@@@@QAE@XZ ; List<Debris>::~List<Debris>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$9:
  00069	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	05 ac 00 00 00	 add	 eax, 172		; 000000acH
  00071	e9 00 00 00 00	 jmp	 ??1?$List@VAsteroid@@@@QAE@XZ ; List<Asteroid>::~List<Asteroid>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$10:
  00076	68 00 00 00 00	 push	 OFFSET ??1?$List@VContact@@@@QAE@XZ ; List<Contact>::~List<Contact>
  0007b	6a 05		 push	 5
  0007d	6a 0c		 push	 12			; 0000000cH
  0007f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00082	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0008d	c3		 ret	 0
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$11:
  0008e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00091	05 f4 00 00 00	 add	 eax, 244		; 000000f4H
  00096	e9 00 00 00 00	 jmp	 ??1?$List@VSimRegion@@@@QAE@XZ ; List<SimRegion>::~List<SimRegion>
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$12:
  0009b	68 cb 08 00 00	 push	 2251			; 000008cbH
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  000a5	8b 45 10	 mov	 eax, DWORD PTR $T374442[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	c3		 ret	 0
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$13:
  000b2	68 d1 08 00 00	 push	 2257			; 000008d1H
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  000bc	8b 45 10	 mov	 eax, DWORD PTR $T374446[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c8	c3		 ret	 0
__unwindfunclet$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z$14:
  000c9	8d 4d e8	 lea	 ecx, DWORD PTR $T374449[ebp]
  000cc	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__ehhandler$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z:
  000d1	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000d5	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000d8	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  000db	33 c8		 xor	 ecx, eax
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z
  000e7	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z ENDP	; SimRegion::SimRegion
PUBLIC	_elem$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z ; Sim::CreateMissionElement
;	COMDAT xdata$x
; File c:\matrix games\dev\stars45\mission.h
xdata$x	SEGMENT
__unwindtable$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$9
__ehfuncinfo$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z
_TEXT	SEGMENT
$T374589 = -144						; size = 4
_nav$120210 = -144					; size = 4
_squadron_index$120158 = -144				; size = 4
_elem$GSCopy$ = -140					; size = 4
_this$GSCopy$ = -136					; size = 4
$T374960 = -136						; size = 4
_num_inst$120198 = -136					; size = 4
_num_obj$120185 = -136					; size = 4
$T374590 = -132						; size = 4
$T374586 = -132						; size = 4
_design_path$120174 = -132				; size = 8
_design_path$120162 = -132				; size = 8
tv1225 = -124						; size = 4
$T374940 = -124						; size = 4
$T374585 = -124						; size = 4
$T374581 = -124						; size = 4
$T374577 = -124						; size = 4
$T374567 = -124						; size = 4
tv1143 = -120						; size = 4
$T374965 = -120						; size = 4
_msn_elem$ = -116					; size = 4
_fuel$120240 = -112					; size = 16
_nav_iter$120206 = -112					; size = 8
_instr$120203 = -112					; size = 8
$T374575 = -112						; size = 8
$T374574 = -112						; size = 24
$T374572 = -112						; size = 8
$T374571 = -112						; size = 24
_ammo$120239 = -88					; size = 64
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z PROC ; Sim::CreateMissionElement, COMDAT
; _elem$ = ecx

; 2027 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	89 84 24 80 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+148], eax
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c4		 xor	 eax, esp
  00032	50		 push	 eax
  00033	8d 84 24 98 00
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+164]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b f1		 mov	 esi, ecx

; 2028 : 	MissionElement* msn_elem = 0;

  00045	33 db		 xor	 ebx, ebx

; 2050 : 			msn_elem->SetRegion(carrier->GetRegion()->Name());

  00047	89 44 24 1c	 mov	 DWORD PTR _this$GSCopy$[esp+164], eax

; 2147 : 		}
; 2148 : 
; 2149 : 		for (int i = 0; i < elem->NumShips(); i++) {

  0004b	89 74 24 18	 mov	 DWORD PTR _elem$GSCopy$[esp+164], esi
  0004f	89 5c 24 30	 mov	 DWORD PTR _msn_elem$[esp+164], ebx
  00053	e8 00 00 00 00	 call	 ?IsSquadron@Element@@QBE_NXZ ; Element::IsSquadron
  00058	84 c0		 test	 al, al
  0005a	74 1f		 je	 SHORT $LN36@CreateMiss

; 2029 : 
; 2030 : 	if (elem->IsSquadron()) {
; 2031 : 		if (!elem->GetCarrier() || elem->GetCarrier()->Integrity() < 1)

  0005c	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  0005f	3b c3		 cmp	 eax, ebx
  00061	74 11		 je	 SHORT $LN35@CreateMiss
  00063	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0006b	0f 2f 80 b8 01
	00 00		 comiss	 xmm0, DWORD PTR [eax+440]
  00072	76 07		 jbe	 SHORT $LN36@CreateMiss
$LN35@CreateMiss:

; 2032 : 		return msn_elem;

  00074	33 c0		 xor	 eax, eax
  00076	e9 d9 07 00 00	 jmp	 $LN38@CreateMiss
$LN36@CreateMiss:

; 2033 : 	}
; 2034 : 
; 2035 : 	if (elem && !elem->IsNetObserver()) {

  0007b	3b f3		 cmp	 esi, ebx
  0007d	0f 84 cd 07 00
	00		 je	 $LN14@CreateMiss
  00083	e8 00 00 00 00	 call	 ?IsNetObserver@Element@@QBE_NXZ ; Element::IsNetObserver
  00088	84 c0		 test	 al, al
  0008a	0f 85 c0 07 00
	00		 jne	 $LN14@CreateMiss

; 2036 : 		msn_elem = new(__FILE__,__LINE__) MissionElement;

  00090	68 10 01 00 00	 push	 272			; 00000110H
  00095	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009a	83 c4 04	 add	 esp, 4
  0009d	89 44 24 28	 mov	 DWORD PTR $T374567[esp+164], eax
  000a1	89 9c 24 a0 00
	00 00		 mov	 DWORD PTR __$EHRec$[esp+172], ebx
  000a8	3b c3		 cmp	 eax, ebx
  000aa	74 08		 je	 SHORT $LN40@CreateMiss
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ??0MissionElement@@QAE@XZ ; MissionElement::MissionElement
  000b2	8b d8		 mov	 ebx, eax
$LN40@CreateMiss:
  000b4	c7 84 24 a0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+172], -1

; 2037 : 
; 2038 : 		msn_elem->SetName(elem->Name());

  000bf	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000c2	50		 push	 eax
  000c3	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  000c6	89 5c 24 34	 mov	 DWORD PTR _msn_elem$[esp+168], ebx
  000ca	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=

; 2039 : 		msn_elem->SetIFF(elem->GetIFF());

  000cf	8b 16		 mov	 edx, DWORD PTR [esi]
  000d1	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000d4	8b ce		 mov	 ecx, esi
  000d6	ff d0		 call	 eax
  000d8	89 43 44	 mov	 DWORD PTR [ebx+68], eax

; 2040 : 		msn_elem->SetMissionRole(elem->Type());

  000db	8b 46 18	 mov	 eax, DWORD PTR [esi+24]

; 2041 : 
; 2042 : 		if (elem->IsSquadron() && elem->GetCarrier()) {

  000de	8b ce		 mov	 ecx, esi
  000e0	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  000e3	e8 00 00 00 00	 call	 ?IsSquadron@Element@@QBE_NXZ ; Element::IsSquadron
  000e8	84 c0		 test	 al, al
  000ea	0f 84 57 01 00
	00		 je	 $LN33@CreateMiss
  000f0	8b 7e 7c	 mov	 edi, DWORD PTR [esi+124]
  000f3	85 ff		 test	 edi, edi
  000f5	0f 84 4c 01 00
	00		 je	 $LN33@CreateMiss

; 2043 : 			Ship* carrier = elem->GetCarrier();
; 2044 : 
; 2045 : 			msn_elem->SetCarrier(carrier->Name());

  000fb	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  000fe	51		 push	 ecx
  000ff	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  00102	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=

; 2046 : 			msn_elem->SetCount(elem->GetCount());

  00107	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0010a	89 43 38	 mov	 DWORD PTR [ebx+56], eax

; 2047 : 			msn_elem->SetLocation(carrier->Location().OtherHand());

  0010d	f2 0f 10 47 48	 movsd	 xmm0, QWORD PTR [edi+72]
  00112	f2 0f 10 4f 50	 movsd	 xmm1, QWORD PTR [edi+80]
  00117	f2 0f 10 57 58	 movsd	 xmm2, QWORD PTR [edi+88]
  0011c	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00124	8d 44 24 34	 lea	 eax, DWORD PTR $T374571[esp+164]
  00128	8b d3		 mov	 edx, ebx
  0012a	f2 0f 11 44 24
	34		 movsd	 QWORD PTR $T374571[esp+164], xmm0
  00130	f2 0f 11 54 24
	3c		 movsd	 QWORD PTR $T374571[esp+172], xmm2
  00136	f2 0f 11 4c 24
	44		 movsd	 QWORD PTR $T374571[esp+180], xmm1
  0013c	e8 00 00 00 00	 call	 ?SetLocation@MissionElement@@QAEXABUPoint@@@Z ; MissionElement::SetLocation

; 2048 : 
; 2049 : 			if (carrier->GetRegion())

  00141	8b 17		 mov	 edx, DWORD PTR [edi]
  00143	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00149	8b cf		 mov	 ecx, edi
  0014b	ff d0		 call	 eax
  0014d	85 c0		 test	 eax, eax
  0014f	74 18		 je	 SHORT $LN106@CreateMiss

; 2050 : 			msn_elem->SetRegion(carrier->GetRegion()->Name());

  00151	8b 17		 mov	 edx, DWORD PTR [edi]
  00153	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00159	8b cf		 mov	 ecx, edi
  0015b	ff d0		 call	 eax
  0015d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00160	50		 push	 eax
  00161	8d 4b 68	 lea	 ecx, DWORD PTR [ebx+104]
  00164	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=
$LN106@CreateMiss:

; 2051 : 
; 2052 : 			int      squadron_index = 0;
; 2053 : 			Hangar*  hangar = FindSquadron(elem->Name(), squadron_index);

  00169	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0016c	8d 4c 24 14	 lea	 ecx, DWORD PTR _squadron_index$120158[esp+164]
  00170	51		 push	 ecx
  00171	50		 push	 eax
  00172	8b 44 24 24	 mov	 eax, DWORD PTR _this$GSCopy$[esp+172]
  00176	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _squadron_index$120158[esp+172], 0
  0017e	e8 00 00 00 00	 call	 ?FindSquadron@Sim@@IAEPAVHangar@@PBDAAH@Z ; Sim::FindSquadron
  00183	8b f8		 mov	 edi, eax

; 2054 : 
; 2055 : 			if (hangar) {

  00185	85 ff		 test	 edi, edi
  00187	0f 84 cf 00 00
	00		 je	 $LN132@CreateMiss

; 2056 : 				msn_elem->SetDeadCount(hangar->NumShipsDead(squadron_index));

  0018d	8b 4c 24 14	 mov	 ecx, DWORD PTR _squadron_index$120158[esp+164]
  00191	8b d7		 mov	 edx, edi
  00193	e8 00 00 00 00	 call	 ?NumShipsDead@Hangar@@QBEHH@Z ; Hangar::NumShipsDead

; 2057 : 				msn_elem->SetMaintCount(hangar->NumShipsMaint(squadron_index));

  00198	8b 4c 24 14	 mov	 ecx, DWORD PTR _squadron_index$120158[esp+164]
  0019c	8b d7		 mov	 edx, edi
  0019e	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  001a1	e8 00 00 00 00	 call	 ?NumShipsMaint@Hangar@@QBEHH@Z ; Hangar::NumShipsMaint
  001a6	89 43 3c	 mov	 DWORD PTR [ebx+60], eax

; 2058 : 
; 2059 : 				const ShipDesign* design = hangar->SquadronDesign(squadron_index);

  001a9	8b 44 24 14	 mov	 eax, DWORD PTR _squadron_index$120158[esp+164]
  001ad	8b cf		 mov	 ecx, edi
  001af	e8 00 00 00 00	 call	 ?SquadronDesign@Hangar@@QBEPBVShipDesign@@H@Z ; Hangar::SquadronDesign

; 2060 : 				msn_elem->SetDesign(design);

  001b4	89 43 30	 mov	 DWORD PTR [ebx+48], eax

; 2061 : 
; 2062 : 				Text design_path = design->path_name;

  001b7	83 c0 40	 add	 eax, 64			; 00000040H
  001ba	50		 push	 eax
  001bb	8d 4c 24 24	 lea	 ecx, DWORD PTR _design_path$120162[esp+168]
  001bf	e8 00 00 00 00	 call	 ??0Text@@QAE@PBD@Z	; Text::Text

; 2063 : 				design_path.setSensitive(false);

  001c4	6a 00		 push	 0
  001c6	8d 4c 24 24	 lea	 ecx, DWORD PTR _design_path$120162[esp+168]
  001ca	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+176], 1
  001d5	e8 00 00 00 00	 call	 ?setSensitive@Text@@QAEX_N@Z ; Text::setSensitive

; 2064 : 
; 2065 : 				if (design_path.indexOf("/Mods/Ships") == 0) {

  001da	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PMIPMFJL@?1Mods?1Ships?$AA@
  001df	8d 4c 24 24	 lea	 ecx, DWORD PTR _design_path$120162[esp+168]
  001e3	e8 00 00 00 00	 call	 ?indexOf@Text@@QBEHPBD@Z ; Text::indexOf
  001e8	85 c0		 test	 eax, eax
  001ea	75 45		 jne	 SHORT $LN120@CreateMiss

; 2066 : 					design_path = design_path.substring(11, 1000);

  001ec	68 e8 03 00 00	 push	 1000			; 000003e8H
  001f1	6a 0b		 push	 11			; 0000000bH
  001f3	8d 54 24 3c	 lea	 edx, DWORD PTR $T374572[esp+172]
  001f7	52		 push	 edx
  001f8	8d 4c 24 2c	 lea	 ecx, DWORD PTR _design_path$120162[esp+176]
  001fc	e8 00 00 00 00	 call	 ?substring@Text@@QAE?AV1@HH@Z ; Text::substring
  00201	50		 push	 eax
  00202	8d 4c 24 24	 lea	 ecx, DWORD PTR _design_path$120162[esp+168]
  00206	c6 84 24 a4 00
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+176], 2
  0020e	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@ABV0@@Z ; Text::operator=
  00213	8d 4c 24 34	 lea	 ecx, DWORD PTR $T374572[esp+164]
  00217	c6 84 24 a0 00
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+172], 1
  0021f	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text

; 2067 : 					msn_elem->SetPath(design_path);

  00224	8b 44 24 20	 mov	 eax, DWORD PTR _design_path$120162[esp+164]
  00228	50		 push	 eax
  00229	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  0022c	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=
$LN120@CreateMiss:

; 2068 : 				}
; 2069 : 			}

  00231	8d 4c 24 20	 lea	 ecx, DWORD PTR _design_path$120162[esp+164]
  00235	c7 84 24 a0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+172], -1
  00240	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text

; 2070 : 		}
; 2071 : 
; 2072 : 		else {

  00245	eb 15		 jmp	 SHORT $LN132@CreateMiss
$LN33@CreateMiss:

; 2073 : 			msn_elem->SetSquadron(elem->GetSquadron());

  00247	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  0024d	50		 push	 eax
  0024e	8d 4b 1c	 lea	 ecx, DWORD PTR [ebx+28]
  00251	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=

; 2074 : 			msn_elem->SetCount(elem->NumShips());

  00256	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00259	89 43 38	 mov	 DWORD PTR [ebx+56], eax
$LN132@CreateMiss:

; 2075 : 		}
; 2076 : 
; 2077 : 		if (elem->GetCommander())

  0025c	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  0025f	85 c0		 test	 eax, eax
  00261	74 0c		 je	 SHORT $LN142@CreateMiss

; 2078 : 		msn_elem->SetCommander(elem->GetCommander()->Name());

  00263	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  00266	50		 push	 eax
  00267	8d 4b 14	 lea	 ecx, DWORD PTR [ebx+20]
  0026a	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=
$LN142@CreateMiss:

; 2079 : 
; 2080 : 		msn_elem->SetCombatGroup(elem->GetCombatGroup());

  0026f	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  00275	89 83 c8 00 00
	00		 mov	 DWORD PTR [ebx+200], eax

; 2081 : 		msn_elem->SetCombatUnit(elem->GetCombatUnit());

  0027b	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  00281	89 83 cc 00 00
	00		 mov	 DWORD PTR [ebx+204], eax

; 2082 : 
; 2083 : 		Ship* ship = elem->GetShip(1);

  00287	b9 01 00 00 00	 mov	 ecx, 1
  0028c	8b c6		 mov	 eax, esi
  0028e	e8 00 00 00 00	 call	 ?GetShip@Element@@QAEPAVShip@@H@Z ; Element::GetShip
  00293	8b f8		 mov	 edi, eax

; 2084 : 		if (ship) {

  00295	85 ff		 test	 edi, edi
  00297	0f 84 50 01 00
	00		 je	 $LN27@CreateMiss

; 2085 : 			if (ship->GetRegion())

  0029d	8b 17		 mov	 edx, DWORD PTR [edi]
  0029f	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  002a5	8b cf		 mov	 ecx, edi
  002a7	ff d0		 call	 eax
  002a9	85 c0		 test	 eax, eax
  002ab	74 18		 je	 SHORT $LN156@CreateMiss

; 2086 : 			msn_elem->SetRegion(ship->GetRegion()->Name());

  002ad	8b 17		 mov	 edx, DWORD PTR [edi]
  002af	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  002b5	8b cf		 mov	 ecx, edi
  002b7	ff d0		 call	 eax
  002b9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  002bc	50		 push	 eax
  002bd	8d 4b 68	 lea	 ecx, DWORD PTR [ebx+104]
  002c0	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=
$LN156@CreateMiss:

; 2087 : 
; 2088 : 			msn_elem->SetLocation(ship->Location().OtherHand());

  002c5	f2 0f 10 47 48	 movsd	 xmm0, QWORD PTR [edi+72]
  002ca	f2 0f 10 4f 50	 movsd	 xmm1, QWORD PTR [edi+80]
  002cf	f2 0f 10 57 58	 movsd	 xmm2, QWORD PTR [edi+88]
  002d4	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  002dc	8d 44 24 34	 lea	 eax, DWORD PTR $T374574[esp+164]
  002e0	8b d3		 mov	 edx, ebx
  002e2	f2 0f 11 44 24
	34		 movsd	 QWORD PTR $T374574[esp+164], xmm0
  002e8	f2 0f 11 54 24
	3c		 movsd	 QWORD PTR $T374574[esp+172], xmm2
  002ee	f2 0f 11 4c 24
	44		 movsd	 QWORD PTR $T374574[esp+180], xmm1
  002f4	e8 00 00 00 00	 call	 ?SetLocation@MissionElement@@QAEXABUPoint@@@Z ; MissionElement::SetLocation

; 2089 : 			msn_elem->SetDesign(ship->Design());

  002f9	8b 87 00 02 00
	00		 mov	 eax, DWORD PTR [edi+512]
  002ff	89 43 30	 mov	 DWORD PTR [ebx+48], eax

; 2090 : 
; 2091 : 			msn_elem->SetPlayer(elem->Player());

  00302	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00305	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 2092 : 			msn_elem->SetCommandAI(elem->GetCommandAILevel());

  00308	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0030b	89 43 60	 mov	 DWORD PTR [ebx+96], eax

; 2093 : 			msn_elem->SetHoldTime((int) elem->GetHoldTime());

  0030e	8b c6		 mov	 eax, esi
  00310	e8 00 00 00 00	 call	 ?GetHoldTime@Element@@QAENXZ ; Element::GetHoldTime
  00315	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00319	89 43 54	 mov	 DWORD PTR [ebx+84], eax

; 2094 : 			msn_elem->SetZoneLock(elem->GetZoneLock());

  0031c	8b c6		 mov	 eax, esi
  0031e	e8 00 00 00 00	 call	 ?GetZoneLock@Element@@QAE_NXZ ; Element::GetZoneLock
  00323	0f b6 c0	 movzx	 eax, al
  00326	89 43 58	 mov	 DWORD PTR [ebx+88], eax

; 2095 : 			msn_elem->SetHeading(ship->CompassHeading());

  00329	8b c7		 mov	 eax, edi
  0032b	e8 00 00 00 00	 call	 ?CompassHeading@Ship@@QBENXZ ; Ship::CompassHeading
  00330	f2 0f 11 83 c0
	00 00 00	 movsd	 QWORD PTR [ebx+192], xmm0

; 2096 : 
; 2097 : 			msn_elem->SetPlayable(elem->IsPlayable());

  00338	8a 86 a1 00 00
	00		 mov	 al, BYTE PTR [esi+161]
  0033e	88 43 65	 mov	 BYTE PTR [ebx+101], al

; 2098 : 			msn_elem->SetRogue(elem->IsRogue());

  00341	8a 86 a0 00 00
	00		 mov	 al, BYTE PTR [esi+160]
  00347	88 43 66	 mov	 BYTE PTR [ebx+102], al

; 2099 : 			msn_elem->SetIntelLevel(elem->IntelLevel());

  0034a	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0034d	89 43 4c	 mov	 DWORD PTR [ebx+76], eax

; 2100 : 
; 2101 : 			Text design_path = ship->Design()->path_name;

  00350	8b 87 00 02 00
	00		 mov	 eax, DWORD PTR [edi+512]
  00356	83 c0 40	 add	 eax, 64			; 00000040H
  00359	50		 push	 eax
  0035a	8d 4c 24 24	 lea	 ecx, DWORD PTR _design_path$120174[esp+168]
  0035e	e8 00 00 00 00	 call	 ??0Text@@QAE@PBD@Z	; Text::Text

; 2102 : 			design_path.setSensitive(false);

  00363	6a 00		 push	 0
  00365	8d 4c 24 24	 lea	 ecx, DWORD PTR _design_path$120174[esp+168]
  00369	c7 84 24 a4 00
	00 00 03 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+176], 3
  00374	e8 00 00 00 00	 call	 ?setSensitive@Text@@QAEX_N@Z ; Text::setSensitive

; 2103 : 
; 2104 : 			if (design_path.indexOf("/Mods/Ships") == 0) {

  00379	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PMIPMFJL@?1Mods?1Ships?$AA@
  0037e	8d 4c 24 24	 lea	 ecx, DWORD PTR _design_path$120174[esp+168]
  00382	e8 00 00 00 00	 call	 ?indexOf@Text@@QBEHPBD@Z ; Text::indexOf
  00387	85 c0		 test	 eax, eax
  00389	75 45		 jne	 SHORT $LN202@CreateMiss

; 2105 : 				design_path = design_path.substring(11, 1000);

  0038b	68 e8 03 00 00	 push	 1000			; 000003e8H
  00390	6a 0b		 push	 11			; 0000000bH
  00392	8d 4c 24 3c	 lea	 ecx, DWORD PTR $T374575[esp+172]
  00396	51		 push	 ecx
  00397	8d 4c 24 2c	 lea	 ecx, DWORD PTR _design_path$120174[esp+176]
  0039b	e8 00 00 00 00	 call	 ?substring@Text@@QAE?AV1@HH@Z ; Text::substring
  003a0	50		 push	 eax
  003a1	8d 4c 24 24	 lea	 ecx, DWORD PTR _design_path$120174[esp+168]
  003a5	c6 84 24 a4 00
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+176], 4
  003ad	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@ABV0@@Z ; Text::operator=
  003b2	8d 4c 24 34	 lea	 ecx, DWORD PTR $T374575[esp+164]
  003b6	c6 84 24 a0 00
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+172], 3
  003be	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text

; 2106 : 				msn_elem->SetPath(design_path);

  003c3	8b 54 24 20	 mov	 edx, DWORD PTR _design_path$120174[esp+164]
  003c7	52		 push	 edx
  003c8	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  003cb	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=
$LN202@CreateMiss:

; 2107 : 			}
; 2108 : 
; 2109 : 			msn_elem->SetRespawnCount(ship->RespawnCount());

  003d0	8b bf 98 04 00
	00		 mov	 edi, DWORD PTR [edi+1176]

; 2110 : 		}

  003d6	8d 4c 24 20	 lea	 ecx, DWORD PTR _design_path$120174[esp+164]
  003da	89 7b 50	 mov	 DWORD PTR [ebx+80], edi
  003dd	c7 84 24 a0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+172], -1
  003e8	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
$LN27@CreateMiss:

; 2111 : 
; 2112 : 		MissionLoad* loadout = new(__FILE__,__LINE__) MissionLoad;

  003ed	6a 4c		 push	 76			; 0000004cH
  003ef	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003f4	83 c4 04	 add	 esp, 4
  003f7	89 44 24 28	 mov	 DWORD PTR $T374577[esp+164], eax
  003fb	c7 84 24 a0 00
	00 00 05 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+172], 5
  00406	85 c0		 test	 eax, eax
  00408	74 0e		 je	 SHORT $LN42@CreateMiss
  0040a	6a 00		 push	 0
  0040c	6a ff		 push	 -1
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ??0MissionLoad@@QAE@HPBD@Z ; MissionLoad::MissionLoad
  00414	8b d0		 mov	 edx, eax
  00416	eb 02		 jmp	 SHORT $LN43@CreateMiss
$LN42@CreateMiss:
  00418	33 d2		 xor	 edx, edx
$LN43@CreateMiss:

; 2113 : 		CopyMemory(loadout->GetStations(), elem->Loadout(), 16 * sizeof(int));

  0041a	8b c2		 mov	 eax, edx
  0041c	c7 84 24 a0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+172], -1
  00427	81 c6 a4 00 00
	00		 add	 esi, 164		; 000000a4H
  0042d	e8 00 00 00 00	 call	 ?GetStations@MissionLoad@@QAEPAHXZ ; MissionLoad::GetStations
  00432	8b f8		 mov	 edi, eax
  00434	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00439	f3 a5		 rep movsd

; 2114 : 
; 2115 : 		msn_elem->Loadouts().append(loadout);

  0043b	8d 83 f4 00 00
	00		 lea	 eax, DWORD PTR [ebx+244]
  00441	8b fa		 mov	 edi, edx
  00443	e8 00 00 00 00	 call	 ?append@?$List@VMissionLoad@@@@QAEXPBVMissionLoad@@@Z ; List<MissionLoad>::append

; 2116 : 
; 2117 : 		int num_obj = elem->NumObjectives();

  00448	8b 44 24 18	 mov	 eax, DWORD PTR _elem$GSCopy$[esp+164]
  0044c	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]

; 2118 : 		for (int i = 0; i < num_obj; i++) {

  0044f	33 f6		 xor	 esi, esi
  00451	89 44 24 1c	 mov	 DWORD PTR _num_obj$120185[esp+164], eax
  00455	85 c0		 test	 eax, eax
  00457	7e 58		 jle	 SHORT $LN22@CreateMiss
$LN24@CreateMiss:

; 2119 : 			Instruction* o     = elem->GetObjective(i);

  00459	8b 4c 24 18	 mov	 ecx, DWORD PTR _elem$GSCopy$[esp+164]
  0045d	8b c6		 mov	 eax, esi
  0045f	e8 00 00 00 00	 call	 ?GetObjective@Element@@QAEPAVInstruction@@H@Z ; Element::GetObjective

; 2120 : 			Instruction* instr = 0;
; 2121 : 
; 2122 : 			instr = new(__FILE__,__LINE__) Instruction(*o);

  00464	68 b0 00 00 00	 push	 176			; 000000b0H
  00469	8b f8		 mov	 edi, eax
  0046b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00470	83 c4 04	 add	 esp, 4
  00473	89 44 24 28	 mov	 DWORD PTR $T374581[esp+164], eax
  00477	c7 84 24 a0 00
	00 00 06 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+172], 6
  00482	85 c0		 test	 eax, eax
  00484	74 0a		 je	 SHORT $LN44@CreateMiss
  00486	50		 push	 eax
  00487	8b cf		 mov	 ecx, edi
  00489	e8 00 00 00 00	 call	 ??0Instruction@@QAE@ABV0@@Z ; Instruction::Instruction
  0048e	eb 02		 jmp	 SHORT $LN45@CreateMiss
$LN44@CreateMiss:
  00490	33 c0		 xor	 eax, eax
$LN45@CreateMiss:

; 2123 : 
; 2124 : 			msn_elem->AddObjective(instr);

  00492	8b f8		 mov	 edi, eax
  00494	8d 83 d0 00 00
	00		 lea	 eax, DWORD PTR [ebx+208]
  0049a	c7 84 24 a0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+172], -1
  004a5	e8 00 00 00 00	 call	 ?append@?$List@VInstruction@@@@QAEXPBVInstruction@@@Z ; List<Instruction>::append
  004aa	46		 inc	 esi
  004ab	3b 74 24 1c	 cmp	 esi, DWORD PTR _num_obj$120185[esp+164]
  004af	7c a8		 jl	 SHORT $LN24@CreateMiss
$LN22@CreateMiss:

; 2125 : 		}
; 2126 : 
; 2127 : 		int num_inst = elem->NumInstructions();

  004b1	8b 4c 24 18	 mov	 ecx, DWORD PTR _elem$GSCopy$[esp+164]
  004b5	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]

; 2128 : 		for (int i = 0; i < num_inst; i++) {

  004b8	33 f6		 xor	 esi, esi
  004ba	89 44 24 1c	 mov	 DWORD PTR _num_inst$120198[esp+164], eax
  004be	85 c0		 test	 eax, eax
  004c0	7e 73		 jle	 SHORT $LN19@CreateMiss
$LL21@CreateMiss:

; 2129 : 			Text instr = elem->GetInstruction(i);

  004c2	8b 4c 24 18	 mov	 ecx, DWORD PTR _elem$GSCopy$[esp+164]
  004c6	8b c6		 mov	 eax, esi
  004c8	8d 7c 24 34	 lea	 edi, DWORD PTR _instr$120203[esp+164]
  004cc	e8 00 00 00 00	 call	 ?GetInstruction@Element@@QAE?AVText@@H@Z ; Element::GetInstruction
  004d1	c7 84 24 a0 00
	00 00 07 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+172], 7

; 2130 : 			msn_elem->AddInstruction(instr);

  004dc	8b 7c 24 34	 mov	 edi, DWORD PTR _instr$120203[esp+164]
  004e0	6a 08		 push	 8
  004e2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  004e7	83 c4 04	 add	 esp, 4
  004ea	89 44 24 28	 mov	 DWORD PTR $T374940[esp+164], eax
  004ee	c6 84 24 a0 00
	00 00 08	 mov	 BYTE PTR __$EHRec$[esp+172], 8
  004f6	85 c0		 test	 eax, eax
  004f8	74 0a		 je	 SHORT $LN230@CreateMiss
  004fa	57		 push	 edi
  004fb	8b c8		 mov	 ecx, eax
  004fd	e8 00 00 00 00	 call	 ??0Text@@QAE@PBD@Z	; Text::Text
  00502	eb 02		 jmp	 SHORT $LN231@CreateMiss
$LN230@CreateMiss:
  00504	33 c0		 xor	 eax, eax
$LN231@CreateMiss:
  00506	50		 push	 eax
  00507	8d 8b dc 00 00
	00		 lea	 ecx, DWORD PTR [ebx+220]
  0050d	c6 84 24 a4 00
	00 00 07	 mov	 BYTE PTR __$EHRec$[esp+176], 7
  00515	e8 00 00 00 00	 call	 ?append@?$List@VText@@@@QAEXPBVText@@@Z ; List<Text>::append

; 2131 : 		}

  0051a	8d 4c 24 34	 lea	 ecx, DWORD PTR _instr$120203[esp+164]
  0051e	c7 84 24 a0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+172], -1
  00529	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  0052e	46		 inc	 esi
  0052f	3b 74 24 1c	 cmp	 esi, DWORD PTR _num_inst$120198[esp+164]
  00533	7c 8d		 jl	 SHORT $LL21@CreateMiss
$LN19@CreateMiss:

; 2132 : 
; 2133 : 		ListIter<Instruction> nav_iter = elem->GetFlightPlan();

  00535	8b 44 24 18	 mov	 eax, DWORD PTR _elem$GSCopy$[esp+164]
  00539	e8 00 00 00 00	 call	 ?GetFlightPlan@Element@@QAEAAV?$List@VInstruction@@@@XZ ; Element::GetFlightPlan

; 2134 : 		while (++nav_iter) {

  0053e	8d 54 24 34	 lea	 edx, DWORD PTR _nav_iter$120206[esp+164]
  00542	89 44 24 34	 mov	 DWORD PTR _nav_iter$120206[esp+164], eax
  00546	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR _nav_iter$120206[esp+168], -1
  0054e	e8 00 00 00 00	 call	 ?next@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::next
  00553	85 c0		 test	 eax, eax
  00555	0f 84 d1 00 00
	00		 je	 $LN17@CreateMiss
$LN18@CreateMiss:

; 2135 : 			Instruction* nav = nav_iter.value();

  0055b	8d 44 24 34	 lea	 eax, DWORD PTR _nav_iter$120206[esp+164]
  0055f	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value
  00564	8b f8		 mov	 edi, eax

; 2136 : 			Instruction* npt = new(__FILE__,__LINE__)
; 2137 : 			Instruction(nav->RegionName(), nav->Location(), nav->Action());

  00566	68 b0 00 00 00	 push	 176			; 000000b0H
  0056b	89 7c 24 18	 mov	 DWORD PTR _nav$120210[esp+168], edi
  0056f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00574	83 c4 04	 add	 esp, 4
  00577	89 44 24 28	 mov	 DWORD PTR $T374585[esp+164], eax
  0057b	c7 84 24 a0 00
	00 00 09 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+172], 9
  00586	85 c0		 test	 eax, eax
  00588	74 36		 je	 SHORT $LN46@CreateMiss
  0058a	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  0058d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00590	83 ec 18	 sub	 esp, 24			; 00000018H
  00593	8b f4		 mov	 esi, esp
  00595	8b cf		 mov	 ecx, edi
  00597	89 54 24 34	 mov	 DWORD PTR $T374960[esp+188], edx
  0059b	89 44 24 44	 mov	 DWORD PTR $T374965[esp+188], eax
  0059f	89 64 24 38	 mov	 DWORD PTR $T374586[esp+188], esp
  005a3	e8 00 00 00 00	 call	 ?Location@Instruction@@QBE?AUPoint@@XZ ; Instruction::Location
  005a8	8b 4c 24 34	 mov	 ecx, DWORD PTR $T374960[esp+188]
  005ac	8b 54 24 44	 mov	 edx, DWORD PTR $T374965[esp+188]
  005b0	8b 44 24 40	 mov	 eax, DWORD PTR $T374585[esp+188]
  005b4	51		 push	 ecx
  005b5	52		 push	 edx
  005b6	50		 push	 eax
  005b7	e8 00 00 00 00	 call	 ??0Instruction@@QAE@PBDUPoint@@H@Z ; Instruction::Instruction
  005bc	8b f8		 mov	 edi, eax
  005be	eb 02		 jmp	 SHORT $LN47@CreateMiss
$LN46@CreateMiss:
  005c0	33 ff		 xor	 edi, edi
$LN47@CreateMiss:
  005c2	c7 84 24 a0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+172], -1

; 2138 : 
; 2139 : 			npt->SetFormation(nav->Formation());

  005cd	8b 44 24 14	 mov	 eax, DWORD PTR _nav$120210[esp+164]
  005d1	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  005d4	89 4f 74	 mov	 DWORD PTR [edi+116], ecx

; 2140 : 			npt->SetSpeed(nav->Speed());

  005d7	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  005da	89 4f 7c	 mov	 DWORD PTR [edi+124], ecx

; 2141 : 			npt->SetTarget(nav->TargetName());

  005dd	8b b0 80 00 00
	00		 mov	 esi, DWORD PTR [eax+128]
  005e3	e8 00 00 00 00	 call	 ?SetTarget@Instruction@@QAEXPBD@Z ; Instruction::SetTarget

; 2142 : 			npt->SetHoldTime(nav->HoldTime());

  005e8	8b 44 24 14	 mov	 eax, DWORD PTR _nav$120210[esp+164]
  005ec	f2 0f 10 80 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+168]
  005f4	f2 0f 11 87 a8
	00 00 00	 movsd	 QWORD PTR [edi+168], xmm0

; 2143 : 			npt->SetFarcast(nav->Farcast());

  005fc	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00602	89 8f a0 00 00
	00		 mov	 DWORD PTR [edi+160], ecx

; 2144 : 			npt->SetStatus(nav->Status());

  00608	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0060b	8b c7		 mov	 eax, edi
  0060d	e8 00 00 00 00	 call	 ?SetStatus@Instruction@@QAEXH@Z ; Instruction::SetStatus

; 2145 : 
; 2146 : 			msn_elem->AddNavPoint(npt);

  00612	57		 push	 edi
  00613	53		 push	 ebx
  00614	33 c0		 xor	 eax, eax
  00616	e8 00 00 00 00	 call	 ?AddNavPoint@MissionElement@@QAEXPAVInstruction@@0@Z ; MissionElement::AddNavPoint
  0061b	8d 54 24 34	 lea	 edx, DWORD PTR _nav_iter$120206[esp+164]
  0061f	e8 00 00 00 00	 call	 ?next@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::next
  00624	85 c0		 test	 eax, eax
  00626	0f 85 2f ff ff
	ff		 jne	 $LN18@CreateMiss
$LN17@CreateMiss:

; 2147 : 		}
; 2148 : 
; 2149 : 		for (int i = 0; i < elem->NumShips(); i++) {

  0062c	8b 4c 24 18	 mov	 ecx, DWORD PTR _elem$GSCopy$[esp+164]
  00630	33 c0		 xor	 eax, eax
  00632	39 41 38	 cmp	 DWORD PTR [ecx+56], eax
  00635	0f 8e 15 02 00
	00		 jle	 $LN14@CreateMiss
$LN16@CreateMiss:

; 2150 : 			ship = elem->GetShip(i+1);

  0063b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0063e	8b 44 24 18	 mov	 eax, DWORD PTR _elem$GSCopy$[esp+164]
  00642	8b cf		 mov	 ecx, edi
  00644	89 7c 24 2c	 mov	 DWORD PTR tv1143[esp+164], edi
  00648	e8 00 00 00 00	 call	 ?GetShip@Element@@QAEPAVShip@@H@Z ; Element::GetShip
  0064d	8b f0		 mov	 esi, eax

; 2151 : 
; 2152 : 			if (ship) {

  0064f	85 f6		 test	 esi, esi
  00651	0f 84 ea 01 00
	00		 je	 $LN15@CreateMiss

; 2153 : 				MissionShip* s = new(__FILE__,__LINE__) MissionShip;

  00657	68 c0 00 00 00	 push	 192			; 000000c0H
  0065c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00661	83 c4 04	 add	 esp, 4
  00664	89 44 24 20	 mov	 DWORD PTR $T374590[esp+164], eax
  00668	c7 84 24 a0 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+172], 10 ; 0000000aH
  00673	85 c0		 test	 eax, eax
  00675	74 0e		 je	 SHORT $LN48@CreateMiss
  00677	50		 push	 eax
  00678	e8 00 00 00 00	 call	 ??0MissionShip@@QAE@XZ	; MissionShip::MissionShip
  0067d	8b f8		 mov	 edi, eax
  0067f	89 7c 24 14	 mov	 DWORD PTR $T374589[esp+164], edi
  00683	eb 0c		 jmp	 SHORT $LN49@CreateMiss
$LN48@CreateMiss:
  00685	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR $T374589[esp+164], 0
  0068d	8b 7c 24 14	 mov	 edi, DWORD PTR $T374589[esp+164]
$LN49@CreateMiss:

; 2154 : 
; 2155 : 				s->SetName(ship->Name());

  00691	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  00694	52		 push	 edx
  00695	8b cf		 mov	 ecx, edi
  00697	c7 84 24 a4 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+176], -1
  006a2	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=

; 2156 : 				s->SetRegNum(ship->Registry());

  006a7	8d 86 f0 01 00
	00		 lea	 eax, DWORD PTR [esi+496]
  006ad	50		 push	 eax
  006ae	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  006b1	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=

; 2157 : 				s->SetRegion(ship->GetRegion()->Name());

  006b6	8b 16		 mov	 edx, DWORD PTR [esi]
  006b8	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  006be	8b ce		 mov	 ecx, esi
  006c0	ff d0		 call	 eax
  006c2	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  006c5	51		 push	 ecx
  006c6	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  006c9	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=

; 2158 : 				s->SetLocation(ship->Location().OtherHand());

  006ce	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __mask@@NegDouble@
  006d6	f2 0f 10 46 48	 movsd	 xmm0, QWORD PTR [esi+72]
  006db	f2 0f 10 4e 50	 movsd	 xmm1, QWORD PTR [esi+80]
  006e0	f2 0f 10 56 58	 movsd	 xmm2, QWORD PTR [esi+88]
  006e5	f2 0f 11 57 28	 movsd	 QWORD PTR [edi+40], xmm2
  006ea	f2 0f 11 4f 30	 movsd	 QWORD PTR [edi+48], xmm1
  006ef	66 0f 57 c3	 xorpd	 xmm0, xmm3
  006f3	f2 0f 11 47 20	 movsd	 QWORD PTR [edi+32], xmm0

; 2159 : 				s->SetVelocity(ship->Velocity().OtherHand());

  006f8	f2 0f 10 86 c0
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+192]
  00700	f2 0f 58 86 a8
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+168]
  00708	f2 0f 10 8e c8
	00 00 00	 movsd	 xmm1, QWORD PTR [esi+200]
  00710	f2 0f 10 96 d0
	00 00 00	 movsd	 xmm2, QWORD PTR [esi+208]
  00718	f2 0f 58 8e b0
	00 00 00	 addsd	 xmm1, QWORD PTR [esi+176]
  00720	f2 0f 58 96 b8
	00 00 00	 addsd	 xmm2, QWORD PTR [esi+184]
  00728	66 0f 57 c3	 xorpd	 xmm0, xmm3
  0072c	f2 0f 11 47 38	 movsd	 QWORD PTR [edi+56], xmm0
  00731	f2 0f 11 57 40	 movsd	 QWORD PTR [edi+64], xmm2
  00736	f2 0f 11 4f 48	 movsd	 QWORD PTR [edi+72], xmm1

; 2160 : 
; 2161 : 				s->SetRespawns(ship->RespawnCount());

  0073b	8b 96 98 04 00
	00		 mov	 edx, DWORD PTR [esi+1176]

; 2162 : 				s->SetHeading(ship->CompassHeading());

  00741	8b c6		 mov	 eax, esi
  00743	89 57 50	 mov	 DWORD PTR [edi+80], edx
  00746	e8 00 00 00 00	 call	 ?CompassHeading@Ship@@QBENXZ ; Ship::CompassHeading
  0074b	f2 0f 11 47 58	 movsd	 QWORD PTR [edi+88], xmm0

; 2163 : 				s->SetIntegrity(ship->Integrity());

  00750	f3 0f 10 86 b8
	01 00 00	 movss	 xmm0, DWORD PTR [esi+440]
  00758	0f 5a c0	 cvtps2pd xmm0, xmm0
  0075b	f2 0f 11 47 60	 movsd	 QWORD PTR [edi+96], xmm0

; 2164 : 
; 2165 : 				if (ship->GetDecoy())

  00760	8b 06		 mov	 eax, DWORD PTR [esi]
  00762	8b 90 24 01 00
	00		 mov	 edx, DWORD PTR [eax+292]
  00768	8b ce		 mov	 ecx, esi
  0076a	ff d2		 call	 edx
  0076c	85 c0		 test	 eax, eax
  0076e	74 15		 je	 SHORT $LN329@CreateMiss

; 2166 : 				s->SetDecoys(ship->GetDecoy()->Ammo());

  00770	8b 06		 mov	 eax, DWORD PTR [esi]
  00772	8b 90 24 01 00
	00		 mov	 edx, DWORD PTR [eax+292]
  00778	8b ce		 mov	 ecx, esi
  0077a	ff d2		 call	 edx
  0077c	8b 80 8c 02 00
	00		 mov	 eax, DWORD PTR [eax+652]
  00782	89 47 68	 mov	 DWORD PTR [edi+104], eax
$LN329@CreateMiss:

; 2167 : 
; 2168 : 				if (ship->GetProbeLauncher())

  00785	8b 16		 mov	 edx, DWORD PTR [esi]
  00787	8b 82 bc 01 00
	00		 mov	 eax, DWORD PTR [edx+444]
  0078d	8b ce		 mov	 ecx, esi
  0078f	ff d0		 call	 eax
  00791	85 c0		 test	 eax, eax
  00793	74 15		 je	 SHORT $LN333@CreateMiss

; 2169 : 				s->SetProbes(ship->GetProbeLauncher()->Ammo());

  00795	8b 16		 mov	 edx, DWORD PTR [esi]
  00797	8b 82 bc 01 00
	00		 mov	 eax, DWORD PTR [edx+444]
  0079d	8b ce		 mov	 ecx, esi
  0079f	ff d0		 call	 eax
  007a1	8b 88 8c 02 00
	00		 mov	 ecx, DWORD PTR [eax+652]
  007a7	89 4f 6c	 mov	 DWORD PTR [edi+108], ecx
$LN333@CreateMiss:

; 2170 : 
; 2171 : 				int n;
; 2172 : 				int ammo[16];
; 2173 : 				int fuel[4];
; 2174 : 
; 2175 : 				for (n = 0; n < 16; n++) {

  007aa	33 ff		 xor	 edi, edi
  007ac	8d 64 24 00	 npad	 4
$LL10@CreateMiss:

; 2176 : 					Weapon* w = ship->GetWeaponByIndex(n+1);

  007b0	8b 16		 mov	 edx, DWORD PTR [esi]
  007b2	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  007b5	89 44 24 28	 mov	 DWORD PTR tv1225[esp+164], eax
  007b9	50		 push	 eax
  007ba	8b 82 18 01 00
	00		 mov	 eax, DWORD PTR [edx+280]
  007c0	8b ce		 mov	 ecx, esi
  007c2	ff d0		 call	 eax

; 2177 : 
; 2178 : 					if (w)

  007c4	85 c0		 test	 eax, eax
  007c6	74 0c		 je	 SHORT $LN7@CreateMiss

; 2179 : 					ammo[n] = w->Ammo();

  007c8	8b 88 8c 02 00
	00		 mov	 ecx, DWORD PTR [eax+652]
  007ce	89 4c bc 4c	 mov	 DWORD PTR _ammo$120239[esp+edi*4+164], ecx

; 2180 : 					else

  007d2	eb 08		 jmp	 SHORT $LN9@CreateMiss
$LN7@CreateMiss:

; 2181 : 					ammo[n] = -10;

  007d4	c7 44 bc 4c f6
	ff ff ff	 mov	 DWORD PTR _ammo$120239[esp+edi*4+164], -10 ; fffffff6H
$LN9@CreateMiss:

; 2170 : 
; 2171 : 				int n;
; 2172 : 				int ammo[16];
; 2173 : 				int fuel[4];
; 2174 : 
; 2175 : 				for (n = 0; n < 16; n++) {

  007dc	8b 7c 24 28	 mov	 edi, DWORD PTR tv1225[esp+164]
  007e0	83 ff 10	 cmp	 edi, 16			; 00000010H
  007e3	7c cb		 jl	 SHORT $LL10@CreateMiss

; 2182 : 				}
; 2183 : 
; 2184 : 				for (n = 0; n < 4; n++) {

  007e5	33 ff		 xor	 edi, edi
$LL5@CreateMiss:

; 2185 : 					if (ship->Reactors().size() > n)

  007e7	39 be 90 03 00
	00		 cmp	 DWORD PTR [esi+912], edi
  007ed	7e 1b		 jle	 SHORT $LN2@CreateMiss

; 2186 : 					fuel[n] = ship->Reactors()[n]->Charge();

  007ef	57		 push	 edi
  007f0	8d 86 90 03 00
	00		 lea	 eax, DWORD PTR [esi+912]
  007f6	e8 00 00 00 00	 call	 ??A?$List@VPowerSource@@@@QAEAAPAVPowerSource@@H@Z ; List<PowerSource>::operator[]
  007fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  007fd	8b 11		 mov	 edx, DWORD PTR [ecx]
  007ff	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00802	ff d0		 call	 eax
  00804	89 44 bc 34	 mov	 DWORD PTR _fuel$120240[esp+edi*4+164], eax

; 2187 : 					else

  00808	eb 08		 jmp	 SHORT $LN4@CreateMiss
$LN2@CreateMiss:

; 2188 : 					fuel[n] = -10;

  0080a	c7 44 bc 34 f6
	ff ff ff	 mov	 DWORD PTR _fuel$120240[esp+edi*4+164], -10 ; fffffff6H
$LN4@CreateMiss:

; 2182 : 				}
; 2183 : 
; 2184 : 				for (n = 0; n < 4; n++) {

  00812	47		 inc	 edi
  00813	83 ff 04	 cmp	 edi, 4
  00816	7c cf		 jl	 SHORT $LL5@CreateMiss

; 2189 : 				}
; 2190 : 
; 2191 : 				s->SetAmmo(ammo);

  00818	8b 7c 24 14	 mov	 edi, DWORD PTR $T374589[esp+164]
  0081c	8d 54 24 4c	 lea	 edx, DWORD PTR _ammo$120239[esp+164]
  00820	8b cf		 mov	 ecx, edi
  00822	e8 00 00 00 00	 call	 ?SetAmmo@MissionShip@@QAEXPBH@Z ; MissionShip::SetAmmo

; 2192 : 				s->SetFuel(fuel);

  00827	8d 44 24 34	 lea	 eax, DWORD PTR _fuel$120240[esp+164]
  0082b	8b cf		 mov	 ecx, edi
  0082d	e8 00 00 00 00	 call	 ?SetFuel@MissionShip@@QAEXPBH@Z ; MissionShip::SetFuel

; 2193 : 
; 2194 : 				msn_elem->Ships().append(s);

  00832	8d 83 00 01 00
	00		 lea	 eax, DWORD PTR [ebx+256]
  00838	e8 00 00 00 00	 call	 ?append@?$List@VMissionShip@@@@QAEXPBVMissionShip@@@Z ; List<MissionShip>::append
  0083d	8b 7c 24 2c	 mov	 edi, DWORD PTR tv1143[esp+164]
$LN15@CreateMiss:

; 2147 : 		}
; 2148 : 
; 2149 : 		for (int i = 0; i < elem->NumShips(); i++) {

  00841	8b 4c 24 18	 mov	 ecx, DWORD PTR _elem$GSCopy$[esp+164]
  00845	8b c7		 mov	 eax, edi
  00847	3b 41 38	 cmp	 eax, DWORD PTR [ecx+56]
  0084a	0f 8c eb fd ff
	ff		 jl	 $LN16@CreateMiss
$LN14@CreateMiss:

; 2195 : 			}
; 2196 : 		}
; 2197 : 	}
; 2198 : 
; 2199 : 	return msn_elem;

  00850	8b 44 24 30	 mov	 eax, DWORD PTR _msn_elem$[esp+164]
$LN38@CreateMiss:

; 2200 : }

  00854	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+164]
  0085b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00862	59		 pop	 ecx
  00863	5f		 pop	 edi
  00864	5e		 pop	 esi
  00865	5b		 pop	 ebx
  00866	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+148]
  0086d	33 cc		 xor	 ecx, esp
  0086f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00874	8b e5		 mov	 esp, ebp
  00876	5d		 pop	 ebp
  00877	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$0:
  00000	68 f4 07 00 00	 push	 2036			; 000007f4H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 84	 mov	 eax, DWORD PTR $T374567[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$1:
  00017	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _design_path$120162[ebp]
  0001d	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$2:
  00022	8d 4d 90	 lea	 ecx, DWORD PTR $T374572[ebp]
  00025	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$3:
  0002a	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _design_path$120174[ebp]
  00030	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$4:
  00035	8d 4d 90	 lea	 ecx, DWORD PTR $T374575[ebp]
  00038	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$5:
  0003d	68 40 08 00 00	 push	 2112			; 00000840H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  00047	8b 45 84	 mov	 eax, DWORD PTR $T374577[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	c3		 ret	 0
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$6:
  00054	68 4a 08 00 00	 push	 2122			; 0000084aH
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0005e	8b 45 84	 mov	 eax, DWORD PTR $T374581[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	c3		 ret	 0
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$7:
  0006b	8d 4d 90	 lea	 ecx, DWORD PTR _instr$120203[ebp]
  0006e	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$10:
  00073	68 26 01 00 00	 push	 294			; 00000126H
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@DCHCODGP@c?3?2matrix?5games?2dev?2stars45?2Miss@
  0007d	8b 45 84	 mov	 eax, DWORD PTR $T374940[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	c3		 ret	 0
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$8:
  0008a	68 58 08 00 00	 push	 2136			; 00000858H
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  00094	8b 45 84	 mov	 eax, DWORD PTR $T374585[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	c3		 ret	 0
__unwindfunclet$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z$9:
  000a1	68 69 08 00 00	 push	 2153			; 00000869H
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  000ab	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T374590[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ba	c3		 ret	 0
__ehhandler$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z:
  000bb	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000bf	8d 82 6c ff ff
	ff		 lea	 eax, DWORD PTR [edx-148]
  000c5	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  000cb	33 c8		 xor	 ecx, eax
  000cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d2	83 c0 0c	 add	 eax, 12			; 0000000cH
  000d5	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  000d8	33 c8		 xor	 ecx, eax
  000da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000df	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z
  000e4	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z ENDP ; Sim::CreateMissionElement
PUBLIC	?GetMissionElements@Sim@@QAE?AV?$ListIter@VMissionElement@@@@XZ ; Sim::GetMissionElements
; Function compile flags: /Ogtp
;	COMDAT ?GetMissionElements@Sim@@QAE?AV?$ListIter@VMissionElement@@@@XZ
_TEXT	SEGMENT
tv192 = -12						; size = 4
_iter$ = -8						; size = 8
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
?GetMissionElements@Sim@@QAE?AV?$ListIter@VMissionElement@@@@XZ PROC ; Sim::GetMissionElements, COMDAT

; 1998 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1999 : 	mission_elements.destroy();

  0000c	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  0000f	8d b7 ac 00 00
	00		 lea	 esi, DWORD PTR [edi+172]
  00015	89 74 24 0c	 mov	 DWORD PTR tv192[esp+24], esi
  00019	e8 00 00 00 00	 call	 ?destroy@?$List@VMissionElement@@@@QAEXXZ ; List<MissionElement>::destroy

; 2000 : 
; 2001 : 	ListIter<Element> iter = elements;

  0001e	81 c7 88 00 00
	00		 add	 edi, 136		; 00000088H

; 2002 : 	while (++iter) {

  00024	8d 54 24 10	 lea	 edx, DWORD PTR _iter$[esp+24]
  00028	89 7c 24 10	 mov	 DWORD PTR _iter$[esp+24], edi
  0002c	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _iter$[esp+28], -1
  00034	e8 00 00 00 00	 call	 ?next@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::next
  00039	85 c0		 test	 eax, eax
  0003b	74 79		 je	 SHORT $LN8@GetMission
  0003d	8d 49 00	 npad	 3
$LL9@GetMission:

; 2003 : 		Element* elem = iter.value();

  00040	8d 44 24 10	 lea	 eax, DWORD PTR _iter$[esp+24]
  00044	e8 00 00 00 00	 call	 ?value@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::value
  00049	8b f8		 mov	 edi, eax

; 2004 : 
; 2005 : 		int num_live_ships = 0;
; 2006 : 
; 2007 : 		for (int i = 0; i < elem->NumShips(); i++) {

  0004b	33 c0		 xor	 eax, eax
  0004d	33 db		 xor	 ebx, ebx
  0004f	39 47 38	 cmp	 DWORD PTR [edi+56], eax
  00052	7e 28		 jle	 SHORT $LN5@GetMission
$LL7@GetMission:

; 2008 : 			Ship* s = elem->GetShip(i+1);

  00054	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00057	8b ce		 mov	 ecx, esi
  00059	8b c7		 mov	 eax, edi
  0005b	e8 00 00 00 00	 call	 ?GetShip@Element@@QAEPAVShip@@H@Z ; Element::GetShip

; 2009 : 
; 2010 : 			if (s && !s->IsDying() && !s->IsDead())

  00060	85 c0		 test	 eax, eax
  00062	74 11		 je	 SHORT $LN6@GetMission
  00064	8b 80 60 04 00
	00		 mov	 eax, DWORD PTR [eax+1120]
  0006a	83 f8 05	 cmp	 eax, 5
  0006d	74 06		 je	 SHORT $LN6@GetMission
  0006f	83 f8 06	 cmp	 eax, 6
  00072	74 01		 je	 SHORT $LN6@GetMission

; 2011 : 			num_live_ships++;

  00074	43		 inc	 ebx
$LN6@GetMission:

; 2004 : 
; 2005 : 		int num_live_ships = 0;
; 2006 : 
; 2007 : 		for (int i = 0; i < elem->NumShips(); i++) {

  00075	8b c6		 mov	 eax, esi
  00077	3b 47 38	 cmp	 eax, DWORD PTR [edi+56]
  0007a	7c d8		 jl	 SHORT $LL7@GetMission
$LN5@GetMission:

; 2012 : 		}
; 2013 : 
; 2014 : 		if (elem->IsSquadron() || num_live_ships > 0) {

  0007c	8b cf		 mov	 ecx, edi
  0007e	e8 00 00 00 00	 call	 ?IsSquadron@Element@@QBE_NXZ ; Element::IsSquadron
  00083	84 c0		 test	 al, al
  00085	75 04		 jne	 SHORT $LN2@GetMission
  00087	85 db		 test	 ebx, ebx
  00089	7e 1a		 jle	 SHORT $LN1@GetMission
$LN2@GetMission:

; 2015 : 			MissionElement* msn_elem = CreateMissionElement(elem);

  0008b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	50		 push	 eax
  0008f	8b cf		 mov	 ecx, edi
  00091	e8 00 00 00 00	 call	 ?CreateMissionElement@Sim@@IAEPAVMissionElement@@PAVElement@@@Z ; Sim::CreateMissionElement

; 2016 : 
; 2017 : 			if (msn_elem)

  00096	85 c0		 test	 eax, eax
  00098	74 0b		 je	 SHORT $LN1@GetMission

; 2018 : 			mission_elements.append(msn_elem);

  0009a	8b f8		 mov	 edi, eax
  0009c	8b 44 24 0c	 mov	 eax, DWORD PTR tv192[esp+24]
  000a0	e8 00 00 00 00	 call	 ?append@?$List@VMissionElement@@@@QAEXPBVMissionElement@@@Z ; List<MissionElement>::append
$LN1@GetMission:

; 2002 : 	while (++iter) {

  000a5	8d 54 24 10	 lea	 edx, DWORD PTR _iter$[esp+24]
  000a9	e8 00 00 00 00	 call	 ?next@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::next
  000ae	85 c0		 test	 eax, eax
  000b0	75 8e		 jne	 SHORT $LL9@GetMission
  000b2	8b 74 24 0c	 mov	 esi, DWORD PTR tv192[esp+24]
$LN8@GetMission:

; 2019 : 		}
; 2020 : 	}
; 2021 : 
; 2022 : 	return mission_elements;

  000b6	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2023 : }

  000b9	5f		 pop	 edi
  000ba	89 30		 mov	 DWORD PTR [eax], esi
  000bc	5e		 pop	 esi
  000bd	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  000c4	5b		 pop	 ebx
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 08 00	 ret	 8
?GetMissionElements@Sim@@QAE?AV?$ListIter@VMissionElement@@@@XZ ENDP ; Sim::GetMissionElements
_TEXT	ENDS
PUBLIC	?ActivateRegion@Sim@@QAE_NPAVSimRegion@@@Z	; Sim::ActivateRegion
; Function compile flags: /Ogtp
;	COMDAT ?ActivateRegion@Sim@@QAE_NPAVSimRegion@@@Z
_TEXT	SEGMENT
_rgn$ = 8						; size = 4
?ActivateRegion@Sim@@QAE_NPAVSimRegion@@@Z PROC		; Sim::ActivateRegion, COMDAT
; _this$ = esi

; 1446 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _rgn$[ebp]
  00007	57		 push	 edi

; 1447 : 	if (rgn && active_region != rgn && regions.contains(rgn)) {

  00008	85 db		 test	 ebx, ebx
  0000a	0f 84 9d 00 00
	00		 je	 $LN7@ActivateRe
  00010	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  00013	0f 84 94 00 00
	00		 je	 $LN7@ActivateRe
  00019	8d 7e 58	 lea	 edi, DWORD PTR [esi+88]
  0001c	8b c3		 mov	 eax, ebx
  0001e	e8 00 00 00 00	 call	 ?contains@?$List@VSimRegion@@@@QBE_NPBVSimRegion@@@Z ; List<SimRegion>::contains
  00023	84 c0		 test	 al, al
  00025	0f 84 82 00 00
	00		 je	 $LN7@ActivateRe

; 1448 : 		if (active_region)

  0002b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002e	85 c9		 test	 ecx, ecx
  00030	74 07		 je	 SHORT $LN6@ActivateRe

; 1449 : 		active_region->Deactivate();

  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00037	ff d2		 call	 edx
$LN6@ActivateRe:

; 1450 : 
; 1451 : 		if (!active_region || active_region->System() != rgn->System()) {

  00039	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003c	85 c0		 test	 eax, eax
  0003e	74 15		 je	 SHORT $LN3@ActivateRe
  00040	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00043	3b 4b 18	 cmp	 ecx, DWORD PTR [ebx+24]
  00046	74 1b		 je	 SHORT $LN5@ActivateRe

; 1452 : 			if (active_region)

  00048	85 c0		 test	 eax, eax
  0004a	74 09		 je	 SHORT $LN3@ActivateRe

; 1453 : 			active_region->System()->Deactivate();

  0004c	8b c1		 mov	 eax, ecx
  0004e	8b 10		 mov	 edx, DWORD PTR [eax]
  00050	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00053	ff d0		 call	 eax
$LN3@ActivateRe:

; 1454 : 			rgn->System()->Activate(scene);

  00055	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  00058	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005a	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  0005d	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00060	50		 push	 eax
  00061	ff d2		 call	 edx
$LN5@ActivateRe:

; 1455 : 		}
; 1456 : 
; 1457 : 		active_region = rgn;

  00063	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 1458 : 		star_system   = active_region->System();

  00066	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  00069	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 1459 : 
; 1460 : 		if (star_system) {

  0006c	85 c9		 test	 ecx, ecx
  0006e	74 1a		 je	 SHORT $LN2@ActivateRe

; 1461 : 			star_system->SetActiveRegion(active_region->orbital_region);

  00070	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00073	e8 00 00 00 00	 call	 ?SetActiveRegion@StarSystem@@QAEXPAVOrbitalRegion@@@Z ; StarSystem::SetActiveRegion

; 1465 : 		}
; 1466 : 
; 1467 : 		active_region->Activate();

  00078	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0007b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00080	ff d0		 call	 eax

; 1468 : 		return true;

  00082	b0 01		 mov	 al, 1

; 1469 : 	}
; 1470 : 
; 1471 : 	return false;
; 1472 : }

  00084	5f		 pop	 edi
  00085	5b		 pop	 ebx
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
$LN2@ActivateRe:

; 1462 : 		}
; 1463 : 		else {
; 1464 : 			::Print("WARNING: Sim::ActivateRegion() No star system found for rgn '%s'", rgn->Name());

  0008a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@OCIFAMJD@WARNING?3?5Sim?3?3ActivateRegion?$CI?$CJ?5N@
  00093	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 1465 : 		}
; 1466 : 
; 1467 : 		active_region->Activate();

  00098	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0009b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a0	83 c4 08	 add	 esp, 8
  000a3	ff d0		 call	 eax

; 1468 : 		return true;

  000a5	b0 01		 mov	 al, 1

; 1469 : 	}
; 1470 : 
; 1471 : 	return false;
; 1472 : }

  000a7	5f		 pop	 edi
  000a8	5b		 pop	 ebx
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
$LN7@ActivateRe:
  000ad	5f		 pop	 edi
  000ae	32 c0		 xor	 al, al
  000b0	5b		 pop	 ebx
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
?ActivateRegion@Sim@@QAE_NPAVSimRegion@@@Z ENDP		; Sim::ActivateRegion
_TEXT	ENDS
PUBLIC	?NextView@Sim@@QAEXXZ				; Sim::NextView
; Function compile flags: /Ogtp
;	COMDAT ?NextView@Sim@@QAEXXZ
_TEXT	SEGMENT
?NextView@Sim@@QAEXXZ PROC				; Sim::NextView, COMDAT
; _this$ = eax

; 1253 : 	if (active_region)

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	85 c0		 test	 eax, eax
  00005	74 05		 je	 SHORT $LN1@NextView@2

; 1254 : 	active_region->NextView();

  00007	e9 00 00 00 00	 jmp	 ?NextView@SimRegion@@QAEXXZ ; SimRegion::NextView
$LN1@NextView@2:

; 1255 : }

  0000c	c3		 ret	 0
?NextView@Sim@@QAEXXZ ENDP				; Sim::NextView
_TEXT	ENDS
PUBLIC	?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z ; Sim::CreateExplosion
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\geometry.h
xdata$x	SEGMENT
__unwindtable$?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z$0
__ehfuncinfo$?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z
_TEXT	SEGMENT
$T375274 = -36						; size = 12
$T375273 = -24						; size = 12
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_type$ = 12						; size = 4
_exp_scale$ = 16					; size = 4
_part_scale$ = 20					; size = 4
$T375272 = 24						; size = 4
_rgn$ = 24						; size = 4
_source$ = 28						; size = 4
?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z PROC ; Sim::CreateExplosion, COMDAT
; _pos$ = ecx
; _vel$ = edi

; 1119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b 5d 18	 mov	 ebx, DWORD PTR _rgn$[ebp]
  0002a	8b f1		 mov	 esi, ecx

; 1120 : 	// don't bother creating explosions that can't be seen:
; 1121 : 	if (!rgn || !active_region || rgn != active_region)

  0002c	85 db		 test	 ebx, ebx
  0002e	0f 84 e1 00 00
	00		 je	 $LN4@CreateExpl
  00034	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003a	85 c0		 test	 eax, eax
  0003c	0f 84 d3 00 00
	00		 je	 $LN4@CreateExpl
  00042	3b d8		 cmp	 ebx, eax
  00044	0f 85 cb 00 00
	00		 jne	 $LN4@CreateExpl

; 1123 : 
; 1124 : 	Explosion* exp = new(__FILE__,__LINE__) Explosion(type, pos, vel, exp_scale, part_scale, rgn, source);

  0004a	68 20 02 00 00	 push	 544			; 00000220H
  0004f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00054	83 c4 04	 add	 esp, 4
  00057	89 45 18	 mov	 DWORD PTR $T375272[ebp], eax
  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00061	85 c0		 test	 eax, eax
  00063	0f 84 84 00 00
	00		 je	 $LN8@CreateExpl
  00069	f2 0f 10 07	 movsd	 xmm0, QWORD PTR [edi]
  0006d	8b 4d 1c	 mov	 ecx, DWORD PTR _source$[ebp]
  00070	f2 0f 10 4f 08	 movsd	 xmm1, QWORD PTR [edi+8]
  00075	f2 0f 10 57 10	 movsd	 xmm2, QWORD PTR [edi+16]
  0007a	8b 55 0c	 mov	 edx, DWORD PTR _type$[ebp]
  0007d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00081	51		 push	 ecx
  00082	f3 0f 11 45 e8	 movss	 DWORD PTR $T375273[ebp], xmm0
  00087	f2 0f 10 06	 movsd	 xmm0, QWORD PTR [esi]
  0008b	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0008f	53		 push	 ebx
  00090	83 ec 08	 sub	 esp, 8
  00093	f3 0f 11 45 dc	 movss	 DWORD PTR $T375274[ebp], xmm0
  00098	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _part_scale$[ebp]
  0009d	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000a3	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _exp_scale$[ebp]
  000a8	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  000ac	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  000b0	f3 0f 11 4d ec	 movss	 DWORD PTR $T375273[ebp+4], xmm1
  000b5	f2 0f 10 4e 08	 movsd	 xmm1, QWORD PTR [esi+8]
  000ba	f3 0f 11 55 f0	 movss	 DWORD PTR $T375273[ebp+8], xmm2
  000bf	f2 0f 10 56 10	 movsd	 xmm2, QWORD PTR [esi+16]
  000c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c9	52		 push	 edx
  000ca	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  000ce	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  000d2	8d 55 e8	 lea	 edx, DWORD PTR $T375273[ebp]
  000d5	8d 4d dc	 lea	 ecx, DWORD PTR $T375274[ebp]
  000d8	8b f0		 mov	 esi, eax
  000da	f3 0f 11 4d e0	 movss	 DWORD PTR $T375274[ebp+4], xmm1
  000df	f3 0f 11 55 e4	 movss	 DWORD PTR $T375274[ebp+8], xmm2
  000e4	e8 00 00 00 00	 call	 ??0Explosion@@QAE@HABUVec3@@0MMPAVSimRegion@@PAVSimObject@@@Z ; Explosion::Explosion
  000e9	8b f0		 mov	 esi, eax
  000eb	eb 02		 jmp	 SHORT $LN9@CreateExpl
$LN8@CreateExpl:
  000ed	33 f6		 xor	 esi, esi
$LN9@CreateExpl:
  000ef	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 1125 : 
; 1126 : 	if (rgn)
; 1127 : 	rgn->InsertObject(exp);

  000f6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000f8	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  000fb	56		 push	 esi
  000fc	8b cb		 mov	 ecx, ebx
  000fe	ff d2		 call	 edx

; 1128 : 
; 1129 : 	else if (active_region)
; 1130 : 	active_region->InsertObject(exp);
; 1131 : 
; 1132 : 	return exp;

  00100	8b c6		 mov	 eax, esi

; 1133 : }

  00102	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00105	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010c	59		 pop	 ecx
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 18 00	 ret	 24			; 00000018H
$LN4@CreateExpl:

; 1122 : 	return 0;

  00115	33 c0		 xor	 eax, eax

; 1133 : }

  00117	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00121	59		 pop	 ecx
  00122	5e		 pop	 esi
  00123	5b		 pop	 ebx
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z$0:
  00000	68 64 04 00 00	 push	 1124			; 00000464H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 18	 mov	 eax, DWORD PTR $T375272[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__ehhandler$?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z ENDP ; Sim::CreateExplosion
PUBLIC	?BuildLinks@Sim@@IAEXXZ				; Sim::BuildLinks
; Function compile flags: /Ogtp
;	COMDAT ?BuildLinks@Sim@@IAEXXZ
_TEXT	SEGMENT
_iter$ = -24						; size = 8
_lnk_iter$118696 = -16					; size = 8
_rgn$118660 = -8					; size = 4
_this$ = 8						; size = 4
?BuildLinks@Sim@@IAEXXZ PROC				; Sim::BuildLinks, COMDAT

; 461  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 462  : 	ListIter<SimRegion> iter = regions;

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	83 c0 58	 add	 eax, 88			; 00000058H
  0000e	57		 push	 edi

; 463  : 	while (++iter) {

  0000f	8d 55 e8	 lea	 edx, DWORD PTR _iter$[ebp]
  00012	89 45 e8	 mov	 DWORD PTR _iter$[ebp], eax
  00015	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _iter$[ebp+4], -1
  0001c	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  00021	85 c0		 test	 eax, eax
  00023	0f 84 8a 00 00
	00		 je	 $LN5@BuildLinks
$LN6@BuildLinks:

; 464  : 		SimRegion*     rgn = iter.value();

  00029	8d 45 e8	 lea	 eax, DWORD PTR _iter$[ebp]
  0002c	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  00031	8b d8		 mov	 ebx, eax

; 465  : 		OrbitalRegion* orb = rgn->GetOrbitalRegion();

  00033	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00036	89 5d f8	 mov	 DWORD PTR _rgn$118660[ebp], ebx

; 466  : 
; 467  : 		if (orb) {

  00039	85 c0		 test	 eax, eax
  0003b	74 66		 je	 SHORT $LN2@BuildLinks

; 468  : 			ListIter<Text> lnk_iter = orb->Links();

  0003d	05 14 01 00 00	 add	 eax, 276		; 00000114H

; 469  : 			while (++lnk_iter) {

  00042	8d 4d f0	 lea	 ecx, DWORD PTR _lnk_iter$118696[ebp]
  00045	89 45 f0	 mov	 DWORD PTR _lnk_iter$118696[ebp], eax
  00048	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _lnk_iter$118696[ebp+4], -1
  0004f	e8 00 00 00 00	 call	 ?next@?$ListIter@VText@@@@QAEPAVText@@XZ ; ListIter<Text>::next
  00054	85 c0		 test	 eax, eax
  00056	74 4b		 je	 SHORT $LN2@BuildLinks
  00058	eb 09		 jmp	 SHORT $LN3@BuildLinks
  0005a	8d 9b 00 00 00
	00		 npad	 6
$LL30@BuildLinks:
  00060	8b 5d f8	 mov	 ebx, DWORD PTR _rgn$118660[ebp]
$LN3@BuildLinks:

; 470  : 				Text* t = lnk_iter.value();

  00063	8d 4d f0	 lea	 ecx, DWORD PTR _lnk_iter$118696[ebp]
  00066	e8 00 00 00 00	 call	 ?value@?$ListIter@VText@@@@QAEPAVText@@XZ ; ListIter<Text>::value

; 471  : 
; 472  : 				SimRegion* tgt = FindRegion(*t);

  0006b	8b 30		 mov	 esi, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?FindRegion@Sim@@QAEPAVSimRegion@@PBD@Z ; Sim::FindRegion
  00075	8b f0		 mov	 esi, eax

; 473  : 
; 474  : 				if (tgt && !rgn->Links().contains(tgt))

  00077	85 f6		 test	 esi, esi
  00079	74 1c		 je	 SHORT $LN1@BuildLinks
  0007b	8d bb f4 00 00
	00		 lea	 edi, DWORD PTR [ebx+244]
  00081	e8 00 00 00 00	 call	 ?contains@?$List@VSimRegion@@@@QBE_NPBVSimRegion@@@Z ; List<SimRegion>::contains
  00086	84 c0		 test	 al, al
  00088	75 0d		 jne	 SHORT $LN1@BuildLinks

; 475  : 				rgn->Links().append(tgt);

  0008a	8b fe		 mov	 edi, esi
  0008c	8d 83 f4 00 00
	00		 lea	 eax, DWORD PTR [ebx+244]
  00092	e8 00 00 00 00	 call	 ?append@?$List@VSimRegion@@@@QAEXPBVSimRegion@@@Z ; List<SimRegion>::append
$LN1@BuildLinks:

; 469  : 			while (++lnk_iter) {

  00097	8d 4d f0	 lea	 ecx, DWORD PTR _lnk_iter$118696[ebp]
  0009a	e8 00 00 00 00	 call	 ?next@?$ListIter@VText@@@@QAEPAVText@@XZ ; ListIter<Text>::next
  0009f	85 c0		 test	 eax, eax
  000a1	75 bd		 jne	 SHORT $LL30@BuildLinks
$LN2@BuildLinks:

; 463  : 	while (++iter) {

  000a3	8d 55 e8	 lea	 edx, DWORD PTR _iter$[ebp]
  000a6	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  000ab	85 c0		 test	 eax, eax
  000ad	0f 85 76 ff ff
	ff		 jne	 $LN6@BuildLinks
$LN5@BuildLinks:

; 476  : 			}
; 477  : 		}
; 478  : 	}
; 479  : }

  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c2 04 00	 ret	 4
?BuildLinks@Sim@@IAEXXZ ENDP				; Sim::BuildLinks
_TEXT	ENDS
PUBLIC	?CreateRegions@Sim@@IAEXXZ			; Sim::CreateRegions
;	COMDAT xdata$x
; File c:\matrix games\dev\foundationex\text.h
xdata$x	SEGMENT
__unwindtable$?CreateRegions@Sim@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateRegions@Sim@@IAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateRegions@Sim@@IAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateRegions@Sim@@IAEXXZ$2
__ehfuncinfo$?CreateRegions@Sim@@IAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?CreateRegions@Sim@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateRegions@Sim@@IAEXXZ
_TEXT	SEGMENT
_iter$ = -80						; size = 8
_rgn$118607 = -72					; size = 8
_rgn$118593 = -64					; size = 8
_moon$118573 = -56					; size = 8
_rgn$118579 = -48					; size = 8
_star$118562 = -40					; size = 8
_planet$118567 = -32					; size = 8
$T375355 = -24						; size = 4
$T375351 = -24						; size = 4
$T375347 = -24						; size = 4
_active_region_name$ = -20				; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?CreateRegions@Sim@@IAEXXZ PROC				; Sim::CreateRegions, COMDAT

; 407  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateRegions@Sim@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 408  : 	const char* active_region_name = 0;
; 409  : 
; 410  : 	if (mission)

  00028	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [eax+192]
  00031	85 c0		 test	 eax, eax
  00033	0f 84 eb 02 00
	00		 je	 $LN19@CreateRegi

; 411  : 		active_region_name = mission->GetRegion();

  00039	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]

; 412  : 	else return;
; 413  : 
; 414  : 	ListIter<StarSystem> iter = mission->GetSystemList();

  0003f	05 e0 00 00 00	 add	 eax, 224		; 000000e0H
  00044	83 ce ff	 or	 esi, -1

; 415  : 	while (++iter) {

  00047	8d 55 b0	 lea	 edx, DWORD PTR _iter$[ebp]
  0004a	89 4d ec	 mov	 DWORD PTR _active_region_name$[ebp], ecx
  0004d	89 45 b0	 mov	 DWORD PTR _iter$[ebp], eax
  00050	89 75 b4	 mov	 DWORD PTR _iter$[ebp+4], esi
  00053	e8 00 00 00 00	 call	 ?next@?$ListIter@VStarSystem@@@@QAEPAVStarSystem@@XZ ; ListIter<StarSystem>::next
  00058	85 c0		 test	 eax, eax
  0005a	0f 84 c4 02 00
	00		 je	 $LN19@CreateRegi
$LL17@CreateRegi:

; 416  : 		StarSystem* sys = iter.value();

  00060	8d 45 b0	 lea	 eax, DWORD PTR _iter$[ebp]
  00063	e8 00 00 00 00	 call	 ?value@?$ListIter@VStarSystem@@@@QAEPAVStarSystem@@XZ ; ListIter<StarSystem>::value

; 417  : 
; 418  : 		// insert objects from star system:
; 419  : 		ListIter<OrbitalBody> star = sys->Bodies();

  00068	05 08 01 00 00	 add	 eax, 264		; 00000108H

; 420  : 		while (++star) {

  0006d	8d 55 d8	 lea	 edx, DWORD PTR _star$118562[ebp]
  00070	89 45 d8	 mov	 DWORD PTR _star$118562[ebp], eax
  00073	89 75 dc	 mov	 DWORD PTR _star$118562[ebp+4], esi
  00076	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::next
  0007b	85 c0		 test	 eax, eax
  0007d	0f 84 91 02 00
	00		 je	 $LN14@CreateRegi
$LN15@CreateRegi:

; 421  : 			ListIter<OrbitalBody> planet = star->Satellites();

  00083	8d 45 d8	 lea	 eax, DWORD PTR _star$118562[ebp]
  00086	e8 00 00 00 00	 call	 ?value@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::value
  0008b	05 78 01 00 00	 add	 eax, 376		; 00000178H

; 422  : 			while (++planet) {

  00090	8d 55 e0	 lea	 edx, DWORD PTR _planet$118567[ebp]
  00093	89 45 e0	 mov	 DWORD PTR _planet$118567[ebp], eax
  00096	89 75 e4	 mov	 DWORD PTR _planet$118567[ebp+4], esi
  00099	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::next
  0009e	85 c0		 test	 eax, eax
  000a0	0f 84 a6 01 00
	00		 je	 $LN12@CreateRegi
$LN13@CreateRegi:

; 423  : 				ListIter<OrbitalBody> moon = planet->Satellites();

  000a6	8d 45 e0	 lea	 eax, DWORD PTR _planet$118567[ebp]
  000a9	e8 00 00 00 00	 call	 ?value@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::value
  000ae	05 78 01 00 00	 add	 eax, 376		; 00000178H

; 424  : 				while (++moon) {

  000b3	8d 55 c8	 lea	 edx, DWORD PTR _moon$118573[ebp]
  000b6	89 45 c8	 mov	 DWORD PTR _moon$118573[ebp], eax
  000b9	89 75 cc	 mov	 DWORD PTR _moon$118573[ebp+4], esi
  000bc	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::next
  000c1	85 c0		 test	 eax, eax
  000c3	0f 84 c2 00 00
	00		 je	 $LN10@CreateRegi
$LN11@CreateRegi:

; 425  : 					ListIter<OrbitalRegion> rgn = moon->Regions();

  000c9	8d 45 c8	 lea	 eax, DWORD PTR _moon$118573[ebp]
  000cc	e8 00 00 00 00	 call	 ?value@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::value
  000d1	05 f0 00 00 00	 add	 eax, 240		; 000000f0H

; 426  : 					while (++rgn) {

  000d6	8d 55 d0	 lea	 edx, DWORD PTR _rgn$118579[ebp]
  000d9	89 45 d0	 mov	 DWORD PTR _rgn$118579[ebp], eax
  000dc	89 75 d4	 mov	 DWORD PTR _rgn$118579[ebp+4], esi
  000df	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::next
  000e4	85 c0		 test	 eax, eax
  000e6	0f 84 8f 00 00
	00		 je	 $LN8@CreateRegi
  000ec	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  000ef	90		 npad	 1
$LL9@CreateRegi:

; 427  : 						SimRegion* sim_region = new(__FILE__,__LINE__) SimRegion(this, rgn.value());

  000f0	68 08 01 00 00	 push	 264			; 00000108H
  000f5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000fa	8b f8		 mov	 edi, eax
  000fc	83 c4 04	 add	 esp, 4
  000ff	89 7d e8	 mov	 DWORD PTR $T375347[ebp], edi
  00102	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00109	85 ff		 test	 edi, edi
  0010b	74 17		 je	 SHORT $LN22@CreateRegi
  0010d	8d 45 d0	 lea	 eax, DWORD PTR _rgn$118579[ebp]
  00110	e8 00 00 00 00	 call	 ?value@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::value
  00115	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00118	50		 push	 eax
  00119	52		 push	 edx
  0011a	57		 push	 edi
  0011b	e8 00 00 00 00	 call	 ??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z ; SimRegion::SimRegion
  00120	8b f8		 mov	 edi, eax
  00122	eb 02		 jmp	 SHORT $LN23@CreateRegi
$LN22@CreateRegi:
  00124	33 ff		 xor	 edi, edi
$LN23@CreateRegi:

; 428  : 						regions.append(sim_region);

  00126	8d 43 58	 lea	 eax, DWORD PTR [ebx+88]
  00129	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  0012c	e8 00 00 00 00	 call	 ?append@?$List@VSimRegion@@@@QAEXPBVSimRegion@@@Z ; List<SimRegion>::append

; 429  : 						if (!strcmp(active_region_name, sim_region->Name())) {

  00131	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00134	8b 45 ec	 mov	 eax, DWORD PTR _active_region_name$[ebp]
$LL112@CreateRegi:
  00137	8a 10		 mov	 dl, BYTE PTR [eax]
  00139	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0013b	75 1a		 jne	 SHORT $LN113@CreateRegi
  0013d	84 d2		 test	 dl, dl
  0013f	74 12		 je	 SHORT $LN114@CreateRegi
  00141	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00144	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00147	75 0e		 jne	 SHORT $LN113@CreateRegi
  00149	83 c0 02	 add	 eax, 2
  0014c	83 c1 02	 add	 ecx, 2
  0014f	84 d2		 test	 dl, dl
  00151	75 e4		 jne	 SHORT $LL112@CreateRegi
$LN114@CreateRegi:
  00153	33 c0		 xor	 eax, eax
  00155	eb 04		 jmp	 SHORT $LN115@CreateRegi
$LN113@CreateRegi:
  00157	1b c0		 sbb	 eax, eax
  00159	1b c6		 sbb	 eax, esi
$LN115@CreateRegi:
  0015b	85 c0		 test	 eax, eax
  0015d	75 0c		 jne	 SHORT $LN7@CreateRegi

; 430  : 							ActivateRegion(sim_region);

  0015f	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00162	57		 push	 edi
  00163	e8 00 00 00 00	 call	 ?ActivateRegion@Sim@@QAE_NPAVSimRegion@@@Z ; Sim::ActivateRegion
  00168	83 ce ff	 or	 esi, -1
$LN7@CreateRegi:

; 426  : 					while (++rgn) {

  0016b	8d 55 d0	 lea	 edx, DWORD PTR _rgn$118579[ebp]
  0016e	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::next
  00173	85 c0		 test	 eax, eax
  00175	0f 85 75 ff ff
	ff		 jne	 $LL9@CreateRegi
$LN8@CreateRegi:

; 424  : 				while (++moon) {

  0017b	8d 55 c8	 lea	 edx, DWORD PTR _moon$118573[ebp]
  0017e	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::next
  00183	85 c0		 test	 eax, eax
  00185	0f 85 3e ff ff
	ff		 jne	 $LN11@CreateRegi
$LN10@CreateRegi:

; 431  : 						}
; 432  : 					}
; 433  : 				}
; 434  : 				
; 435  : 				ListIter<OrbitalRegion> rgn = planet->Regions();

  0018b	8d 45 e0	 lea	 eax, DWORD PTR _planet$118567[ebp]
  0018e	e8 00 00 00 00	 call	 ?value@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::value
  00193	05 f0 00 00 00	 add	 eax, 240		; 000000f0H

; 436  : 				while (++rgn) {

  00198	8d 55 c0	 lea	 edx, DWORD PTR _rgn$118593[ebp]
  0019b	89 45 c0	 mov	 DWORD PTR _rgn$118593[ebp], eax
  0019e	89 75 c4	 mov	 DWORD PTR _rgn$118593[ebp+4], esi
  001a1	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::next
  001a6	85 c0		 test	 eax, eax
  001a8	0f 84 8e 00 00
	00		 je	 $LN5@CreateRegi
  001ae	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
$LL6@CreateRegi:

; 437  : 					SimRegion* sim_region = new(__FILE__,__LINE__) SimRegion(this, rgn.value());

  001b1	68 08 01 00 00	 push	 264			; 00000108H
  001b6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001bb	8b f8		 mov	 edi, eax
  001bd	83 c4 04	 add	 esp, 4
  001c0	89 7d e8	 mov	 DWORD PTR $T375351[ebp], edi
  001c3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  001ca	85 ff		 test	 edi, edi
  001cc	74 17		 je	 SHORT $LN24@CreateRegi
  001ce	8d 45 c0	 lea	 eax, DWORD PTR _rgn$118593[ebp]
  001d1	e8 00 00 00 00	 call	 ?value@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::value
  001d6	50		 push	 eax
  001d7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001da	50		 push	 eax
  001db	57		 push	 edi
  001dc	e8 00 00 00 00	 call	 ??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z ; SimRegion::SimRegion
  001e1	8b f8		 mov	 edi, eax
  001e3	eb 02		 jmp	 SHORT $LN25@CreateRegi
$LN24@CreateRegi:
  001e5	33 ff		 xor	 edi, edi
$LN25@CreateRegi:

; 438  : 					regions.append(sim_region);

  001e7	8d 43 58	 lea	 eax, DWORD PTR [ebx+88]
  001ea	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  001ed	e8 00 00 00 00	 call	 ?append@?$List@VSimRegion@@@@QAEXPBVSimRegion@@@Z ; List<SimRegion>::append

; 439  : 					if (!strcmp(active_region_name, sim_region->Name())) {

  001f2	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  001f5	8b 45 ec	 mov	 eax, DWORD PTR _active_region_name$[ebp]
$LL116@CreateRegi:
  001f8	8a 10		 mov	 dl, BYTE PTR [eax]
  001fa	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001fc	75 1a		 jne	 SHORT $LN117@CreateRegi
  001fe	84 d2		 test	 dl, dl
  00200	74 12		 je	 SHORT $LN118@CreateRegi
  00202	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00205	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00208	75 0e		 jne	 SHORT $LN117@CreateRegi
  0020a	83 c0 02	 add	 eax, 2
  0020d	83 c1 02	 add	 ecx, 2
  00210	84 d2		 test	 dl, dl
  00212	75 e4		 jne	 SHORT $LL116@CreateRegi
$LN118@CreateRegi:
  00214	33 c0		 xor	 eax, eax
  00216	eb 04		 jmp	 SHORT $LN119@CreateRegi
$LN117@CreateRegi:
  00218	1b c0		 sbb	 eax, eax
  0021a	1b c6		 sbb	 eax, esi
$LN119@CreateRegi:
  0021c	85 c0		 test	 eax, eax
  0021e	75 0c		 jne	 SHORT $LN4@CreateRegi

; 440  : 						ActivateRegion(sim_region);

  00220	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00223	57		 push	 edi
  00224	e8 00 00 00 00	 call	 ?ActivateRegion@Sim@@QAE_NPAVSimRegion@@@Z ; Sim::ActivateRegion
  00229	83 ce ff	 or	 esi, -1
$LN4@CreateRegi:

; 436  : 				while (++rgn) {

  0022c	8d 55 c0	 lea	 edx, DWORD PTR _rgn$118593[ebp]
  0022f	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::next
  00234	85 c0		 test	 eax, eax
  00236	0f 85 75 ff ff
	ff		 jne	 $LL6@CreateRegi
$LN5@CreateRegi:

; 422  : 			while (++planet) {

  0023c	8d 55 e0	 lea	 edx, DWORD PTR _planet$118567[ebp]
  0023f	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::next
  00244	85 c0		 test	 eax, eax
  00246	0f 85 5a fe ff
	ff		 jne	 $LN13@CreateRegi
$LN12@CreateRegi:

; 441  : 					}
; 442  : 				}
; 443  : 			}
; 444  : 			
; 445  : 			ListIter<OrbitalRegion> rgn = star->Regions();

  0024c	8d 45 d8	 lea	 eax, DWORD PTR _star$118562[ebp]
  0024f	e8 00 00 00 00	 call	 ?value@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::value
  00254	05 f0 00 00 00	 add	 eax, 240		; 000000f0H

; 446  : 			while (++rgn) {

  00259	8d 55 b8	 lea	 edx, DWORD PTR _rgn$118607[ebp]
  0025c	89 45 b8	 mov	 DWORD PTR _rgn$118607[ebp], eax
  0025f	89 75 bc	 mov	 DWORD PTR _rgn$118607[ebp+4], esi
  00262	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::next
  00267	85 c0		 test	 eax, eax
  00269	0f 84 95 00 00
	00		 je	 $LN2@CreateRegi
  0026f	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
$LL3@CreateRegi:

; 447  : 				SimRegion* sim_region = new(__FILE__,__LINE__) SimRegion(this, rgn.value());

  00272	68 08 01 00 00	 push	 264			; 00000108H
  00277	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0027c	8b f8		 mov	 edi, eax
  0027e	83 c4 04	 add	 esp, 4
  00281	89 7d e8	 mov	 DWORD PTR $T375355[ebp], edi
  00284	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0028b	85 ff		 test	 edi, edi
  0028d	74 17		 je	 SHORT $LN26@CreateRegi
  0028f	8d 45 b8	 lea	 eax, DWORD PTR _rgn$118607[ebp]
  00292	e8 00 00 00 00	 call	 ?value@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::value
  00297	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0029a	50		 push	 eax
  0029b	51		 push	 ecx
  0029c	57		 push	 edi
  0029d	e8 00 00 00 00	 call	 ??0SimRegion@@QAE@PAVSim@@PAVOrbitalRegion@@@Z ; SimRegion::SimRegion
  002a2	8b f8		 mov	 edi, eax
  002a4	eb 02		 jmp	 SHORT $LN27@CreateRegi
$LN26@CreateRegi:
  002a6	33 ff		 xor	 edi, edi
$LN27@CreateRegi:

; 448  : 				regions.append(sim_region);

  002a8	8d 43 58	 lea	 eax, DWORD PTR [ebx+88]
  002ab	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  002ae	e8 00 00 00 00	 call	 ?append@?$List@VSimRegion@@@@QAEXPBVSimRegion@@@Z ; List<SimRegion>::append

; 449  : 				if (!strcmp(active_region_name, sim_region->Name())) {

  002b3	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  002b6	8b 45 ec	 mov	 eax, DWORD PTR _active_region_name$[ebp]
  002b9	8d a4 24 00 00
	00 00		 npad	 7
$LL120@CreateRegi:
  002c0	8a 10		 mov	 dl, BYTE PTR [eax]
  002c2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  002c4	75 1a		 jne	 SHORT $LN121@CreateRegi
  002c6	84 d2		 test	 dl, dl
  002c8	74 12		 je	 SHORT $LN122@CreateRegi
  002ca	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  002cd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002d0	75 0e		 jne	 SHORT $LN121@CreateRegi
  002d2	83 c0 02	 add	 eax, 2
  002d5	83 c1 02	 add	 ecx, 2
  002d8	84 d2		 test	 dl, dl
  002da	75 e4		 jne	 SHORT $LL120@CreateRegi
$LN122@CreateRegi:
  002dc	33 c0		 xor	 eax, eax
  002de	eb 04		 jmp	 SHORT $LN123@CreateRegi
$LN121@CreateRegi:
  002e0	1b c0		 sbb	 eax, eax
  002e2	1b c6		 sbb	 eax, esi
$LN123@CreateRegi:
  002e4	85 c0		 test	 eax, eax
  002e6	75 0c		 jne	 SHORT $LN1@CreateRegi

; 450  : 					ActivateRegion(sim_region);

  002e8	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  002eb	57		 push	 edi
  002ec	e8 00 00 00 00	 call	 ?ActivateRegion@Sim@@QAE_NPAVSimRegion@@@Z ; Sim::ActivateRegion
  002f1	83 ce ff	 or	 esi, -1
$LN1@CreateRegi:

; 446  : 			while (++rgn) {

  002f4	8d 55 b8	 lea	 edx, DWORD PTR _rgn$118607[ebp]
  002f7	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalRegion@@@@QAEPAVOrbitalRegion@@XZ ; ListIter<OrbitalRegion>::next
  002fc	85 c0		 test	 eax, eax
  002fe	0f 85 6e ff ff
	ff		 jne	 $LL3@CreateRegi
$LN2@CreateRegi:

; 420  : 		while (++star) {

  00304	8d 55 d8	 lea	 edx, DWORD PTR _star$118562[ebp]
  00307	e8 00 00 00 00	 call	 ?next@?$ListIter@VOrbitalBody@@@@QAEPAVOrbitalBody@@XZ ; ListIter<OrbitalBody>::next
  0030c	85 c0		 test	 eax, eax
  0030e	0f 85 6f fd ff
	ff		 jne	 $LN15@CreateRegi
$LN14@CreateRegi:

; 415  : 	while (++iter) {

  00314	8d 55 b0	 lea	 edx, DWORD PTR _iter$[ebp]
  00317	e8 00 00 00 00	 call	 ?next@?$ListIter@VStarSystem@@@@QAEPAVStarSystem@@XZ ; ListIter<StarSystem>::next
  0031c	85 c0		 test	 eax, eax
  0031e	0f 85 3c fd ff
	ff		 jne	 $LL17@CreateRegi
$LN19@CreateRegi:

; 451  : 				}
; 452  : 			}
; 453  : 		}
; 454  : 	}
; 455  : }

  00324	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00327	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0032e	59		 pop	 ecx
  0032f	5f		 pop	 edi
  00330	5e		 pop	 esi
  00331	5b		 pop	 ebx
  00332	8b e5		 mov	 esp, ebp
  00334	5d		 pop	 ebp
  00335	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateRegions@Sim@@IAEXXZ$0:
  00000	68 ab 01 00 00	 push	 427			; 000001abH
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 e8	 mov	 eax, DWORD PTR $T375347[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__unwindfunclet$?CreateRegions@Sim@@IAEXXZ$1:
  00017	68 b5 01 00 00	 push	 437			; 000001b5H
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  00021	8b 45 e8	 mov	 eax, DWORD PTR $T375351[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	c3		 ret	 0
__unwindfunclet$?CreateRegions@Sim@@IAEXXZ$2:
  0002e	68 bf 01 00 00	 push	 447			; 000001bfH
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  00038	8b 45 e8	 mov	 eax, DWORD PTR $T375355[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	c3		 ret	 0
__ehhandler$?CreateRegions@Sim@@IAEXXZ:
  00045	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00049	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004c	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateRegions@Sim@@IAEXXZ
  0005b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateRegions@Sim@@IAEXXZ ENDP				; Sim::CreateRegions
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?DockShips@SimRegion@@IAEXXZ			; SimRegion::DockShips
; Function compile flags: /Ogtp
;	COMDAT ?DockShips@SimRegion@@IAEXXZ
_TEXT	SEGMENT
_player_docked$121142 = -60				; size = 4
_ship_iter$ = -56					; size = 8
_this$GSCopy$ = -48					; size = 4
_ship_name$121143 = -44					; size = 33
__$ArrayPad$ = -8					; size = 4
_this$ = 8						; size = 4
?DockShips@SimRegion@@IAEXXZ PROC			; SimRegion::DockShips, COMDAT

; 3350 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 3351 : 	if (ships.size() == 0)

  00014	83 7b 4c 00	 cmp	 DWORD PTR [ebx+76], 0
  00018	8d 43 4c	 lea	 eax, DWORD PTR [ebx+76]
  0001b	56		 push	 esi
  0001c	57		 push	 edi

; 3395 : 			Print("    %s Docked with %s\n", ship_name, carrier->Name());

  0001d	89 5d d0	 mov	 DWORD PTR _this$GSCopy$[ebp], ebx
  00020	0f 84 27 01 00
	00		 je	 $LN10@DockShips

; 3352 : 	return;
; 3353 : 
; 3354 : 	ListIter<Ship> ship_iter = ships;

  00026	8d 55 c8	 lea	 edx, DWORD PTR _ship_iter$[ebp]
  00029	89 45 c8	 mov	 DWORD PTR _ship_iter$[ebp], eax
  0002c	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _ship_iter$[ebp+4], -1

; 3355 : 	while (++ship_iter) {

  00033	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 0d 01 00
	00		 je	 $LN10@DockShips
  00040	eb 03		 jmp	 SHORT $LN11@DockShips
$LL45@DockShips:
  00042	8b 5d d0	 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
$LN11@DockShips:

; 3356 : 		Ship* ship   = ship_iter.value();

  00045	8d 45 c8	 lea	 eax, DWORD PTR _ship_iter$[ebp]
  00048	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  0004d	8b f0		 mov	 esi, eax

; 3357 : 		int   docked = (ship->GetFlightPhase() == Ship::DOCKED);

  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	8b 90 d4 00 00
	00		 mov	 edx, DWORD PTR [eax+212]
  00057	8b ce		 mov	 ecx, esi
  00059	ff d2		 call	 edx
  0005b	85 c0		 test	 eax, eax

; 3358 : 
; 3359 : 		if (docked) {

  0005d	0f 85 da 00 00
	00		 jne	 $LN1@DockShips

; 3360 : 			sim->ProcessEventTrigger(MissionEvent::TRIGGER_DOCK, 0, ship->Name());

  00063	50		 push	 eax
  00064	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  00067	57		 push	 edi
  00068	50		 push	 eax
  00069	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0006c	6a 05		 push	 5
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z ; Sim::ProcessEventTrigger

; 3361 : 
; 3362 : 			// who did this ship dock with?
; 3363 : 			Ship* carrier = ship->GetCarrier();

  00074	8b 9e 2c 04 00
	00		 mov	 ebx, DWORD PTR [esi+1068]

; 3364 : 
; 3365 : 			if (carrier) {

  0007a	85 db		 test	 ebx, ebx
  0007c	74 41		 je	 SHORT $LN4@DockShips

; 3366 : 				ShipStats* s = ShipStats::Find(ship->Name());

  0007e	8b cf		 mov	 ecx, edi
  00080	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  00085	8b d0		 mov	 edx, eax

; 3367 : 				if (s) {

  00087	85 d2		 test	 edx, edx
  00089	74 1f		 je	 SHORT $LN5@DockShips

; 3368 : 					if (ship->IsAirborne())

  0008b	8b c6		 mov	 eax, esi
  0008d	e8 00 00 00 00	 call	 ?IsAirborne@Ship@@QBE_NXZ ; Ship::IsAirborne
  00092	84 c0		 test	 al, al
  00094	74 08		 je	 SHORT $LN6@DockShips

; 3369 : 					s->AddEvent(SimEvent::LAND, carrier->Name());

  00096	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  00099	51		 push	 ecx
  0009a	6a 03		 push	 3

; 3370 : 					else

  0009c	eb 06		 jmp	 SHORT $LN46@DockShips
$LN6@DockShips:

; 3371 : 					s->AddEvent(SimEvent::DOCK, carrier->Name());

  0009e	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  000a1	50		 push	 eax
  000a2	6a 02		 push	 2
$LN46@DockShips:
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
$LN5@DockShips:

; 3372 : 				}
; 3373 : 
; 3374 : 				ShipStats* c = ShipStats::Find(carrier->Name());

  000aa	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  000ad	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find

; 3375 : 				if (c) c->AddEvent(SimEvent::RECOVER_SHIP, ship->Name());

  000b2	85 c0		 test	 eax, eax
  000b4	74 09		 je	 SHORT $LN4@DockShips
  000b6	57		 push	 edi
  000b7	6a 0c		 push	 12			; 0000000cH
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
$LN4@DockShips:

; 3376 : 			}
; 3377 : 
; 3378 : 			// then delete the ship:
; 3379 : 			int  player_docked = (player_ship == ship);

  000bf	8b 55 d0	 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  000c2	33 c9		 xor	 ecx, ecx
  000c4	39 72 44	 cmp	 DWORD PTR [edx+68], esi

; 3380 : 			char ship_name[33];
; 3381 : 			strcpy_s(ship_name, ship->Name());

  000c7	57		 push	 edi
  000c8	0f 94 c1	 sete	 cl
  000cb	8d 45 d4	 lea	 eax, DWORD PTR _ship_name$121143[ebp]
  000ce	6a 21		 push	 33			; 00000021H
  000d0	50		 push	 eax
  000d1	89 4d c4	 mov	 DWORD PTR _player_docked$121142[ebp], ecx
  000d4	e8 00 00 00 00	 call	 _strcpy_s

; 3382 : 
; 3383 : 			selection.remove(ship);

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000df	83 c0 64	 add	 eax, 100		; 00000064H
  000e2	8b fe		 mov	 edi, esi
  000e4	e8 00 00 00 00	 call	 ?remove@?$List@VShip@@@@QAEPAVShip@@PBV2@@Z ; List<Ship>::remove

; 3384 : 			dead_ships.insert(ship_iter.removeItem());

  000e9	8d 55 c8	 lea	 edx, DWORD PTR _ship_iter$[ebp]
  000ec	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::removeItem
  000f1	50		 push	 eax
  000f2	8b 45 d0	 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  000f5	83 c0 70	 add	 eax, 112		; 00000070H
  000f8	33 ff		 xor	 edi, edi
  000fa	e8 00 00 00 00	 call	 ?insert@?$List@VShip@@@@QAEXPBVShip@@H@Z ; List<Ship>::insert

; 3385 : 			ship->Destroy();

  000ff	8b 16		 mov	 edx, DWORD PTR [esi]
  00101	8b 82 84 01 00
	00		 mov	 eax, DWORD PTR [edx+388]
  00107	8b ce		 mov	 ecx, esi
  00109	ff d0		 call	 eax

; 3386 : 
; 3387 : 			if (player_docked) {

  0010b	39 7d c4	 cmp	 DWORD PTR _player_docked$121142[ebp], edi
  0010e	74 14		 je	 SHORT $LN2@DockShips

; 3388 : 				// close mission, return to menu:
; 3389 : 				Starshatter* stars = Starshatter::GetInstance();

  00110	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?instance@Starshatter@@1PAV1@A ; Starshatter::instance

; 3390 : 				if (stars)

  00116	85 c9		 test	 ecx, ecx
  00118	74 0a		 je	 SHORT $LN2@DockShips

; 3391 : 				stars->SetGameMode(Starshatter::PLAN_MODE);

  0011a	bf 04 00 00 00	 mov	 edi, 4
  0011f	e8 00 00 00 00	 call	 ?SetGameMode@Starshatter@@QAEXH@Z ; Starshatter::SetGameMode
$LN2@DockShips:

; 3392 : 			}
; 3393 : 
; 3394 : 			if (carrier)

  00124	85 db		 test	 ebx, ebx
  00126	74 15		 je	 SHORT $LN1@DockShips

; 3395 : 			Print("    %s Docked with %s\n", ship_name, carrier->Name());

  00128	83 c3 10	 add	 ebx, 16			; 00000010H
  0012b	53		 push	 ebx
  0012c	8d 4d d4	 lea	 ecx, DWORD PTR _ship_name$121143[ebp]
  0012f	51		 push	 ecx
  00130	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CIBPJMDL@?5?5?5?5?$CFs?5Docked?5with?5?$CFs?6?$AA@
  00135	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@DockShips:

; 3355 : 	while (++ship_iter) {

  0013d	8d 55 c8	 lea	 edx, DWORD PTR _ship_iter$[ebp]
  00140	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00145	85 c0		 test	 eax, eax
  00147	0f 85 f5 fe ff
	ff		 jne	 $LL45@DockShips
$LN10@DockShips:

; 3396 : 		}
; 3397 : 	}
; 3398 : }

  0014d	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	33 cd		 xor	 ecx, ebp
  00154	5b		 pop	 ebx
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 04 00	 ret	 4
?DockShips@SimRegion@@IAEXXZ ENDP			; SimRegion::DockShips
_TEXT	ENDS
PUBLIC	?SetPlayerShip@SimRegion@@QAEXPAVShip@@@Z	; SimRegion::SetPlayerShip
; Function compile flags: /Ogtp
;	COMDAT ?SetPlayerShip@SimRegion@@QAEXPAVShip@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?SetPlayerShip@SimRegion@@QAEXPAVShip@@@Z PROC		; SimRegion::SetPlayerShip, COMDAT
; _ship$ = eax

; 2309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2310 : 	// there can only be a player ship when playing the game locally
; 2311 : 	if (Starshatter::GetInstance()) {

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?instance@Starshatter@@1PAV1@A, 0 ; Starshatter::instance
  0000a	53		 push	 ebx
  0000b	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b f0		 mov	 esi, eax
  00012	74 4f		 je	 SHORT $LN6@SetPlayerS

; 2312 : 		int player_index = ships.index(ship);

  00014	8d 4b 4c	 lea	 ecx, DWORD PTR [ebx+76]
  00017	e8 00 00 00 00	 call	 ?index@?$List@VShip@@@@QBEHPBVShip@@@Z ; List<Ship>::index
  0001c	8b f8		 mov	 edi, eax

; 2313 : 
; 2314 : 		if (player_index >= 0) {

  0001e	85 ff		 test	 edi, edi
  00020	78 1c		 js	 SHORT $LN5@SetPlayerS

; 2315 : 			if (sim->GetActiveRegion() != this)

  00022	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00025	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  00028	74 06		 je	 SHORT $LN4@SetPlayerS

; 2316 : 			sim->ActivateRegion(this);

  0002a	53		 push	 ebx
  0002b	e8 00 00 00 00	 call	 ?ActivateRegion@Sim@@QAE_NPAVSimRegion@@@Z ; Sim::ActivateRegion
$LN4@SetPlayerS:

; 2317 : 
; 2318 : 			AttachPlayerShip(player_index);

  00030	8b f3		 mov	 esi, ebx
  00032	e8 00 00 00 00	 call	 ?AttachPlayerShip@SimRegion@@IAEXH@Z ; SimRegion::AttachPlayerShip

; 2331 : 
; 2332 : 		current_view = -1;
; 2333 : 		player_ship = 0;
; 2334 : 	}
; 2335 : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
$LN5@SetPlayerS:

; 2319 : 		}
; 2320 : 
; 2321 : 		else {
; 2322 : 			Print("SimRegion %s could not set player ship '%s' - not in region\n",
; 2323 : 			name.data(), ship ? ship->Name() : "(null)");

  0003e	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00041	85 f6		 test	 esi, esi
  00043	75 05		 jne	 SHORT $LN10@SetPlayerS
  00045	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
$LN10@SetPlayerS:
  0004a	50		 push	 eax
  0004b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0004e	50		 push	 eax
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@GOGEGHME@SimRegion?5?$CFs?5could?5not?5set?5playe@
  00054	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2331 : 
; 2332 : 		current_view = -1;
; 2333 : 		player_ship = 0;
; 2334 : 	}
; 2335 : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN6@SetPlayerS:

; 2324 : 		}
; 2325 : 	}
; 2326 : 
; 2327 : 	// if this is a stand-alone server, set player ship to null
; 2328 : 	else {
; 2329 : 		if (player_ship)

  00063	8b 4b 44	 mov	 ecx, DWORD PTR [ebx+68]
  00066	85 c9		 test	 ecx, ecx
  00068	74 0c		 je	 SHORT $LN1@SetPlayerS

; 2330 : 		player_ship->SetControls(0);

  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  00072	6a 00		 push	 0
  00074	ff d0		 call	 eax
$LN1@SetPlayerS:

; 2331 : 
; 2332 : 		current_view = -1;
; 2333 : 		player_ship = 0;
; 2334 : 	}
; 2335 : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	c7 43 48 ff ff
	ff ff		 mov	 DWORD PTR [ebx+72], -1
  0007f	c7 43 44 00 00
	00 00		 mov	 DWORD PTR [ebx+68], 0
  00086	5b		 pop	 ebx
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?SetPlayerShip@SimRegion@@QAEXPAVShip@@@Z ENDP		; SimRegion::SetPlayerShip
_TEXT	ENDS
PUBLIC	?ResolveHyperList@Sim@@QAEXXZ			; Sim::ResolveHyperList
;	COMDAT xdata$x
; File c:\matrix games\dev\stars45\ship.h
xdata$x	SEGMENT
__unwindtable$?ResolveHyperList@Sim@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResolveHyperList@Sim@@QAEXXZ$0
__ehfuncinfo$?ResolveHyperList@Sim@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ResolveHyperList@Sim@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?ResolveHyperList@Sim@@QAEXXZ
_TEXT	SEGMENT
_dest$119787 = -216					; size = 4
_i$119849 = -212					; size = 4
_i$119827 = -212					; size = 4
$T396874 = -208						; size = 24
$T396870 = -208						; size = 24
$T396869 = -208						; size = 24
$T396867 = -208						; size = 24
$T396866 = -208						; size = 24
$T396864 = -208						; size = 24
$T396862 = -208						; size = 24
$T396873 = -184						; size = 24
$T396871 = -184						; size = 24
$T396861 = -184						; size = 24
$T396860 = -184						; size = 24
$T396859 = -184						; size = 24
$T396857 = -184						; size = 24
_deck$119823 = -156					; size = 8
_jump$119784 = -148					; size = 4
_riders$119835 = -144					; size = 12
_j_iter$119780 = -132					; size = 8
_neighbor$119837 = -124					; size = 8
_pship$119746 = -116					; size = 4
$T397011 = -112						; size = 8
$T397013 = -104						; size = 8
$T397012 = -96						; size = 8
$T396876 = -88						; size = 24
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?ResolveHyperList@Sim@@QAEXXZ PROC			; Sim::ResolveHyperList, COMDAT

; 1595 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?ResolveHyperList@Sim@@QAEXXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c4		 xor	 eax, esp
  00024	50		 push	 eax
  00025	8d 84 24 f8 00
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+260]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1596 : 	// resolve the hyper space transitions:
; 1597 : 	if (jumplist.size()) {

  00032	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00035	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  00038	8d 73 70	 lea	 esi, DWORD PTR [ebx+112]
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 1a 08 00
	00		 je	 $LN1@ResolveHyp

; 1598 : 		Ship* pship = GetPlayerShip();

  00043	8b cb		 mov	 ecx, ebx
  00045	e8 00 00 00 00	 call	 ?GetPlayerShip@Sim@@QAEPAVShip@@XZ ; Sim::GetPlayerShip
  0004a	8b f8		 mov	 edi, eax

; 1599 : 
; 1600 : 		ListIter<SimHyper> j_iter = jumplist;
; 1601 : 		while (++j_iter) {

  0004c	8d 94 24 80 00
	00 00		 lea	 edx, DWORD PTR _j_iter$119780[esp+260]
  00053	89 bc 24 90 00
	00 00		 mov	 DWORD PTR _pship$119746[esp+260], edi
  0005a	89 b4 24 80 00
	00 00		 mov	 DWORD PTR _j_iter$119780[esp+260], esi
  00061	c7 84 24 84 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR _j_iter$119780[esp+264], -1
  0006c	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ ; ListIter<SimHyper>::next
  00071	85 c0		 test	 eax, eax
  00073	0f 84 a3 07 00
	00		 je	 $LN34@ResolveHyp
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL35@ResolveHyp:

; 1602 : 			SimHyper*   jump     = j_iter.value();

  00080	8d 84 24 80 00
	00 00		 lea	 eax, DWORD PTR _j_iter$119780[esp+260]
  00087	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ ; ListIter<SimHyper>::value
  0008c	8b f8		 mov	 edi, eax

; 1603 : 			Ship*       jumpship = jump->ship;

  0008e	8b 1f		 mov	 ebx, DWORD PTR [edi]

; 1604 : 
; 1605 : 			if (jumpship) {

  00090	33 f6		 xor	 esi, esi
  00092	89 7c 24 70	 mov	 DWORD PTR _jump$119784[esp+260], edi
  00096	3b de		 cmp	 ebx, esi
  00098	0f 84 60 07 00
	00		 je	 $LN3@ResolveHyp

; 1606 : 				SimRegion* dest = jump->rgn;

  0009e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000a1	89 44 24 2c	 mov	 DWORD PTR _dest$119787[esp+260], eax

; 1607 : 
; 1608 : 				if (!dest)

  000a5	3b c6		 cmp	 eax, esi
  000a7	75 18		 jne	 SHORT $LN284@ResolveHyp

; 1609 : 				dest = FindNearestSpaceRegion(jumpship);

  000a9	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b f3		 mov	 esi, ebx
  000ae	e8 00 00 00 00	 call	 ?FindNearestSpaceRegion@Sim@@QAEPAVSimRegion@@PAVSimObject@@@Z ; Sim::FindNearestSpaceRegion
  000b3	89 44 24 2c	 mov	 DWORD PTR _dest$119787[esp+260], eax

; 1610 : 
; 1611 : 				if (dest) {

  000b7	85 c0		 test	 eax, eax
  000b9	0f 84 fe 06 00
	00		 je	 $LN31@ResolveHyp
  000bf	33 f6		 xor	 esi, esi
$LN284@ResolveHyp:

; 1612 : 					// bring along fighters on deck:
; 1613 : 					ListIter<FlightDeck> deck = jumpship->FlightDecks();

  000c1	8d 83 c0 03 00
	00		 lea	 eax, DWORD PTR [ebx+960]

; 1614 : 					while (++deck) {

  000c7	8d 54 24 68	 lea	 edx, DWORD PTR _deck$119823[esp+260]
  000cb	89 44 24 68	 mov	 DWORD PTR _deck$119823[esp+260], eax
  000cf	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR _deck$119823[esp+264], -1
  000d7	e8 00 00 00 00	 call	 ?next@?$ListIter@VFlightDeck@@@@QAEPAVFlightDeck@@XZ ; ListIter<FlightDeck>::next
  000dc	85 c0		 test	 eax, eax
  000de	74 62		 je	 SHORT $LN29@ResolveHyp
$LL30@ResolveHyp:

; 1615 : 						for (int i = 0; i < deck->NumSlots(); i++) {

  000e0	8d 44 24 68	 lea	 eax, DWORD PTR _deck$119823[esp+260]
  000e4	89 74 24 30	 mov	 DWORD PTR _i$119827[esp+260], esi
  000e8	e8 00 00 00 00	 call	 ?value@?$ListIter@VFlightDeck@@@@QAEPAVFlightDeck@@XZ ; ListIter<FlightDeck>::value
  000ed	8b c8		 mov	 ecx, eax
  000ef	39 b1 d0 00 00
	00		 cmp	 DWORD PTR [ecx+208], esi
  000f5	7e 3e		 jle	 SHORT $LN26@ResolveHyp
$LN28@ResolveHyp:

; 1616 : 							Ship* s = deck->GetShip(i);

  000f7	8b 44 24 30	 mov	 eax, DWORD PTR _i$119827[esp+260]
  000fb	e8 00 00 00 00	 call	 ?GetShip@FlightDeck@@QBEPAVShip@@H@Z ; FlightDeck::GetShip
  00100	8b f0		 mov	 esi, eax

; 1617 : 
; 1618 : 							if (s) {

  00102	85 f6		 test	 esi, esi
  00104	74 11		 je	 SHORT $LN27@ResolveHyp

; 1619 : 								dest->InsertObject(s);

  00106	8b 4c 24 2c	 mov	 ecx, DWORD PTR _dest$119787[esp+260]
  0010a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010c	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0010f	56		 push	 esi
  00110	ff d0		 call	 eax

; 1620 : 								s->ClearTrack();

  00112	e8 00 00 00 00	 call	 ?ClearTrack@Ship@@QAEXXZ ; Ship::ClearTrack
$LN27@ResolveHyp:

; 1615 : 						for (int i = 0; i < deck->NumSlots(); i++) {

  00117	8b 74 24 30	 mov	 esi, DWORD PTR _i$119827[esp+260]
  0011b	46		 inc	 esi
  0011c	8d 44 24 68	 lea	 eax, DWORD PTR _deck$119823[esp+260]
  00120	89 74 24 30	 mov	 DWORD PTR _i$119827[esp+260], esi
  00124	e8 00 00 00 00	 call	 ?value@?$ListIter@VFlightDeck@@@@QAEPAVFlightDeck@@XZ ; ListIter<FlightDeck>::value
  00129	8b c8		 mov	 ecx, eax
  0012b	3b b1 d0 00 00
	00		 cmp	 esi, DWORD PTR [ecx+208]
  00131	7c c4		 jl	 SHORT $LN28@ResolveHyp
  00133	33 f6		 xor	 esi, esi
$LN26@ResolveHyp:

; 1614 : 					while (++deck) {

  00135	8d 54 24 68	 lea	 edx, DWORD PTR _deck$119823[esp+260]
  00139	e8 00 00 00 00	 call	 ?next@?$ListIter@VFlightDeck@@@@QAEPAVFlightDeck@@XZ ; ListIter<FlightDeck>::next
  0013e	85 c0		 test	 eax, eax
  00140	75 9e		 jne	 SHORT $LL30@ResolveHyp
$LN29@ResolveHyp:

; 1621 : 							}
; 1622 : 						}
; 1623 : 					}
; 1624 : 
; 1625 : 					if (jump->type == 0 && !jump->hyperdrive) {

  00142	39 77 20	 cmp	 DWORD PTR [edi+32], esi
  00145	0f 85 67 02 00
	00		 jne	 $LN136@ResolveHyp
  0014b	80 7f 24 00	 cmp	 BYTE PTR [edi+36], 0
  0014f	0f 85 5d 02 00
	00		 jne	 $LN136@ResolveHyp

; 1626 : 						// bring along nearby ships:
; 1627 : 						// have to do it in two parts, because inserting the ships
; 1628 : 						// into the destination corrupts the iter over the current
; 1629 : 						// region's list of ships...
; 1630 : 
; 1631 : 						// part one: gather the ships that will be jumping:
; 1632 : 						List<Ship> riders;

  00155	89 74 24 74	 mov	 DWORD PTR _riders$119835[esp+260], esi
  00159	89 74 24 78	 mov	 DWORD PTR _riders$119835[esp+264], esi
  0015d	89 74 24 7c	 mov	 DWORD PTR _riders$119835[esp+268], esi
  00161	89 b4 24 00 01
	00 00		 mov	 DWORD PTR __$EHRec$[esp+268], esi

; 1633 : 						ListIter<Ship> neighbor = jumpship->GetRegion()->Ships();

  00168	8b 13		 mov	 edx, DWORD PTR [ebx]
  0016a	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00170	8b cb		 mov	 ecx, ebx
  00172	ff d0		 call	 eax
  00174	83 c0 4c	 add	 eax, 76			; 0000004cH

; 1634 : 						while (++neighbor) {

  00177	8d 94 24 88 00
	00 00		 lea	 edx, DWORD PTR _neighbor$119837[esp+260]
  0017e	89 84 24 88 00
	00 00		 mov	 DWORD PTR _neighbor$119837[esp+260], eax
  00185	c7 84 24 8c 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR _neighbor$119837[esp+264], -1
  00190	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00195	85 c0		 test	 eax, eax
  00197	0f 84 83 00 00
	00		 je	 $LN22@ResolveHyp
  0019d	8d 49 00	 npad	 3
$LL23@ResolveHyp:

; 1635 : 							if (neighbor->IsDropship()) {

  001a0	8d 84 24 88 00
	00 00		 lea	 eax, DWORD PTR _neighbor$119837[esp+260]
  001a7	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  001ac	8b d0		 mov	 edx, eax
  001ae	e8 00 00 00 00	 call	 ?IsDropship@Ship@@QBE_NXZ ; Ship::IsDropship
  001b3	84 c0		 test	 al, al
  001b5	74 59		 je	 SHORT $LN19@ResolveHyp

; 1636 : 								Ship* s = neighbor.value();
; 1637 : 								if (s == jumpship) continue;

  001b7	3b d3		 cmp	 edx, ebx
  001b9	74 55		 je	 SHORT $LN19@ResolveHyp

; 1638 : 
; 1639 : 								Point delta = s->Location() - jumpship->Location();

  001bb	f2 0f 10 42 48	 movsd	 xmm0, QWORD PTR [edx+72]
  001c0	f2 0f 5c 43 48	 subsd	 xmm0, QWORD PTR [ebx+72]
  001c5	f2 0f 10 4a 50	 movsd	 xmm1, QWORD PTR [edx+80]
  001ca	f2 0f 5c 4b 50	 subsd	 xmm1, QWORD PTR [ebx+80]
  001cf	f2 0f 10 52 58	 movsd	 xmm2, QWORD PTR [edx+88]
  001d4	f2 0f 5c 53 58	 subsd	 xmm2, QWORD PTR [ebx+88]

; 1640 : 
; 1641 : 								if (delta.length() < 5e3) {

  001d9	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  001dd	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  001e1	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001e5	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@40b3880000000000
  001ed	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  001f1	f2 0f 58 c2	 addsd	 xmm0, xmm2
  001f5	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  001f9	66 0f 2f c8	 comisd	 xmm1, xmm0
  001fd	76 11		 jbe	 SHORT $LN19@ResolveHyp

; 1642 : 									riders.append(s);

  001ff	8b fa		 mov	 edi, edx
  00201	8d 44 24 74	 lea	 eax, DWORD PTR _riders$119835[esp+260]
  00205	e8 00 00 00 00	 call	 ?append@?$List@VShip@@@@QAEXPBVShip@@@Z ; List<Ship>::append
  0020a	8b 7c 24 70	 mov	 edi, DWORD PTR _jump$119784[esp+260]
  0020e	33 f6		 xor	 esi, esi
$LN19@ResolveHyp:

; 1634 : 						while (++neighbor) {

  00210	8d 94 24 88 00
	00 00		 lea	 edx, DWORD PTR _neighbor$119837[esp+260]
  00217	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  0021c	85 c0		 test	 eax, eax
  0021e	75 80		 jne	 SHORT $LL23@ResolveHyp
$LN22@ResolveHyp:

; 1643 : 								}
; 1644 : 							}
; 1645 : 						}
; 1646 : 
; 1647 : 						// part two: now transfer the list to the destination:
; 1648 : 						for (int i = 0; i < riders.size(); i++) {

  00220	89 74 24 30	 mov	 DWORD PTR _i$119849[esp+260], esi
  00224	39 74 24 74	 cmp	 DWORD PTR _riders$119835[esp+260], esi
  00228	0f 8e 6c 01 00
	00		 jle	 $LN16@ResolveHyp
$LN18@ResolveHyp:

; 1649 : 							Ship* s = riders[i];

  0022e	8b 4c 24 30	 mov	 ecx, DWORD PTR _i$119849[esp+260]
  00232	51		 push	 ecx
  00233	8d 44 24 78	 lea	 eax, DWORD PTR _riders$119835[esp+264]
  00237	e8 00 00 00 00	 call	 ??A?$List@VShip@@@@QAEAAPAVShip@@H@Z ; List<Ship>::operator[]
  0023c	8b 30		 mov	 esi, DWORD PTR [eax]

; 1650 : 							Point delta = s->Location() - jumpship->Location();
; 1651 : 							dest->InsertObject(s);

  0023e	8b 4c 24 2c	 mov	 ecx, DWORD PTR _dest$119787[esp+260]
  00242	8b 11		 mov	 edx, DWORD PTR [ecx]
  00244	f2 0f 10 46 48	 movsd	 xmm0, QWORD PTR [esi+72]
  00249	f2 0f 10 4e 50	 movsd	 xmm1, QWORD PTR [esi+80]
  0024e	f2 0f 10 56 58	 movsd	 xmm2, QWORD PTR [esi+88]
  00253	f2 0f 5c 43 48	 subsd	 xmm0, QWORD PTR [ebx+72]
  00258	f2 0f 5c 4b 50	 subsd	 xmm1, QWORD PTR [ebx+80]
  0025d	f2 0f 5c 53 58	 subsd	 xmm2, QWORD PTR [ebx+88]
  00262	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00265	56		 push	 esi
  00266	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR $T397013[esp+264], xmm0
  0026f	f2 0f 11 8c 24
	a8 00 00 00	 movsd	 QWORD PTR $T397012[esp+264], xmm1
  00278	f2 0f 11 94 24
	98 00 00 00	 movsd	 QWORD PTR $T397011[esp+264], xmm2
  00281	ff d0		 call	 eax

; 1652 : 							s->MoveTo(jump->loc.OtherHand() + delta);

  00283	f2 0f 10 47 08	 movsd	 xmm0, QWORD PTR [edi+8]
  00288	8b 16		 mov	 edx, DWORD PTR [esi]
  0028a	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00292	f2 0f 10 4f 18	 movsd	 xmm1, QWORD PTR [edi+24]
  00297	f2 0f 10 94 24
	94 00 00 00	 movsd	 xmm2, QWORD PTR $T397011[esp+260]
  002a0	f2 0f 58 84 24
	9c 00 00 00	 addsd	 xmm0, QWORD PTR $T397013[esp+260]
  002a9	f2 0f 58 8c 24
	a4 00 00 00	 addsd	 xmm1, QWORD PTR $T397012[esp+260]
  002b2	f2 0f 58 57 10	 addsd	 xmm2, QWORD PTR [edi+16]
  002b7	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  002ba	8d 44 24 4c	 lea	 eax, DWORD PTR $T396857[esp+260]
  002be	50		 push	 eax
  002bf	8b ce		 mov	 ecx, esi
  002c1	f2 0f 11 44 24
	50		 movsd	 QWORD PTR $T396857[esp+264], xmm0
  002c7	f2 0f 11 4c 24
	58		 movsd	 QWORD PTR $T396857[esp+272], xmm1
  002cd	f2 0f 11 54 24
	60		 movsd	 QWORD PTR $T396857[esp+280], xmm2
  002d3	ff d2		 call	 edx

; 1653 : 							s->ClearTrack();

  002d5	e8 00 00 00 00	 call	 ?ClearTrack@Ship@@QAEXXZ ; Ship::ClearTrack

; 1654 : 
; 1655 : 							if (jump->fc_dst) {

  002da	83 7f 2c 00	 cmp	 DWORD PTR [edi+44], 0
  002de	0f 84 90 00 00
	00		 je	 $LN15@ResolveHyp

; 1656 : 								double r = jump->fc_dst->Roll();

  002e4	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  002e7	f3 0f 10 80 04
	01 00 00	 movss	 xmm0, DWORD PTR [eax+260]

; 1657 : 								double p = jump->fc_dst->Pitch();

  002ef	f3 0f 10 88 08
	01 00 00	 movss	 xmm1, DWORD PTR [eax+264]

; 1658 : 								double w = jump->fc_dst->Yaw();

  002f7	f3 0f 10 90 0c
	01 00 00	 movss	 xmm2, DWORD PTR [eax+268]

; 1659 : 
; 1660 : 								s->SetAbsoluteOrientation(r, p, w);

  002ff	8b 06		 mov	 eax, DWORD PTR [esi]
  00301	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  00304	83 ec 18	 sub	 esp, 24			; 00000018H
  00307	0f 5a d2	 cvtps2pd xmm2, xmm2
  0030a	f2 0f 11 54 24
	10		 movsd	 QWORD PTR [esp+16], xmm2
  00310	0f 5a c9	 cvtps2pd xmm1, xmm1
  00313	0f 5a c0	 cvtps2pd xmm0, xmm0
  00316	f2 0f 11 4c 24
	08		 movsd	 QWORD PTR [esp+8], xmm1
  0031c	8b ce		 mov	 ecx, esi
  0031e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00323	ff d2		 call	 edx

; 1661 : 								s->SetVelocity(jump->fc_dst->Heading() * 500);

  00325	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00328	f2 0f 10 80 a0
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+160]
  00330	f2 0f 10 88 98
	00 00 00	 movsd	 xmm1, QWORD PTR [eax+152]
  00338	f2 0f 10 90 90
	00 00 00	 movsd	 xmm2, QWORD PTR [eax+144]
  00340	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@407f400000000000
  00348	8b 06		 mov	 eax, DWORD PTR [esi]
  0034a	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  0034d	8d 4c 24 4c	 lea	 ecx, DWORD PTR $T396859[esp+260]
  00351	51		 push	 ecx
  00352	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  00356	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  0035a	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  0035e	8b ce		 mov	 ecx, esi
  00360	f2 0f 11 54 24
	50		 movsd	 QWORD PTR $T396859[esp+264], xmm2
  00366	f2 0f 11 4c 24
	58		 movsd	 QWORD PTR $T396859[esp+272], xmm1
  0036c	f2 0f 11 44 24
	60		 movsd	 QWORD PTR $T396859[esp+280], xmm0
  00372	ff d2		 call	 edx
$LN15@ResolveHyp:

; 1662 : 							}
; 1663 : 
; 1664 : 							ProcessEventTrigger(MissionEvent::TRIGGER_JUMP, 0, s->Name());

  00374	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00377	6a 00		 push	 0
  00379	83 c6 10	 add	 esi, 16			; 00000010H
  0037c	56		 push	 esi
  0037d	6a 00		 push	 0
  0037f	6a 03		 push	 3
  00381	50		 push	 eax
  00382	e8 00 00 00 00	 call	 ?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z ; Sim::ProcessEventTrigger
  00387	8b 44 24 30	 mov	 eax, DWORD PTR _i$119849[esp+260]
  0038b	40		 inc	 eax
  0038c	89 44 24 30	 mov	 DWORD PTR _i$119849[esp+260], eax
  00390	3b 44 24 74	 cmp	 eax, DWORD PTR _riders$119835[esp+260]
  00394	0f 8c 94 fe ff
	ff		 jl	 $LN18@ResolveHyp
$LN16@ResolveHyp:

; 1665 : 						}
; 1666 : 					}

  0039a	c7 84 24 00 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+268], -1
  003a5	8b 4c 24 7c	 mov	 ecx, DWORD PTR _riders$119835[esp+268]
  003a9	51		 push	 ecx
  003aa	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003af	83 c4 04	 add	 esp, 4
$LN136@ResolveHyp:

; 1667 : 
; 1668 : 					// now it is safe to move the main jump ship:
; 1669 : 					dest->InsertObject(jumpship);

  003b2	8b 4c 24 2c	 mov	 ecx, DWORD PTR _dest$119787[esp+260]
  003b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b8	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  003bb	53		 push	 ebx
  003bc	ff d0		 call	 eax

; 1670 : 					jumpship->MoveTo(jump->loc.OtherHand());

  003be	f2 0f 10 47 08	 movsd	 xmm0, QWORD PTR [edi+8]
  003c3	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __mask@@NegDouble@
  003cb	8b 13		 mov	 edx, DWORD PTR [ebx]
  003cd	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  003d0	66 0f 57 c1	 xorpd	 xmm0, xmm1
  003d4	f2 0f 11 44 24
	4c		 movsd	 QWORD PTR $T396860[esp+260], xmm0
  003da	f2 0f 10 47 18	 movsd	 xmm0, QWORD PTR [edi+24]
  003df	8d 44 24 4c	 lea	 eax, DWORD PTR $T396860[esp+260]
  003e3	f2 0f 11 44 24
	54		 movsd	 QWORD PTR $T396860[esp+268], xmm0
  003e9	f2 0f 10 47 10	 movsd	 xmm0, QWORD PTR [edi+16]
  003ee	50		 push	 eax
  003ef	8b cb		 mov	 ecx, ebx
  003f1	f2 0f 11 44 24
	60		 movsd	 QWORD PTR $T396860[esp+280], xmm0
  003f7	ff d2		 call	 edx

; 1671 : 					jumpship->ClearTrack();

  003f9	8b f3		 mov	 esi, ebx
  003fb	e8 00 00 00 00	 call	 ?ClearTrack@Ship@@QAEXXZ ; Ship::ClearTrack

; 1672 : 
; 1673 : 					ProcessEventTrigger(MissionEvent::TRIGGER_JUMP, 0, jumpship->Name());

  00400	6a 00		 push	 0
  00402	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00405	50		 push	 eax
  00406	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00409	6a 00		 push	 0
  0040b	6a 03		 push	 3
  0040d	50		 push	 eax
  0040e	e8 00 00 00 00	 call	 ?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z ; Sim::ProcessEventTrigger

; 1674 : 					NetUtil::SendObjHyper(jumpship, dest->Name(), jump->loc, jump->fc_src, jump->fc_dst, jump->type);

  00413	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  00416	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  00419	51		 push	 ecx
  0041a	52		 push	 edx
  0041b	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0041e	50		 push	 eax
  0041f	8b 44 24 38	 mov	 eax, DWORD PTR _dest$119787[esp+272]
  00423	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00426	51		 push	 ecx
  00427	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0042a	e8 00 00 00 00	 call	 ?SendObjHyper@NetUtil@@SAXPAVShip@@PBDABUPoint@@PBV2@3H@Z ; NetUtil::SendObjHyper
  0042f	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 : 
; 1676 : 					// if using farcaster:
; 1677 : 					if (jump->fc_src) {

  00432	83 7f 28 00	 cmp	 DWORD PTR [edi+40], 0
  00436	0f 84 1d 01 00
	00		 je	 $LN14@ResolveHyp

; 1678 : 						::Print("Ship '%s' farcast to '%s'\n", jumpship->Name(), dest->Name());

  0043c	8b 74 24 2c	 mov	 esi, DWORD PTR _dest$119787[esp+260]
  00440	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00443	52		 push	 edx
  00444	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00447	50		 push	 eax
  00448	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GPICPCGA@Ship?5?8?$CFs?8?5farcast?5to?5?8?$CFs?8?6?$AA@
  0044d	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 1679 : 						CreateExplosion(jumpship->Location(), Point(0,0,0), Explosion::QUANTUM_FLASH, 1.0f, 0, dest);

  00452	0f 57 c0	 xorps	 xmm0, xmm0
  00455	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00458	83 c4 0c	 add	 esp, 12			; 0000000cH
  0045b	f2 0f 11 44 24
	4c		 movsd	 QWORD PTR $T396861[esp+260], xmm0
  00461	f2 0f 11 44 24
	54		 movsd	 QWORD PTR $T396861[esp+268], xmm0
  00467	f2 0f 11 44 24
	5c		 movsd	 QWORD PTR $T396861[esp+276], xmm0
  0046d	f2 0f 10 43 48	 movsd	 xmm0, QWORD PTR [ebx+72]
  00472	f2 0f 11 44 24
	34		 movsd	 QWORD PTR $T396862[esp+260], xmm0
  00478	f2 0f 10 43 50	 movsd	 xmm0, QWORD PTR [ebx+80]
  0047d	6a 00		 push	 0
  0047f	f2 0f 11 44 24
	40		 movsd	 QWORD PTR $T396862[esp+272], xmm0
  00485	f2 0f 10 43 58	 movsd	 xmm0, QWORD PTR [ebx+88]
  0048a	56		 push	 esi
  0048b	83 ec 08	 sub	 esp, 8
  0048e	f2 0f 11 44 24
	54		 movsd	 QWORD PTR $T396862[esp+292], xmm0
  00494	0f 57 c0	 xorps	 xmm0, xmm0
  00497	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0049d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004aa	6a 0e		 push	 14			; 0000000eH
  004ac	50		 push	 eax
  004ad	8d 7c 24 64	 lea	 edi, DWORD PTR $T396861[esp+284]
  004b1	8d 4c 24 4c	 lea	 ecx, DWORD PTR $T396862[esp+284]
  004b5	e8 00 00 00 00	 call	 ?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z ; Sim::CreateExplosion

; 1680 : 
; 1681 : 						if (jump->fc_dst) {

  004ba	8b 74 24 70	 mov	 esi, DWORD PTR _jump$119784[esp+260]
  004be	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  004c2	0f 84 dc 02 00
	00		 je	 $LN13@ResolveHyp

; 1682 : 							double r = jump->fc_dst->Roll();
; 1683 : 							double p = jump->fc_dst->Pitch();
; 1684 : 							double w = jump->fc_dst->Yaw();

  004c8	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]

; 1685 : 
; 1686 : 							jumpship->SetAbsoluteOrientation(r, p, w);

  004cb	f3 0f 10 80 0c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+268]
  004d3	8b 13		 mov	 edx, DWORD PTR [ebx]
  004d5	0f 5a c0	 cvtps2pd xmm0, xmm0
  004d8	83 ec 18	 sub	 esp, 24			; 00000018H
  004db	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  004e1	f3 0f 10 80 08
	01 00 00	 movss	 xmm0, DWORD PTR [eax+264]
  004e9	0f 5a c0	 cvtps2pd xmm0, xmm0
  004ec	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  004f2	f3 0f 10 80 04
	01 00 00	 movss	 xmm0, DWORD PTR [eax+260]
  004fa	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  004fd	0f 5a c0	 cvtps2pd xmm0, xmm0
  00500	8b cb		 mov	 ecx, ebx
  00502	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00507	ff d0		 call	 eax

; 1687 : 							jumpship->SetVelocity(jump->fc_dst->Heading() * 500);

  00509	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0050c	f2 0f 10 80 90
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+144]
  00514	f2 0f 10 88 98
	00 00 00	 movsd	 xmm1, QWORD PTR [eax+152]
  0051c	f2 0f 10 90 a0
	00 00 00	 movsd	 xmm2, QWORD PTR [eax+160]
  00524	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@407f400000000000
  0052c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0052e	8b 52 6c	 mov	 edx, DWORD PTR [edx+108]
  00531	8d 44 24 34	 lea	 eax, DWORD PTR $T396864[esp+260]
  00535	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00539	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  0053d	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  00541	f2 0f 11 44 24
	34		 movsd	 QWORD PTR $T396864[esp+260], xmm0
  00547	f2 0f 11 4c 24
	3c		 movsd	 QWORD PTR $T396864[esp+268], xmm1
  0054d	f2 0f 11 54 24
	44		 movsd	 QWORD PTR $T396864[esp+276], xmm2
  00553	50		 push	 eax

; 1688 : 						}
; 1689 : 
; 1690 : 						jumpship->SetHelmHeading(jumpship->CompassHeading());
; 1691 : 						jumpship->SetHelmPitch(0);

  00554	e9 47 02 00 00	 jmp	 $LN291@ResolveHyp
$LN14@ResolveHyp:

; 1692 : 					}
; 1693 : 
; 1694 : 					// break orbit:
; 1695 : 					else if (jump->type == Ship::TRANSITION_DROP_ORBIT) {

  00559	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0055c	83 f8 02	 cmp	 eax, 2
  0055f	0f 85 8f 00 00
	00		 jne	 $LN11@ResolveHyp

; 1696 : 						::Print("Ship '%s' broke orbit to '%s'\n", jumpship->Name(), dest->Name());

  00565	8b 44 24 2c	 mov	 eax, DWORD PTR _dest$119787[esp+260]
  00569	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0056c	51		 push	 ecx
  0056d	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00570	50		 push	 eax
  00571	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@KPJAHLOO@Ship?5?8?$CFs?8?5broke?5orbit?5to?5?8?$CFs?8?6?$AA@
  00576	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 1697 : 						jumpship->SetAbsoluteOrientation(0,PI/4,0);

  0057b	0f 57 c0	 xorps	 xmm0, xmm0
  0057e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00580	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fe921fb54442d18
  00588	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0058b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0058e	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  00594	f2 0f 11 4c 24
	08		 movsd	 QWORD PTR [esp+8], xmm1
  0059a	8b cb		 mov	 ecx, ebx
  0059c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  005a1	ff d0		 call	 eax

; 1698 : 						jumpship->SetVelocity(jumpship->Heading() * 1.0e3);

  005a3	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@408f400000000000
  005ab	8b 13		 mov	 edx, DWORD PTR [ebx]
  005ad	f2 0f 10 83 90
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+144]
  005b5	f2 0f 10 8b 98
	00 00 00	 movsd	 xmm1, QWORD PTR [ebx+152]
  005bd	f2 0f 10 93 a0
	00 00 00	 movsd	 xmm2, QWORD PTR [ebx+160]
  005c5	8b 52 6c	 mov	 edx, DWORD PTR [edx+108]
  005c8	8d 44 24 34	 lea	 eax, DWORD PTR $T396866[esp+260]
  005cc	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  005d0	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  005d4	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  005d8	50		 push	 eax
  005d9	8b cb		 mov	 ecx, ebx
  005db	f2 0f 11 44 24
	38		 movsd	 QWORD PTR $T396866[esp+264], xmm0
  005e1	f2 0f 11 4c 24
	40		 movsd	 QWORD PTR $T396866[esp+272], xmm1
  005e7	f2 0f 11 54 24
	48		 movsd	 QWORD PTR $T396866[esp+280], xmm2
  005ed	ff d2		 call	 edx
  005ef	e9 f7 01 00 00	 jmp	 $LN4@ResolveHyp
$LN11@ResolveHyp:

; 1699 : 					}
; 1700 : 
; 1701 : 					// make orbit:
; 1702 : 					else if (jump->type == Ship::TRANSITION_MAKE_ORBIT) {

  005f4	83 f8 03	 cmp	 eax, 3
  005f7	0f 85 8d 00 00
	00		 jne	 $LN9@ResolveHyp

; 1703 : 						::Print("Ship '%s' achieved orbit '%s'\n", jumpship->Name(), dest->Name());

  005fd	8b 44 24 2c	 mov	 eax, DWORD PTR _dest$119787[esp+260]
  00601	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00604	51		 push	 ecx
  00605	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00608	50		 push	 eax
  00609	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EADKDGGP@Ship?5?8?$CFs?8?5achieved?5orbit?5?8?$CFs?8?6?$AA@
  0060e	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 1704 : 						jumpship->LookAt(Point(0,0,0));

  00613	0f 57 c0	 xorps	 xmm0, xmm0
  00616	8b 13		 mov	 edx, DWORD PTR [ebx]
  00618	8b 52 40	 mov	 edx, DWORD PTR [edx+64]
  0061b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0061e	8d 44 24 34	 lea	 eax, DWORD PTR $T396867[esp+260]
  00622	50		 push	 eax
  00623	8b cb		 mov	 ecx, ebx
  00625	f2 0f 11 44 24
	38		 movsd	 QWORD PTR $T396867[esp+264], xmm0
  0062b	f2 0f 11 44 24
	40		 movsd	 QWORD PTR $T396867[esp+272], xmm0
  00631	f2 0f 11 44 24
	48		 movsd	 QWORD PTR $T396867[esp+280], xmm0
  00637	ff d2		 call	 edx

; 1705 : 						jumpship->SetVelocity(jumpship->Heading() * 500.0);

  00639	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@407f400000000000
  00641	8b 03		 mov	 eax, DWORD PTR [ebx]
  00643	f2 0f 10 83 90
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+144]
  0064b	f2 0f 10 8b 98
	00 00 00	 movsd	 xmm1, QWORD PTR [ebx+152]
  00653	f2 0f 10 93 a0
	00 00 00	 movsd	 xmm2, QWORD PTR [ebx+160]
  0065b	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  0065e	8d 4c 24 34	 lea	 ecx, DWORD PTR $T396869[esp+260]
  00662	51		 push	 ecx
  00663	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00667	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  0066b	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  0066f	8b cb		 mov	 ecx, ebx
  00671	f2 0f 11 44 24
	38		 movsd	 QWORD PTR $T396869[esp+264], xmm0
  00677	f2 0f 11 4c 24
	40		 movsd	 QWORD PTR $T396869[esp+272], xmm1
  0067d	f2 0f 11 54 24
	48		 movsd	 QWORD PTR $T396869[esp+280], xmm2
  00683	ff d2		 call	 edx

; 1706 : 					}
; 1707 : 
; 1708 : 					// hyper jump:
; 1709 : 					else {

  00685	e9 61 01 00 00	 jmp	 $LN4@ResolveHyp
$LN9@ResolveHyp:

; 1710 : 						::Print("Ship '%s' quantum to '%s'\n", jumpship->Name(), dest->Name());

  0068a	8b 74 24 2c	 mov	 esi, DWORD PTR _dest$119787[esp+260]
  0068e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00691	50		 push	 eax
  00692	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00695	50		 push	 eax
  00696	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BLBMKKEF@Ship?5?8?$CFs?8?5quantum?5to?5?8?$CFs?8?6?$AA@
  0069b	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 1711 : 
; 1712 : 						if (jump->hyperdrive)
; 1713 : 						CreateExplosion(jumpship->Location(), Point(0,0,0), Explosion::HYPER_FLASH,   1, 1, dest);

  006a0	0f 57 c0	 xorps	 xmm0, xmm0
  006a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  006a6	f2 0f 11 44 24
	34		 movsd	 QWORD PTR $T396870[esp+260], xmm0
  006ac	f2 0f 11 44 24
	3c		 movsd	 QWORD PTR $T396870[esp+268], xmm0
  006b2	f2 0f 11 44 24
	44		 movsd	 QWORD PTR $T396870[esp+276], xmm0
  006b8	f2 0f 10 43 48	 movsd	 xmm0, QWORD PTR [ebx+72]
  006bd	6a 00		 push	 0
  006bf	f2 0f 11 44 24
	50		 movsd	 QWORD PTR $T396871[esp+264], xmm0
  006c5	f2 0f 10 43 50	 movsd	 xmm0, QWORD PTR [ebx+80]
  006ca	56		 push	 esi
  006cb	83 ec 08	 sub	 esp, 8
  006ce	80 7f 24 00	 cmp	 BYTE PTR [edi+36], 0
  006d2	f2 0f 11 44 24
	64		 movsd	 QWORD PTR $T396871[esp+284], xmm0
  006d8	f2 0f 10 43 58	 movsd	 xmm0, QWORD PTR [ebx+88]
  006dd	f2 0f 11 44 24
	6c		 movsd	 QWORD PTR $T396871[esp+292], xmm0
  006e3	8d 7c 24 44	 lea	 edi, DWORD PTR $T396870[esp+276]
  006e7	74 1b		 je	 SHORT $LN7@ResolveHyp
  006e9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006f1	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  006f4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  006fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006ff	6a 0f		 push	 15			; 0000000fH
  00701	51		 push	 ecx

; 1714 : 						else

  00702	eb 1c		 jmp	 SHORT $LN289@ResolveHyp
$LN7@ResolveHyp:

; 1715 : 						CreateExplosion(jumpship->Location(), Point(0,0,0), Explosion::QUANTUM_FLASH, 1, 0, dest);

  00704	0f 57 c0	 xorps	 xmm0, xmm0
  00707	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0070a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00710	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00718	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0071d	6a 0e		 push	 14			; 0000000eH
  0071f	52		 push	 edx
$LN289@ResolveHyp:
  00720	8d 4c 24 64	 lea	 ecx, DWORD PTR $T396873[esp+284]
  00724	e8 00 00 00 00	 call	 ?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z ; Sim::CreateExplosion

; 1716 : 
; 1717 : 						jumpship->LookAt(Point(0,0,0));

  00729	0f 57 c0	 xorps	 xmm0, xmm0
  0072c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0072e	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  00731	8d 4c 24 34	 lea	 ecx, DWORD PTR $T396874[esp+260]
  00735	51		 push	 ecx
  00736	8b cb		 mov	 ecx, ebx
  00738	f2 0f 11 44 24
	38		 movsd	 QWORD PTR $T396874[esp+264], xmm0
  0073e	f2 0f 11 44 24
	40		 movsd	 QWORD PTR $T396874[esp+272], xmm0
  00744	f2 0f 11 44 24
	48		 movsd	 QWORD PTR $T396874[esp+280], xmm0
  0074a	ff d2		 call	 edx

; 1718 : 						jumpship->SetVelocity(jumpship->Heading() * 500.0);

  0074c	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@407f400000000000
  00754	f2 0f 10 83 90
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+144]
  0075c	f2 0f 10 8b 98
	00 00 00	 movsd	 xmm1, QWORD PTR [ebx+152]
  00764	f2 0f 10 93 a0
	00 00 00	 movsd	 xmm2, QWORD PTR [ebx+160]
  0076c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0076e	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  00771	8d 8c 24 ac 00
	00 00		 lea	 ecx, DWORD PTR $T396876[esp+260]
  00778	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  0077c	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00780	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  00784	f2 0f 11 84 24
	ac 00 00 00	 movsd	 QWORD PTR $T396876[esp+260], xmm0
  0078d	f2 0f 11 8c 24
	b4 00 00 00	 movsd	 QWORD PTR $T396876[esp+268], xmm1
  00796	f2 0f 11 94 24
	bc 00 00 00	 movsd	 QWORD PTR $T396876[esp+276], xmm2
  0079f	51		 push	 ecx
$LN291@ResolveHyp:
  007a0	8b cb		 mov	 ecx, ebx
  007a2	ff d2		 call	 edx
$LN13@ResolveHyp:

; 1719 : 						jumpship->SetHelmHeading(jumpship->CompassHeading());

  007a4	8b c3		 mov	 eax, ebx
  007a6	e8 00 00 00 00	 call	 ?CompassHeading@Ship@@QBENXZ ; Ship::CompassHeading
  007ab	53		 push	 ebx
  007ac	e8 00 00 00 00	 call	 ?SetHelmHeading@Ship@@QAEXN@Z ; Ship::SetHelmHeading

; 1720 : 						jumpship->SetHelmPitch(0);

  007b1	0f 57 d2	 xorps	 xmm2, xmm2
  007b4	8b c3		 mov	 eax, ebx
  007b6	e8 00 00 00 00	 call	 ?SetHelmPitch@Ship@@QAEXN@Z ; Ship::SetHelmPitch

; 1721 : 					}

  007bb	eb 2e		 jmp	 SHORT $LN4@ResolveHyp
$LN31@ResolveHyp:

; 1722 : 				}
; 1723 : 
; 1724 : 				else if (regions.size() > 1) {

  007bd	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  007c0	83 7e 58 01	 cmp	 DWORD PTR [esi+88], 1
  007c4	7e 25		 jle	 SHORT $LN4@ResolveHyp

; 1725 : 					::Print("Warning: Unusual jump request for ship '%s'\n", jumpship->Name());

  007c6	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  007c9	50		 push	 eax
  007ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@DDGAJNGP@Warning?3?5Unusual?5jump?5request?5fo@
  007cf	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  007d4	83 c4 08	 add	 esp, 8

; 1726 : 					regions[1]->InsertObject(jumpship);

  007d7	6a 01		 push	 1
  007d9	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  007dc	e8 00 00 00 00	 call	 ??A?$List@VSimRegion@@@@QAEAAPAVSimRegion@@H@Z ; List<SimRegion>::operator[]
  007e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  007e3	8b 11		 mov	 edx, DWORD PTR [ecx]
  007e5	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  007e8	53		 push	 ebx
  007e9	ff d0		 call	 eax
$LN4@ResolveHyp:

; 1727 : 				}
; 1728 : 
; 1729 : 				Sensor* sensor = jumpship->GetSensor();

  007eb	8b 9b 50 03 00
	00		 mov	 ebx, DWORD PTR [ebx+848]

; 1730 : 				if (sensor)

  007f1	85 db		 test	 ebx, ebx
  007f3	74 09		 je	 SHORT $LN3@ResolveHyp

; 1731 : 				sensor->ClearAllContacts();

  007f5	8b 13		 mov	 edx, DWORD PTR [ebx]
  007f7	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  007fa	8b cb		 mov	 ecx, ebx
  007fc	ff d0		 call	 eax
$LN3@ResolveHyp:

; 1599 : 
; 1600 : 		ListIter<SimHyper> j_iter = jumplist;
; 1601 : 		while (++j_iter) {

  007fe	8d 94 24 80 00
	00 00		 lea	 edx, DWORD PTR _j_iter$119780[esp+260]
  00805	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimHyper@@@@QAEPAVSimHyper@@XZ ; ListIter<SimHyper>::next
  0080a	85 c0		 test	 eax, eax
  0080c	0f 85 6e f8 ff
	ff		 jne	 $LL35@ResolveHyp
  00812	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00815	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR _pship$119746[esp+260]
$LN34@ResolveHyp:

; 1732 : 			}
; 1733 : 		}
; 1734 : 
; 1735 : 		jumplist.destroy();

  0081c	8d 73 70	 lea	 esi, DWORD PTR [ebx+112]
  0081f	e8 00 00 00 00	 call	 ?destroy@?$List@VSimHyper@@@@QAEXXZ ; List<SimHyper>::destroy

; 1736 : 		
; 1737 : 		if (pship && pship->GetRegion()) {

  00824	85 ff		 test	 edi, edi
  00826	74 35		 je	 SHORT $LN1@ResolveHyp
  00828	8b 17		 mov	 edx, DWORD PTR [edi]
  0082a	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00830	8b cf		 mov	 ecx, edi
  00832	ff d0		 call	 eax
  00834	85 c0		 test	 eax, eax
  00836	74 25		 je	 SHORT $LN1@ResolveHyp

; 1738 : 			if (active_region != pship->GetRegion()) {

  00838	8b 17		 mov	 edx, DWORD PTR [edi]
  0083a	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00840	8b cf		 mov	 ecx, edi
  00842	ff d0		 call	 eax
  00844	39 43 04	 cmp	 DWORD PTR [ebx+4], eax
  00847	74 14		 je	 SHORT $LN1@ResolveHyp

; 1739 : 				pship->GetRegion()->SetPlayerShip(pship);

  00849	8b 17		 mov	 edx, DWORD PTR [edi]
  0084b	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00851	8b cf		 mov	 ecx, edi
  00853	ff d0		 call	 eax
  00855	50		 push	 eax
  00856	8b c7		 mov	 eax, edi
  00858	e8 00 00 00 00	 call	 ?SetPlayerShip@SimRegion@@QAEXPAVShip@@@Z ; SimRegion::SetPlayerShip
$LN1@ResolveHyp:

; 1740 : 			}
; 1741 : 		}
; 1742 : 	}
; 1743 : }

  0085d	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+260]
  00864	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0086b	59		 pop	 ecx
  0086c	5f		 pop	 edi
  0086d	5e		 pop	 esi
  0086e	5b		 pop	 ebx
  0086f	8b e5		 mov	 esp, ebp
  00871	5d		 pop	 ebp
  00872	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ResolveHyperList@Sim@@QAEXXZ$0:
  00000	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _riders$119835[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__ehhandler$?ResolveHyperList@Sim@@QAEXXZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 82 0c ff ff
	ff		 lea	 eax, DWORD PTR [edx-244]
  00015	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ResolveHyperList@Sim@@QAEXXZ
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ResolveHyperList@Sim@@QAEXXZ ENDP			; Sim::ResolveHyperList
PUBLIC	?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z	; Sim::CreateSplashDamage
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\geometry.h
xdata$x	SEGMENT
__unwindtable$?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z$0
__ehfuncinfo$?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z
_TEXT	SEGMENT
$T397498 = -92						; size = 24
$T397497 = -68						; size = 24
$T397494 = -68						; size = 24
$T397541 = -44						; size = 8
_damage$119439 = -36					; size = 8
$T397493 = -24						; size = 4
$T397542 = -20						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z PROC		; Sim::CreateSplashDamage, COMDAT
; _shot$ = ecx

; 1188 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx

; 1189 : 	if (shot && shot->GetRegion()) {

  0002a	85 f6		 test	 esi, esi
  0002c	0f 84 91 01 00
	00		 je	 $LN3@CreateSpla@2
  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  0003a	ff d2		 call	 edx
  0003c	85 c0		 test	 eax, eax
  0003e	0f 84 7f 01 00
	00		 je	 $LN3@CreateSpla@2

; 1190 : 		double damage = shot->Damage();

  00044	e8 00 00 00 00	 call	 ?Damage@Shot@@QBENXZ	; Shot::Damage

; 1191 : 		if (damage < shot->Design()->damage)

  00049	8b 86 20 02 00
	00		 mov	 eax, DWORD PTR [esi+544]
  0004f	f3 0f 10 88 60
	01 00 00	 movss	 xmm1, DWORD PTR [eax+352]
  00057	0f 5a c9	 cvtps2pd xmm1, xmm1
  0005a	66 0f 2f c8	 comisd	 xmm1, xmm0
  0005e	f2 0f 11 45 dc	 movsd	 QWORD PTR _damage$119439[ebp], xmm0
  00063	76 10		 jbe	 SHORT $LN2@CreateSpla@2

; 1192 : 		damage = shot->Design()->damage;

  00065	f3 0f 10 80 60
	01 00 00	 movss	 xmm0, DWORD PTR [eax+352]
  0006d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00070	f2 0f 11 45 dc	 movsd	 QWORD PTR _damage$119439[ebp], xmm0
$LN2@CreateSpla@2:

; 1193 : 
; 1194 : 		SimSplash* splash = new(__FILE__,__LINE__)
; 1195 : 		SimSplash(shot->GetRegion(),
; 1196 : 		shot->Location(),
; 1197 : 		damage,
; 1198 : 		shot->Design()->lethal_radius);

  00075	6a 38		 push	 56			; 00000038H
  00077	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007c	8b f8		 mov	 edi, eax
  0007e	83 c4 04	 add	 esp, 4
  00081	89 7d e8	 mov	 DWORD PTR $T397493[ebp], edi
  00084	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008b	85 ff		 test	 edi, edi
  0008d	0f 84 8d 00 00
	00		 je	 $LN6@CreateSpla@2
  00093	f2 0f 10 46 48	 movsd	 xmm0, QWORD PTR [esi+72]
  00098	8b 06		 mov	 eax, DWORD PTR [esi]
  0009a	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  000a0	8b 9e 20 02 00
	00		 mov	 ebx, DWORD PTR [esi+544]
  000a6	f2 0f 11 45 bc	 movsd	 QWORD PTR $T397494[ebp], xmm0
  000ab	f2 0f 10 46 50	 movsd	 xmm0, QWORD PTR [esi+80]
  000b0	f2 0f 11 45 c4	 movsd	 QWORD PTR $T397494[ebp+8], xmm0
  000b5	f2 0f 10 46 58	 movsd	 xmm0, QWORD PTR [esi+88]
  000ba	8b ce		 mov	 ecx, esi
  000bc	f2 0f 11 45 cc	 movsd	 QWORD PTR $T397494[ebp+16], xmm0
  000c1	ff d2		 call	 edx
  000c3	f3 0f 10 83 98
	01 00 00	 movss	 xmm0, DWORD PTR [ebx+408]
  000cb	0f 5a c0	 cvtps2pd xmm0, xmm0
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CAMCFAKE@Collateral?5Damage?$AA@
  000d3	8b cf		 mov	 ecx, edi
  000d5	89 45 ec	 mov	 DWORD PTR $T397542[ebp], eax
  000d8	f2 0f 11 45 d4	 movsd	 QWORD PTR $T397541[ebp], xmm0
  000dd	e8 00 00 00 00	 call	 ??0Text@@QAE@PBD@Z	; Text::Text
  000e2	f2 0f 10 45 bc	 movsd	 xmm0, QWORD PTR $T397494[ebp]
  000e7	8b 45 ec	 mov	 eax, DWORD PTR $T397542[ebp]
  000ea	f2 0f 11 47 08	 movsd	 QWORD PTR [edi+8], xmm0
  000ef	f2 0f 10 45 c4	 movsd	 xmm0, QWORD PTR $T397494[ebp+8]
  000f4	f2 0f 11 47 10	 movsd	 QWORD PTR [edi+16], xmm0
  000f9	f2 0f 10 45 cc	 movsd	 xmm0, QWORD PTR $T397494[ebp+16]
  000fe	f2 0f 11 47 18	 movsd	 QWORD PTR [edi+24], xmm0
  00103	f2 0f 10 45 dc	 movsd	 xmm0, QWORD PTR _damage$119439[ebp]
  00108	f2 0f 11 47 20	 movsd	 QWORD PTR [edi+32], xmm0
  0010d	f2 0f 10 45 d4	 movsd	 xmm0, QWORD PTR $T397541[ebp]
  00112	f2 0f 11 47 28	 movsd	 QWORD PTR [edi+40], xmm0
  00117	89 47 30	 mov	 DWORD PTR [edi+48], eax
  0011a	c6 47 34 00	 mov	 BYTE PTR [edi+52], 0
  0011e	eb 02		 jmp	 SHORT $LN7@CreateSpla@2
$LN6@CreateSpla@2:
  00120	33 ff		 xor	 edi, edi
$LN7@CreateSpla@2:
  00122	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 1199 : 
; 1200 : 		if (shot->Owner())

  00129	8b 86 f0 01 00
	00		 mov	 eax, DWORD PTR [esi+496]
  0012f	85 c0		 test	 eax, eax
  00131	74 0b		 je	 SHORT $LN1@CreateSpla@2

; 1201 : 		splash->owner_name = shot->Owner()->Name();

  00133	83 c0 10	 add	 eax, 16			; 00000010H
  00136	50		 push	 eax
  00137	8b cf		 mov	 ecx, edi
  00139	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=
$LN1@CreateSpla@2:

; 1202 : 
; 1203 : 		splash->missile = shot->IsMissile();

  0013e	8b 16		 mov	 edx, DWORD PTR [esi]
  00140	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  00146	8b ce		 mov	 ecx, esi
  00148	ff d0		 call	 eax

; 1204 : 
; 1205 : 		splashlist.append(splash);

  0014a	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0014d	88 47 34	 mov	 BYTE PTR [edi+52], al
  00150	8d 43 7c	 lea	 eax, DWORD PTR [ebx+124]
  00153	e8 00 00 00 00	 call	 ?append@?$List@VSimSplash@@@@QAEXPBVSimSplash@@@Z ; List<SimSplash>::append

; 1206 : 		CreateExplosion(shot->Location(), Point(), Explosion::SHOT_BLAST, 20.0f, 1.0f, shot->GetRegion());

  00158	0f 57 c0	 xorps	 xmm0, xmm0
  0015b	8b 16		 mov	 edx, DWORD PTR [esi]
  0015d	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00163	f2 0f 11 45 bc	 movsd	 QWORD PTR $T397497[ebp], xmm0
  00168	f2 0f 11 45 c4	 movsd	 QWORD PTR $T397497[ebp+8], xmm0
  0016d	f2 0f 11 45 cc	 movsd	 QWORD PTR $T397497[ebp+16], xmm0
  00172	f2 0f 10 46 48	 movsd	 xmm0, QWORD PTR [esi+72]
  00177	f2 0f 11 45 a4	 movsd	 QWORD PTR $T397498[ebp], xmm0
  0017c	f2 0f 10 46 50	 movsd	 xmm0, QWORD PTR [esi+80]
  00181	f2 0f 11 45 ac	 movsd	 QWORD PTR $T397498[ebp+8], xmm0
  00186	f2 0f 10 46 58	 movsd	 xmm0, QWORD PTR [esi+88]
  0018b	6a 00		 push	 0
  0018d	8b ce		 mov	 ecx, esi
  0018f	f2 0f 11 45 b4	 movsd	 QWORD PTR $T397498[ebp+16], xmm0
  00194	ff d0		 call	 eax
  00196	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0019e	50		 push	 eax
  0019f	83 ec 08	 sub	 esp, 8
  001a2	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41a00000
  001b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b5	6a 04		 push	 4
  001b7	53		 push	 ebx
  001b8	8d 7d bc	 lea	 edi, DWORD PTR $T397497[ebp]
  001bb	8d 4d a4	 lea	 ecx, DWORD PTR $T397498[ebp]
  001be	e8 00 00 00 00	 call	 ?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z ; Sim::CreateExplosion
$LN3@CreateSpla@2:

; 1207 : 	}
; 1208 : }

  001c3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001c6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001cd	59		 pop	 ecx
  001ce	5f		 pop	 edi
  001cf	5e		 pop	 esi
  001d0	5b		 pop	 ebx
  001d1	8b e5		 mov	 esp, ebp
  001d3	5d		 pop	 ebp
  001d4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z$0:
  00000	68 aa 04 00 00	 push	 1194			; 000004aaH
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 e8	 mov	 eax, DWORD PTR $T397493[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__ehhandler$?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z ENDP		; Sim::CreateSplashDamage
PUBLIC	?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z ; Sim::CreateShip
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\geometry.h
xdata$x	SEGMENT
__unwindtable$?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z$0
__ehfuncinfo$?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z
_TEXT	SEGMENT
$T397582 = -68						; size = 4
$T397585 = -64						; size = 24
$T397587 = -40						; size = 24
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_name$ = 12						; size = 4
_reg_num$ = 16						; size = 4
_rgn_name$ = 20						; size = 4
_loc$ = 24						; size = 4
_IFF$ = 28						; size = 4
_cmd_ai$ = 32						; size = 4
_loadout$ = 36						; size = 4
?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z PROC ; Sim::CreateShip, COMDAT
; _design$ = ecx

; 989  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 38	 sub	 esp, 56			; 00000038H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	50		 push	 eax
  00022	8d 44 24 48	 lea	 eax, DWORD PTR __$EHRec$[esp+84]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b f9		 mov	 edi, ecx
  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR _name$[ebp]

; 990  : 	if (!design) {

  00031	85 ff		 test	 edi, edi
  00033	75 25		 jne	 SHORT $LN4@CreateShip

; 991  : 		Print("WARNING: CreateShip(%s): invalid design\n", name);

  00035	53		 push	 ebx
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@BABHFBHK@WARNING?3?5CreateShip?$CI?$CFs?$CJ?3?5invalid@
  0003b	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00040	83 c4 08	 add	 esp, 8
$LN39@CreateShip:

; 992  : 		return 0;

  00043	33 c0		 xor	 eax, eax

; 1013 : }

  00045	8b 4c 24 48	 mov	 ecx, DWORD PTR __$EHRec$[esp+84]
  00049	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00050	59		 pop	 ecx
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 20 00	 ret	 32			; 00000020H
$LN4@CreateShip:

; 993  : 	}
; 994  : 
; 995  : 	SimRegion* rgn = FindRegion(rgn_name);

  0005a	8b 75 14	 mov	 esi, DWORD PTR _rgn_name$[ebp]
  0005d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?FindRegion@Sim@@QAEPAVSimRegion@@PBD@Z ; Sim::FindRegion
  00065	8b f0		 mov	 esi, eax

; 996  : 
; 997  : 	if (!rgn) {

  00067	85 f6		 test	 esi, esi

; 998  : 		return 0;

  00069	74 d8		 je	 SHORT $LN39@CreateShip

; 999  : 	}
; 1000 : 
; 1001 : 	Ship* ship = new(__FILE__,__LINE__) Ship(name, reg_num, design, IFF, cmd_ai, loadout);

  0006b	68 d0 04 00 00	 push	 1232			; 000004d0H
  00070	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00075	83 c4 04	 add	 esp, 4
  00078	89 44 24 10	 mov	 DWORD PTR $T397582[esp+84], eax
  0007c	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  00084	85 c0		 test	 eax, eax
  00086	74 1b		 je	 SHORT $LN7@CreateShip
  00088	8b 4d 24	 mov	 ecx, DWORD PTR _loadout$[ebp]
  0008b	8b 55 20	 mov	 edx, DWORD PTR _cmd_ai$[ebp]
  0008e	51		 push	 ecx
  0008f	8b 4d 1c	 mov	 ecx, DWORD PTR _IFF$[ebp]
  00092	52		 push	 edx
  00093	51		 push	 ecx
  00094	8b 4d 10	 mov	 ecx, DWORD PTR _reg_num$[ebp]
  00097	57		 push	 edi
  00098	53		 push	 ebx
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??0Ship@@QAE@PBD0PAVShipDesign@@HHPBH@Z ; Ship::Ship
  0009f	8b f8		 mov	 edi, eax
  000a1	eb 02		 jmp	 SHORT $LN8@CreateShip
$LN7@CreateShip:
  000a3	33 ff		 xor	 edi, edi
$LN8@CreateShip:

; 1002 : 	ship->MoveTo(loc.OtherHand());

  000a5	8b 45 18	 mov	 eax, DWORD PTR _loc$[ebp]
  000a8	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+92], -1
  000b0	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  000b4	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  000bc	8b 17		 mov	 edx, DWORD PTR [edi]
  000be	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  000c1	f2 0f 11 44 24
	14		 movsd	 QWORD PTR $T397585[esp+84], xmm0
  000c7	f2 0f 10 40 10	 movsd	 xmm0, QWORD PTR [eax+16]
  000cc	f2 0f 11 44 24
	1c		 movsd	 QWORD PTR $T397585[esp+92], xmm0
  000d2	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  000d7	8d 44 24 14	 lea	 eax, DWORD PTR $T397585[esp+84]
  000db	50		 push	 eax
  000dc	8b cf		 mov	 ecx, edi
  000de	f2 0f 11 44 24
	28		 movsd	 QWORD PTR $T397585[esp+104], xmm0
  000e4	ff d2		 call	 edx

; 1003 : 
; 1004 : 	if (rgn) {
; 1005 : 		Print("Inserting Ship(%s) into Region(%s) (%s)\n", ship->Name(), rgn->Name(), FormatGameTime());

  000e6	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  000e9	e8 00 00 00 00	 call	 ?FormatGameTime@@YAPBDXZ ; FormatGameTime
  000ee	50		 push	 eax
  000ef	53		 push	 ebx
  000f0	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  000f3	50		 push	 eax
  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@POPAIFMC@Inserting?5Ship?$CI?$CFs?$CJ?5into?5Region?$CI?$CF@
  000f9	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 1006 : 		rgn->InsertObject(ship);

  000fe	8b 16		 mov	 edx, DWORD PTR [esi]
  00100	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00103	83 c4 10	 add	 esp, 16			; 00000010H
  00106	57		 push	 edi
  00107	8b ce		 mov	 ecx, esi
  00109	ff d0		 call	 eax

; 1007 : 
; 1008 : 		if (ship->IsAirborne() && ship->AltitudeAGL() > 25)

  0010b	8b c7		 mov	 eax, edi
  0010d	e8 00 00 00 00	 call	 ?IsAirborne@Ship@@QBE_NXZ ; Ship::IsAirborne
  00112	84 c0		 test	 al, al
  00114	74 5b		 je	 SHORT $LN1@CreateShip
  00116	e8 00 00 00 00	 call	 ?AltitudeAGL@Ship@@QBENXZ ; Ship::AltitudeAGL
  0011b	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4039000000000000
  00123	76 4c		 jbe	 SHORT $LN1@CreateShip

; 1009 : 		ship->SetVelocity(ship->Heading() * 250);

  00125	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@406f400000000000
  0012d	8b 17		 mov	 edx, DWORD PTR [edi]
  0012f	f2 0f 10 87 90
	00 00 00	 movsd	 xmm0, QWORD PTR [edi+144]
  00137	f2 0f 10 8f 98
	00 00 00	 movsd	 xmm1, QWORD PTR [edi+152]
  0013f	f2 0f 10 97 a0
	00 00 00	 movsd	 xmm2, QWORD PTR [edi+160]
  00147	8b 52 6c	 mov	 edx, DWORD PTR [edx+108]
  0014a	8d 44 24 2c	 lea	 eax, DWORD PTR $T397587[esp+84]
  0014e	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00152	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00156	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  0015a	50		 push	 eax
  0015b	8b cf		 mov	 ecx, edi
  0015d	f2 0f 11 44 24
	30		 movsd	 QWORD PTR $T397587[esp+88], xmm0
  00163	f2 0f 11 4c 24
	38		 movsd	 QWORD PTR $T397587[esp+96], xmm1
  00169	f2 0f 11 54 24
	40		 movsd	 QWORD PTR $T397587[esp+104], xmm2
  0016f	ff d2		 call	 edx
$LN1@CreateShip:

; 1010 : 	}
; 1011 : 
; 1012 : 	return ship;

  00171	8b c7		 mov	 eax, edi

; 1013 : }

  00173	8b 4c 24 48	 mov	 ecx, DWORD PTR __$EHRec$[esp+84]
  00177	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017e	59		 pop	 ecx
  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z$0:
  00000	68 e9 03 00 00	 push	 1001			; 000003e9H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 bc	 mov	 eax, DWORD PTR $T397582[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__ehhandler$?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 bc	 lea	 eax, DWORD PTR [edx-68]
  0001e	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z ENDP ; Sim::CreateShip
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CreateElements@Sim@@IAEXXZ			; Sim::CreateElements
;	COMDAT xdata$x
; File c:\matrix games\dev\stars45\mission.h
xdata$x	SEGMENT
__unwindtable$?CreateElements@Sim@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateElements@Sim@@IAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateElements@Sim@@IAEXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateElements@Sim@@IAEXXZ$8
	DD	02H
	DD	FLAT:__unwindfunclet$?CreateElements@Sim@@IAEXXZ$9
	DD	03H
	DD	FLAT:__unwindfunclet$?CreateElements@Sim@@IAEXXZ$10
__ehfuncinfo$?CreateElements@Sim@@IAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?CreateElements@Sim@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CreateElements@Sim@@IAEXXZ
_TEXT	SEGMENT
_msn_ship$118914 = -404					; size = 4
_slot$118899 = -404					; size = 4
_carrier$118770 = -404					; size = 4
_carrier$118713 = -404					; size = 4
_alertPrep$118863 = -397				; size = 1
_i$118910 = -396					; size = 4
_squadron$118898 = -396					; size = 4
_i$118871 = -396					; size = 4
$T397700 = -389						; size = 1
$T397694 = -389						; size = 1
tv2675 = -388						; size = 4
tv2640 = -388						; size = 4
_deck$118867 = -388					; size = 4
_m$118719 = -388					; size = 4
_this$GSCopy$ = -384					; size = 4
_element$118774 = -380					; size = 4
_sl$118762 = -380					; size = 4
_hangar$118771 = -376					; size = 4
_loadout$118864 = -372					; size = 4
$T398096 = -368						; size = 4
_respawns$118865 = -368					; size = 4
$T397684 = -368						; size = 4
_hangar$118715 = -368					; size = 4
tv2073 = -364						; size = 4
_dsn$118869 = -364					; size = 4
$T397688 = -364						; size = 4
$T397680 = -364						; size = 4
_nav$118847 = -360					; size = 8
_l$118962 = -352					; size = 8
_queue$118868 = -344					; size = 4
$T397689 = -344						; size = 4
_sl$118885 = -340					; size = 8
_sl$118972 = -332					; size = 8
_squadron$118772 = -324					; size = 4
$T397706 = -320						; size = 24
$T397705 = -320						; size = 24
$T397702 = -320						; size = 24
_offset$118926 = -320					; size = 24
_sl_iter$118758 = -296					; size = 8
_e_iter$ = -288						; size = 8
_iter$119066 = -280					; size = 8
_sname$118915 = -272					; size = 8
_obj$118828 = -264					; size = 8
_instr$118842 = -256					; size = 8
_heading$118984 = -248					; size = 8
_rnum$118917 = -236					; size = 8
_slot$118773 = -228					; size = 4
_rgn_name$118919 = -224					; size = 8
_l2$118921 = -216					; size = 24
$T397677 = -192						; size = 8
$T397701 = -184						; size = 8
$T397693 = -176						; size = 8
$T397679 = -168						; size = 8
$T397699 = -160						; size = 8
$T397682 = -152						; size = 8
$T397695 = -144						; size = 8
_design$119076 = -136					; size = 64
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?CreateElements@Sim@@IAEXXZ PROC			; Sim::CreateElements, COMDAT

; 483  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?CreateElements@Sim@@IAEXXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	89 84 24 70 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+436], eax
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c4		 xor	 eax, esp
  00032	50		 push	 eax
  00033	8d 84 24 b8 01
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+452]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]

; 893  : 							}
; 894  : 						}
; 895  : 					}  // ship
; 896  : 				}     // count

  00043	89 44 24 44	 mov	 DWORD PTR _this$GSCopy$[esp+452], eax
  00047	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [eax+192]
  0004d	05 ec 00 00 00	 add	 eax, 236		; 000000ecH
  00052	8d 94 24 a4 00
	00 00		 lea	 edx, DWORD PTR _e_iter$[esp+452]
  00059	89 84 24 a4 00
	00 00		 mov	 DWORD PTR _e_iter$[esp+452], eax
  00060	c7 84 24 a8 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR _e_iter$[esp+456], -1
  0006b	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionElement@@@@QAEPAVMissionElement@@XZ ; ListIter<MissionElement>::next
  00070	85 c0		 test	 eax, eax
  00072	0f 84 f0 10 00
	00		 je	 $LN111@CreateElem@2
  00078	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL634@CreateElem@2:

; 484  : 	ListIter<MissionElement> e_iter = mission->GetElements();
; 485  : 	while (++e_iter) {

  00080	8b 7c 24 44	 mov	 edi, DWORD PTR _this$GSCopy$[esp+452]

; 486  : 		MissionElement* msn_elem = e_iter.value();

  00084	8d 84 24 a4 00
	00 00		 lea	 eax, DWORD PTR _e_iter$[esp+452]
  0008b	33 f6		 xor	 esi, esi
  0008d	e8 00 00 00 00	 call	 ?value@?$ListIter@VMissionElement@@@@QAEPAVMissionElement@@XZ ; ListIter<MissionElement>::value
  00092	8b d8		 mov	 ebx, eax

; 487  : 
; 488  : 		// add element to a carrier?
; 489  : 		if (msn_elem->IsSquadron()) {

  00094	e8 00 00 00 00	 call	 ?IsSquadron@MissionElement@@QBE_NXZ ; MissionElement::IsSquadron
  00099	84 c0		 test	 al, al
  0009b	0f 84 d1 01 00
	00		 je	 $LN110@CreateElem@2

; 490  : 			Ship* carrier = FindShip(msn_elem->Carrier());

  000a1	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000a4	50		 push	 eax
  000a5	57		 push	 edi
  000a6	33 c0		 xor	 eax, eax
  000a8	e8 00 00 00 00	 call	 ?FindShip@Sim@@QAEPAVShip@@PBD0@Z ; Sim::FindShip
  000ad	89 44 24 30	 mov	 DWORD PTR _carrier$118713[esp+452], eax

; 491  : 			if (carrier) {

  000b1	3b c6		 cmp	 eax, esi
  000b3	0f 84 9b 10 00
	00		 je	 $LN54@CreateElem@2

; 492  : 				Hangar* hangar = carrier->GetHangar();

  000b9	8b c8		 mov	 ecx, eax
  000bb	8b 81 68 03 00
	00		 mov	 eax, DWORD PTR [ecx+872]
  000c1	89 44 24 54	 mov	 DWORD PTR _hangar$118715[esp+452], eax

; 493  : 
; 494  : 				if (hangar) {

  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 87 10 00
	00		 je	 $LN54@CreateElem@2

; 495  : 					int* def_load = 0;

  000cd	33 ff		 xor	 edi, edi

; 496  : 
; 497  : 					if (msn_elem->Loadouts().size()) {

  000cf	39 bb f4 00 00
	00		 cmp	 DWORD PTR [ebx+244], edi
  000d5	8d 83 f4 00 00
	00		 lea	 eax, DWORD PTR [ebx+244]
  000db	0f 84 07 01 00
	00		 je	 $LN102@CreateElem@2

; 498  : 						MissionLoad* m = msn_elem->Loadouts().at(0);

  000e1	e8 00 00 00 00	 call	 ?at@?$List@VMissionLoad@@@@QAEAAPAVMissionLoad@@H@Z ; List<MissionLoad>::at
  000e6	8b 00		 mov	 eax, DWORD PTR [eax]

; 499  : 
; 500  : 						if (m->GetName().length()) {

  000e8	8d b4 24 04 01
	00 00		 lea	 esi, DWORD PTR $T397677[esp+452]
  000ef	89 44 24 40	 mov	 DWORD PTR _m$118719[esp+452], eax
  000f3	e8 00 00 00 00	 call	 ?GetName@MissionLoad@@QBE?AVText@@XZ ; MissionLoad::GetName
  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  000fe	8d 8c 24 04 01
	00 00		 lea	 ecx, DWORD PTR $T397677[esp+452]
  00105	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  0010a	85 f6		 test	 esi, esi
  0010c	0f 84 cb 00 00
	00		 je	 $LN627@CreateElem@2

; 501  : 							ShipDesign* dsn = (ShipDesign*) msn_elem->GetDesign();

  00112	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]

; 502  : 							ListIter<ShipLoad> sl_iter = dsn->loadouts;

  00115	05 f8 07 00 00	 add	 eax, 2040		; 000007f8H

; 503  : 							while (++sl_iter) {

  0011a	8d 94 24 9c 00
	00 00		 lea	 edx, DWORD PTR _sl_iter$118758[esp+452]
  00121	89 84 24 9c 00
	00 00		 mov	 DWORD PTR _sl_iter$118758[esp+452], eax
  00128	c7 84 24 a0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR _sl_iter$118758[esp+456], -1
  00133	e8 00 00 00 00	 call	 ?next@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::next
  00138	85 c0		 test	 eax, eax
  0013a	0f 84 9d 00 00
	00		 je	 $LN627@CreateElem@2
$LL105@CreateElem@2:

; 504  : 								ShipLoad* sl = sl_iter.value();

  00140	8d 84 24 9c 00
	00 00		 lea	 eax, DWORD PTR _sl_iter$118758[esp+452]
  00147	e8 00 00 00 00	 call	 ?value@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::value
  0014c	89 44 24 48	 mov	 DWORD PTR _sl$118762[esp+452], eax

; 505  : 
; 506  : 								if (m->GetName() == sl->name)

  00150	8b 44 24 40	 mov	 eax, DWORD PTR _m$118719[esp+452]
  00154	8d b4 24 1c 01
	00 00		 lea	 esi, DWORD PTR $T397679[esp+452]
  0015b	e8 00 00 00 00	 call	 ?GetName@MissionLoad@@QBE?AVText@@XZ ; MissionLoad::GetName
  00160	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00163	80 79 10 00	 cmp	 BYTE PTR [ecx+16], 0
  00167	8b 00		 mov	 eax, DWORD PTR [eax]
  00169	74 2c		 je	 SHORT $LN163@CreateElem@2
  0016b	8b 74 24 48	 mov	 esi, DWORD PTR _sl$118762[esp+452]
  0016f	90		 npad	 1
$LL629@CreateElem@2:
  00170	8a 08		 mov	 cl, BYTE PTR [eax]
  00172	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00174	75 1a		 jne	 SHORT $LN630@CreateElem@2
  00176	84 c9		 test	 cl, cl
  00178	74 12		 je	 SHORT $LN631@CreateElem@2
  0017a	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0017d	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00180	75 0e		 jne	 SHORT $LN630@CreateElem@2
  00182	83 c0 02	 add	 eax, 2
  00185	83 c6 02	 add	 esi, 2
  00188	84 c9		 test	 cl, cl
  0018a	75 e4		 jne	 SHORT $LL629@CreateElem@2
$LN631@CreateElem@2:
  0018c	33 c0		 xor	 eax, eax
  0018e	eb 15		 jmp	 SHORT $LN162@CreateElem@2
$LN630@CreateElem@2:
  00190	1b c0		 sbb	 eax, eax
  00192	83 d8 ff	 sbb	 eax, -1
  00195	eb 0e		 jmp	 SHORT $LN162@CreateElem@2
$LN163@CreateElem@2:
  00197	8b 54 24 48	 mov	 edx, DWORD PTR _sl$118762[esp+452]
  0019b	52		 push	 edx
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 __stricmp
  001a2	83 c4 08	 add	 esp, 8
$LN162@CreateElem@2:
  001a5	33 c9		 xor	 ecx, ecx
  001a7	85 c0		 test	 eax, eax
  001a9	0f 94 c1	 sete	 cl
  001ac	8b f1		 mov	 esi, ecx
  001ae	8d 8c 24 1c 01
	00 00		 lea	 ecx, DWORD PTR $T397679[esp+452]
  001b5	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  001ba	85 f6		 test	 esi, esi
  001bc	74 07		 je	 SHORT $LN103@CreateElem@2

; 507  : 								def_load = sl->load;

  001be	8b 7c 24 48	 mov	 edi, DWORD PTR _sl$118762[esp+452]
  001c2	83 c7 40	 add	 edi, 64			; 00000040H
$LN103@CreateElem@2:

; 503  : 							while (++sl_iter) {

  001c5	8d 94 24 9c 00
	00 00		 lea	 edx, DWORD PTR _sl_iter$118758[esp+452]
  001cc	e8 00 00 00 00	 call	 ?next@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::next
  001d1	85 c0		 test	 eax, eax
  001d3	0f 85 67 ff ff
	ff		 jne	 $LL105@CreateElem@2

; 508  : 							}
; 509  : 						}
; 510  : 
; 511  : 						if (!def_load) {

  001d9	85 ff		 test	 edi, edi
  001db	75 0b		 jne	 SHORT $LN102@CreateElem@2
$LN627@CreateElem@2:

; 512  : 							def_load = m->GetStations();

  001dd	8b 44 24 40	 mov	 eax, DWORD PTR _m$118719[esp+452]
  001e1	e8 00 00 00 00	 call	 ?GetStations@MissionLoad@@QAEPAHXZ ; MissionLoad::GetStations
  001e6	8b f8		 mov	 edi, eax
$LN102@CreateElem@2:

; 513  : 						}
; 514  : 					}
; 515  : 
; 516  : 					hangar->CreateSquadron(msn_elem->Name(), msn_elem->GetCombatGroup(),
; 517  : 					msn_elem->GetDesign(), msn_elem->Count(),
; 518  : 					msn_elem->GetIFF(),
; 519  : 					def_load, msn_elem->MaintCount(), msn_elem->DeadCount());

  001e8	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  001eb	50		 push	 eax
  001ec	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  001ef	50		 push	 eax
  001f0	8b 43 44	 mov	 eax, DWORD PTR [ebx+68]
  001f3	57		 push	 edi
  001f4	50		 push	 eax
  001f5	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  001f8	50		 push	 eax
  001f9	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  001fc	50		 push	 eax
  001fd	8b 83 c8 00 00
	00		 mov	 eax, DWORD PTR [ebx+200]
  00203	50		 push	 eax
  00204	83 ec 08	 sub	 esp, 8
  00207	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  0020a	8b cc		 mov	 ecx, esp
  0020c	89 64 24 7c	 mov	 DWORD PTR $T397680[esp+488], esp
  00210	56		 push	 esi
  00211	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  00216	8b 4c 24 78	 mov	 ecx, DWORD PTR _hangar$118715[esp+488]
  0021a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0021c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0021f	ff d0		 call	 eax

; 520  : 
; 521  : 					Element* element = CreateElement(msn_elem->Name(),
; 522  : 					msn_elem->GetIFF(),
; 523  : 					msn_elem->MissionRole());

  00221	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00224	8b 4b 44	 mov	 ecx, DWORD PTR [ebx+68]
  00227	8b 36		 mov	 esi, DWORD PTR [esi]
  00229	50		 push	 eax
  0022a	51		 push	 ecx
  0022b	8b 4c 24 4c	 mov	 ecx, DWORD PTR _this$GSCopy$[esp+460]
  0022f	56		 push	 esi
  00230	51		 push	 ecx
  00231	e8 00 00 00 00	 call	 ?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z ; Sim::CreateElement

; 524  : 
; 525  : 					element->SetCarrier(carrier);

  00236	8b 54 24 30	 mov	 edx, DWORD PTR _carrier$118713[esp+452]
  0023a	8b c8		 mov	 ecx, eax
  0023c	89 51 7c	 mov	 DWORD PTR [ecx+124], edx

; 526  : 					element->SetCombatGroup(msn_elem->GetCombatGroup());

  0023f	8b 83 c8 00 00
	00		 mov	 eax, DWORD PTR [ebx+200]
  00245	89 81 88 00 00
	00		 mov	 DWORD PTR [ecx+136], eax

; 527  : 					element->SetCombatUnit(msn_elem->GetCombatUnit());

  0024b	8b 93 cc 00 00
	00		 mov	 edx, DWORD PTR [ebx+204]
  00251	89 91 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], edx

; 528  : 					element->SetCount(msn_elem->Count());

  00257	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  0025a	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 529  : 					element->SetRogue(false);
; 530  : 					element->SetPlayable(false);
; 531  : 					element->SetLoadout(def_load);

  0025d	8b c7		 mov	 eax, edi
  0025f	66 c7 81 a0 00
	00 00 00 00	 mov	 WORD PTR [ecx+160], 0
  00268	e8 00 00 00 00	 call	 ?SetLoadout@Element@@QAEXPAH@Z ; Element::SetLoadout

; 532  : 				}
; 533  : 			}
; 534  : 		}
; 535  : 
; 536  : 		// create the element in space:
; 537  : 		else {

  0026d	e9 e2 0e 00 00	 jmp	 $LN54@CreateElem@2
$LN110@CreateElem@2:

; 538  : 			Ship*       carrier  = 0;
; 539  : 			Hangar*     hangar   = 0;
; 540  : 			int         squadron = -1;
; 541  : 			int         slot     = 0;
; 542  : 
; 543  : 			// first create the package element:
; 544  : 			Element* element = CreateElement(msn_elem->Name(),
; 545  : 			msn_elem->GetIFF(),
; 546  : 			msn_elem->MissionRole());

  00272	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00275	8b 4b 44	 mov	 ecx, DWORD PTR [ebx+68]
  00278	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0027b	50		 push	 eax
  0027c	51		 push	 ecx
  0027d	52		 push	 edx
  0027e	57		 push	 edi
  0027f	89 74 24 40	 mov	 DWORD PTR _carrier$118770[esp+468], esi
  00283	89 74 24 5c	 mov	 DWORD PTR _hangar$118771[esp+468], esi
  00287	c7 84 24 90 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR _squadron$118772[esp+468], -1
  00292	89 b4 24 f0 00
	00 00		 mov	 DWORD PTR _slot$118773[esp+468], esi
  00299	e8 00 00 00 00	 call	 ?CreateElement@Sim@@QAEPAVElement@@PBDHH@Z ; Sim::CreateElement
  0029e	8b f8		 mov	 edi, eax

; 547  : 
; 548  : 			element->SetPlayer(msn_elem->Player());

  002a0	8b 43 5c	 mov	 eax, DWORD PTR [ebx+92]
  002a3	89 47 1c	 mov	 DWORD PTR [edi+28], eax

; 549  : 			element->SetCombatGroup(msn_elem->GetCombatGroup());

  002a6	8b 83 c8 00 00
	00		 mov	 eax, DWORD PTR [ebx+200]
  002ac	89 87 88 00 00
	00		 mov	 DWORD PTR [edi+136], eax

; 550  : 			element->SetCombatUnit(msn_elem->GetCombatUnit());

  002b2	8b 83 cc 00 00
	00		 mov	 eax, DWORD PTR [ebx+204]
  002b8	89 87 8c 00 00
	00		 mov	 DWORD PTR [edi+140], eax

; 551  : 			element->SetCommandAILevel(msn_elem->CommandAI());

  002be	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  002c1	89 47 20	 mov	 DWORD PTR [edi+32], eax

; 552  : 			element->SetHoldTime(msn_elem->HoldTime());

  002c4	66 0f 6e 43 54	 movd	 xmm0, DWORD PTR [ebx+84]
  002c9	8b c7		 mov	 eax, edi
  002cb	89 7c 24 48	 mov	 DWORD PTR _element$118774[esp+452], edi
  002cf	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  002d3	e8 00 00 00 00	 call	 ?SetHoldTime@Element@@QAEXN@Z ; Element::SetHoldTime

; 553  : 			element->SetZoneLock(msn_elem->ZoneLock() ? true : false);

  002d8	39 73 58	 cmp	 DWORD PTR [ebx+88], esi
  002db	0f 95 c1	 setne	 cl
  002de	e8 00 00 00 00	 call	 ?SetZoneLock@Element@@QAEX_N@Z ; Element::SetZoneLock

; 554  : 			element->SetRogue(msn_elem->IsRogue());

  002e3	8a 43 66	 mov	 al, BYTE PTR [ebx+102]
  002e6	88 87 a0 00 00
	00		 mov	 BYTE PTR [edi+160], al

; 555  : 			element->SetPlayable(msn_elem->IsPlayable());

  002ec	8a 43 65	 mov	 al, BYTE PTR [ebx+101]
  002ef	88 87 a1 00 00
	00		 mov	 BYTE PTR [edi+161], al

; 556  : 			element->SetIntelLevel(msn_elem->IntelLevel());

  002f5	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  002f8	89 47 28	 mov	 DWORD PTR [edi+40], eax

; 557  : 
; 558  : 			// if this is the player's element, make sure to activate the region:
; 559  : 			if (msn_elem->Player()) {

  002fb	39 73 5c	 cmp	 DWORD PTR [ebx+92], esi
  002fe	74 21		 je	 SHORT $LN99@CreateElem@2

; 560  : 				SimRegion* rgn = FindRegion(msn_elem->Region());

  00300	8b 73 68	 mov	 esi, DWORD PTR [ebx+104]
  00303	8b 44 24 44	 mov	 eax, DWORD PTR _this$GSCopy$[esp+452]
  00307	e8 00 00 00 00	 call	 ?FindRegion@Sim@@QAEPAVSimRegion@@PBD@Z ; Sim::FindRegion

; 561  : 
; 562  : 				if (rgn && rgn != active_region)

  0030c	85 c0		 test	 eax, eax
  0030e	74 11		 je	 SHORT $LN99@CreateElem@2
  00310	8b 4c 24 44	 mov	 ecx, DWORD PTR _this$GSCopy$[esp+452]
  00314	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00317	74 08		 je	 SHORT $LN99@CreateElem@2

; 563  : 				ActivateRegion(rgn);

  00319	50		 push	 eax
  0031a	8b f1		 mov	 esi, ecx
  0031c	e8 00 00 00 00	 call	 ?ActivateRegion@Sim@@QAE_NPAVSimRegion@@@Z ; Sim::ActivateRegion
$LN99@CreateElem@2:

; 564  : 			}
; 565  : 
; 566  : 			// if element belongs to a squadron, 
; 567  : 			// find the carrier, squadron, flight deck, etc.:
; 568  : 			if (msn_elem->Squadron().length() > 0) {

  00321	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  00324	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00328	0f 8e cf 00 00
	00		 jle	 $LN98@CreateElem@2

; 569  : 				MissionElement* squadron_elem = mission->FindElement(msn_elem->Squadron());

  0032e	8b 4c 24 44	 mov	 ecx, DWORD PTR _this$GSCopy$[esp+452]
  00332	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00335	8b 89 c0 00 00
	00		 mov	 ecx, DWORD PTR [ecx+192]
  0033b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0033d	50		 push	 eax
  0033e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00341	ff d0		 call	 eax
  00343	8b f0		 mov	 esi, eax

; 570  : 
; 571  : 				if (squadron_elem) {

  00345	85 f6		 test	 esi, esi
  00347	0f 84 cd 00 00
	00		 je	 $LN296@CreateElem@2

; 572  : 					element->SetSquadron(msn_elem->Squadron());

  0034d	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00350	50		 push	 eax
  00351	8d 8f 80 00 00
	00		 lea	 ecx, DWORD PTR [edi+128]
  00357	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=

; 573  : 
; 574  : 					Element* cmdr  = FindElement(squadron_elem->Carrier());

  0035c	8b 4c 24 44	 mov	 ecx, DWORD PTR _this$GSCopy$[esp+452]
  00360	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]
  00363	51		 push	 ecx
  00364	e8 00 00 00 00	 call	 ?FindElement@Sim@@QAEPAVElement@@PBD@Z ; Sim::FindElement

; 575  : 
; 576  : 					if (cmdr) {

  00369	85 c0		 test	 eax, eax
  0036b	0f 84 a9 00 00
	00		 je	 $LN296@CreateElem@2

; 577  : 						element->SetCommander(cmdr);
; 578  : 						carrier = cmdr->GetShip(1);

  00371	b9 01 00 00 00	 mov	 ecx, 1
  00376	89 47 74	 mov	 DWORD PTR [edi+116], eax
  00379	e8 00 00 00 00	 call	 ?GetShip@Element@@QAEPAVShip@@H@Z ; Element::GetShip
  0037e	89 44 24 30	 mov	 DWORD PTR _carrier$118770[esp+452], eax

; 579  : 
; 580  : 						if (carrier) {

  00382	85 c0		 test	 eax, eax
  00384	0f 84 90 00 00
	00		 je	 $LN296@CreateElem@2

; 581  : 							element->SetCarrier(carrier);

  0038a	89 47 7c	 mov	 DWORD PTR [edi+124], eax

; 582  : 							hangar = carrier->GetHangar();

  0038d	8b 80 68 03 00
	00		 mov	 eax, DWORD PTR [eax+872]

; 583  : 
; 584  : 							for (int s = 0; s < hangar->NumSquadrons(); s++) {

  00393	33 ff		 xor	 edi, edi
  00395	89 44 24 4c	 mov	 DWORD PTR _hangar$118771[esp+452], eax
  00399	39 78 14	 cmp	 DWORD PTR [eax+20], edi
  0039c	0f 8e 78 00 00
	00		 jle	 $LN296@CreateElem@2
$LL94@CreateElem@2:

; 585  : 								if (hangar->SquadronName(s) == msn_elem->Squadron()) {

  003a2	8b 4c 24 4c	 mov	 ecx, DWORD PTR _hangar$118771[esp+452]
  003a6	8b c7		 mov	 eax, edi
  003a8	8d b4 24 2c 01
	00 00		 lea	 esi, DWORD PTR $T397682[esp+452]
  003af	e8 00 00 00 00	 call	 ?SquadronName@Hangar@@QBE?AVText@@H@Z ; Hangar::SquadronName
  003b4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003b7	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  003ba	8b 73 20	 mov	 esi, DWORD PTR [ebx+32]
  003bd	8d 4b 1c	 lea	 ecx, DWORD PTR [ebx+28]
  003c0	3b 56 08	 cmp	 edx, DWORD PTR [esi+8]
  003c3	75 11		 jne	 SHORT $LN282@CreateElem@2
  003c5	51		 push	 ecx
  003c6	8b c8		 mov	 ecx, eax
  003c8	e8 00 00 00 00	 call	 ?compare@Text@@QBEHABV1@@Z ; Text::compare
  003cd	85 c0		 test	 eax, eax
  003cf	75 05		 jne	 SHORT $LN282@CreateElem@2
  003d1	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  003d4	eb 02		 jmp	 SHORT $LN283@CreateElem@2
$LN282@CreateElem@2:
  003d6	33 f6		 xor	 esi, esi
$LN283@CreateElem@2:
  003d8	8d 8c 24 2c 01
	00 00		 lea	 ecx, DWORD PTR $T397682[esp+452]
  003df	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  003e4	85 f6		 test	 esi, esi
  003e6	75 0c		 jne	 SHORT $LN616@CreateElem@2

; 583  : 
; 584  : 							for (int s = 0; s < hangar->NumSquadrons(); s++) {

  003e8	8b 44 24 4c	 mov	 eax, DWORD PTR _hangar$118771[esp+452]
  003ec	47		 inc	 edi
  003ed	3b 78 14	 cmp	 edi, DWORD PTR [eax+20]
  003f0	7c b0		 jl	 SHORT $LL94@CreateElem@2

; 585  : 								if (hangar->SquadronName(s) == msn_elem->Squadron()) {

  003f2	eb 26		 jmp	 SHORT $LN296@CreateElem@2
$LN616@CreateElem@2:

; 586  : 									squadron = s;

  003f4	89 bc 24 80 00
	00 00		 mov	 DWORD PTR _squadron$118772[esp+452], edi

; 587  : 									break;
; 588  : 								}
; 589  : 							}
; 590  : 						}
; 591  : 					}
; 592  : 				}
; 593  : 			}
; 594  : 
; 595  : 			else if (msn_elem->Commander().length() > 0) {

  003fb	eb 1d		 jmp	 SHORT $LN296@CreateElem@2
$LN98@CreateElem@2:
  003fd	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  00400	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00404	7e 14		 jle	 SHORT $LN296@CreateElem@2

; 596  : 				Element* cmdr = FindElement(msn_elem->Commander());

  00406	8b 54 24 44	 mov	 edx, DWORD PTR _this$GSCopy$[esp+452]
  0040a	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]
  0040d	52		 push	 edx
  0040e	e8 00 00 00 00	 call	 ?FindElement@Sim@@QAEPAVElement@@PBD@Z ; Sim::FindElement

; 597  : 
; 598  : 				if (cmdr) {

  00413	85 c0		 test	 eax, eax
  00415	74 03		 je	 SHORT $LN296@CreateElem@2

; 599  : 					element->SetCommander(cmdr);

  00417	89 47 74	 mov	 DWORD PTR [edi+116], eax
$LN296@CreateElem@2:

; 600  : 				}
; 601  : 			}
; 602  : 
; 603  : 			ListIter<Instruction> obj = msn_elem->Objectives();

  0041a	8d 83 d0 00 00
	00		 lea	 eax, DWORD PTR [ebx+208]

; 604  : 			while (++obj) {

  00420	8d 94 24 bc 00
	00 00		 lea	 edx, DWORD PTR _obj$118828[esp+452]
  00427	89 84 24 bc 00
	00 00		 mov	 DWORD PTR _obj$118828[esp+452], eax
  0042e	c7 84 24 c0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR _obj$118828[esp+456], -1
  00439	e8 00 00 00 00	 call	 ?next@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::next
  0043e	85 c0		 test	 eax, eax
  00440	74 60		 je	 SHORT $LN86@CreateElem@2
$LL87@CreateElem@2:

; 605  : 				Instruction* o     = obj.value();

  00442	8d 84 24 bc 00
	00 00		 lea	 eax, DWORD PTR _obj$118828[esp+452]
  00449	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value

; 606  : 				Instruction* instr = 0;
; 607  : 
; 608  : 				instr = new(__FILE__,__LINE__) Instruction(*o);

  0044e	68 b0 00 00 00	 push	 176			; 000000b0H
  00453	8b f0		 mov	 esi, eax
  00455	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0045a	83 c4 04	 add	 esp, 4
  0045d	89 44 24 54	 mov	 DWORD PTR $T397684[esp+452], eax
  00461	c7 84 24 c0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+460], 0
  0046c	85 c0		 test	 eax, eax
  0046e	74 0a		 je	 SHORT $LN115@CreateElem@2
  00470	50		 push	 eax
  00471	8b ce		 mov	 ecx, esi
  00473	e8 00 00 00 00	 call	 ??0Instruction@@QAE@ABV0@@Z ; Instruction::Instruction
  00478	eb 02		 jmp	 SHORT $LN116@CreateElem@2
$LN115@CreateElem@2:
  0047a	33 c0		 xor	 eax, eax
$LN116@CreateElem@2:

; 609  : 
; 610  : 				element->AddObjective(instr);

  0047c	8b f8		 mov	 edi, eax
  0047e	8b 44 24 48	 mov	 eax, DWORD PTR _element$118774[esp+452]
  00482	c7 84 24 c0 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+460], -1
  0048d	e8 00 00 00 00	 call	 ?AddObjective@Element@@QAEXPAVInstruction@@@Z ; Element::AddObjective
  00492	8d 94 24 bc 00
	00 00		 lea	 edx, DWORD PTR _obj$118828[esp+452]
  00499	e8 00 00 00 00	 call	 ?next@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::next
  0049e	85 c0		 test	 eax, eax
  004a0	75 a0		 jne	 SHORT $LL87@CreateElem@2
$LN86@CreateElem@2:

; 611  : 			}
; 612  : 
; 613  : 			if (msn_elem->Instructions().size() > 0) {

  004a2	83 bb dc 00 00
	00 00		 cmp	 DWORD PTR [ebx+220], 0
  004a9	8d 83 dc 00 00
	00		 lea	 eax, DWORD PTR [ebx+220]
  004af	7e 54		 jle	 SHORT $LN83@CreateElem@2

; 614  : 				ListIter<Text> instr = msn_elem->Instructions();
; 615  : 				while (++instr) {

  004b1	8d 8c 24 c4 00
	00 00		 lea	 ecx, DWORD PTR _instr$118842[esp+452]
  004b8	89 84 24 c4 00
	00 00		 mov	 DWORD PTR _instr$118842[esp+452], eax
  004bf	c7 84 24 c8 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR _instr$118842[esp+456], -1
  004ca	e8 00 00 00 00	 call	 ?next@?$ListIter@VText@@@@QAEPAVText@@XZ ; ListIter<Text>::next
  004cf	85 c0		 test	 eax, eax
  004d1	74 32		 je	 SHORT $LN83@CreateElem@2
  004d3	8b 74 24 48	 mov	 esi, DWORD PTR _element$118774[esp+452]
  004d7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL84@CreateElem@2:

; 616  : 					element->AddInstruction(*instr);

  004e0	8d 8c 24 c4 00
	00 00		 lea	 ecx, DWORD PTR _instr$118842[esp+452]
  004e7	e8 00 00 00 00	 call	 ?value@?$ListIter@VText@@@@QAEPAVText@@XZ ; ListIter<Text>::value
  004ec	8b 00		 mov	 eax, DWORD PTR [eax]
  004ee	50		 push	 eax
  004ef	56		 push	 esi
  004f0	e8 00 00 00 00	 call	 ?AddInstruction@Element@@QAEXPBD@Z ; Element::AddInstruction
  004f5	8d 8c 24 c4 00
	00 00		 lea	 ecx, DWORD PTR _instr$118842[esp+452]
  004fc	e8 00 00 00 00	 call	 ?next@?$ListIter@VText@@@@QAEPAVText@@XZ ; ListIter<Text>::next
  00501	85 c0		 test	 eax, eax
  00503	75 db		 jne	 SHORT $LL84@CreateElem@2
$LN83@CreateElem@2:

; 617  : 				}
; 618  : 			}
; 619  : 
; 620  : 			ListIter<Instruction> nav = msn_elem->NavList();

  00505	8d 8b e8 00 00
	00		 lea	 ecx, DWORD PTR [ebx+232]

; 621  : 			while (++nav) {

  0050b	8d 54 24 5c	 lea	 edx, DWORD PTR _nav$118847[esp+452]
  0050f	89 4c 24 5c	 mov	 DWORD PTR _nav$118847[esp+452], ecx
  00513	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR _nav$118847[esp+456], -1
  0051b	e8 00 00 00 00	 call	 ?next@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::next
  00520	85 c0		 test	 eax, eax
  00522	0f 84 45 01 00
	00		 je	 $LN81@CreateElem@2
  00528	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL82@CreateElem@2:

; 622  : 				SimRegion* rgn = FindRegion(nav->RegionName());

  00530	8d 44 24 5c	 lea	 eax, DWORD PTR _nav$118847[esp+452]
  00534	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value
  00539	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  0053c	8b 44 24 44	 mov	 eax, DWORD PTR _this$GSCopy$[esp+452]
  00540	e8 00 00 00 00	 call	 ?FindRegion@Sim@@QAEPAVSimRegion@@PBD@Z ; Sim::FindRegion
  00545	8b f8		 mov	 edi, eax

; 623  : 
; 624  : 				if (!rgn)

  00547	85 ff		 test	 edi, edi
  00549	75 16		 jne	 SHORT $LN626@CreateElem@2

; 625  : 				rgn = FindRegion(msn_elem->Region());

  0054b	8b 73 68	 mov	 esi, DWORD PTR [ebx+104]
  0054e	8b 44 24 44	 mov	 eax, DWORD PTR _this$GSCopy$[esp+452]
  00552	e8 00 00 00 00	 call	 ?FindRegion@Sim@@QAEPAVSimRegion@@PBD@Z ; Sim::FindRegion
  00557	8b f8		 mov	 edi, eax

; 626  : 
; 627  : 				if (rgn) {

  00559	85 ff		 test	 edi, edi
  0055b	0f 84 fb 00 00
	00		 je	 $LN79@CreateElem@2
$LN626@CreateElem@2:

; 628  : 					Instruction* npt = new(__FILE__,__LINE__)
; 629  : 					Instruction(rgn, nav->Location(), nav->Action());

  00561	68 b0 00 00 00	 push	 176			; 000000b0H
  00566	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0056b	83 c4 04	 add	 esp, 4
  0056e	89 44 24 58	 mov	 DWORD PTR $T397688[esp+452], eax
  00572	c7 84 24 c0 01
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+460], 1
  0057d	85 c0		 test	 eax, eax
  0057f	74 37		 je	 SHORT $LN117@CreateElem@2
  00581	8d 44 24 5c	 lea	 eax, DWORD PTR _nav$118847[esp+452]
  00585	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value
  0058a	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  0058d	83 ec 18	 sub	 esp, 24			; 00000018H
  00590	8b f4		 mov	 esi, esp
  00592	8b c8		 mov	 ecx, eax
  00594	89 54 24 6c	 mov	 DWORD PTR $T398096[esp+476], edx
  00598	89 a4 24 84 00
	00 00		 mov	 DWORD PTR $T397689[esp+476], esp
  0059f	e8 00 00 00 00	 call	 ?Location@Instruction@@QBE?AUPoint@@XZ ; Instruction::Location
  005a4	8b 44 24 6c	 mov	 eax, DWORD PTR $T398096[esp+476]
  005a8	8b 4c 24 70	 mov	 ecx, DWORD PTR $T397688[esp+476]
  005ac	50		 push	 eax
  005ad	57		 push	 edi
  005ae	51		 push	 ecx
  005af	e8 00 00 00 00	 call	 ??0Instruction@@QAE@PAVSimRegion@@UPoint@@H@Z ; Instruction::Instruction
  005b4	8b f8		 mov	 edi, eax
  005b6	eb 02		 jmp	 SHORT $LN118@CreateElem@2
$LN117@CreateElem@2:
  005b8	33 ff		 xor	 edi, edi
$LN118@CreateElem@2:

; 630  : 
; 631  : 					npt->SetStatus(nav->Status());

  005ba	8d 44 24 5c	 lea	 eax, DWORD PTR _nav$118847[esp+452]
  005be	c7 84 24 c0 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+460], -1
  005c9	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value
  005ce	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  005d1	8b c7		 mov	 eax, edi
  005d3	e8 00 00 00 00	 call	 ?SetStatus@Instruction@@QAEXH@Z ; Instruction::SetStatus

; 632  : 					npt->SetEMCON(nav->EMCON());

  005d8	8d 44 24 5c	 lea	 eax, DWORD PTR _nav$118847[esp+452]
  005dc	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value
  005e1	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [eax+148]
  005e7	89 87 94 00 00
	00		 mov	 DWORD PTR [edi+148], eax

; 633  : 					npt->SetFormation(nav->Formation());

  005ed	8d 44 24 5c	 lea	 eax, DWORD PTR _nav$118847[esp+452]
  005f1	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value
  005f6	8b 40 74	 mov	 eax, DWORD PTR [eax+116]
  005f9	89 47 74	 mov	 DWORD PTR [edi+116], eax

; 634  : 					npt->SetSpeed(nav->Speed());

  005fc	8d 44 24 5c	 lea	 eax, DWORD PTR _nav$118847[esp+452]
  00600	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value
  00605	8b 40 7c	 mov	 eax, DWORD PTR [eax+124]
  00608	89 47 7c	 mov	 DWORD PTR [edi+124], eax

; 635  : 					npt->SetTarget(nav->TargetName());

  0060b	8d 44 24 5c	 lea	 eax, DWORD PTR _nav$118847[esp+452]
  0060f	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value
  00614	8b b0 80 00 00
	00		 mov	 esi, DWORD PTR [eax+128]
  0061a	e8 00 00 00 00	 call	 ?SetTarget@Instruction@@QAEXPBD@Z ; Instruction::SetTarget

; 636  : 					npt->SetHoldTime(nav->HoldTime());

  0061f	8d 44 24 5c	 lea	 eax, DWORD PTR _nav$118847[esp+452]
  00623	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value
  00628	f2 0f 10 80 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+168]

; 637  : 					npt->SetFarcast(nav->Farcast());

  00630	8d 44 24 5c	 lea	 eax, DWORD PTR _nav$118847[esp+452]
  00634	f2 0f 11 87 a8
	00 00 00	 movsd	 QWORD PTR [edi+168], xmm0
  0063c	e8 00 00 00 00	 call	 ?value@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::value
  00641	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]

; 638  : 
; 639  : 					element->AddNavPoint(npt);

  00647	8b 54 24 48	 mov	 edx, DWORD PTR _element$118774[esp+452]
  0064b	6a 01		 push	 1
  0064d	57		 push	 edi
  0064e	89 87 a0 00 00
	00		 mov	 DWORD PTR [edi+160], eax
  00654	52		 push	 edx
  00655	33 c0		 xor	 eax, eax
  00657	e8 00 00 00 00	 call	 ?AddNavPoint@Element@@QAEXPAVInstruction@@0_N@Z ; Element::AddNavPoint
$LN79@CreateElem@2:

; 621  : 			while (++nav) {

  0065c	8d 54 24 5c	 lea	 edx, DWORD PTR _nav$118847[esp+452]
  00660	e8 00 00 00 00	 call	 ?next@?$ListIter@VInstruction@@@@QAEPAVInstruction@@XZ ; ListIter<Instruction>::next
  00665	85 c0		 test	 eax, eax
  00667	0f 85 c3 fe ff
	ff		 jne	 $LL82@CreateElem@2
$LN81@CreateElem@2:

; 640  : 				}
; 641  : 			}
; 642  : 
; 643  : 			bool  alertPrep = false;
; 644  : 			int*  loadout   = 0;
; 645  : 			int   respawns  = msn_elem->RespawnCount();

  0066d	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  00670	33 c9		 xor	 ecx, ecx
  00672	89 4c 24 50	 mov	 DWORD PTR _loadout$118864[esp+452], ecx
  00676	89 44 24 54	 mov	 DWORD PTR _respawns$118865[esp+452], eax

; 646  : 
; 647  : 			// if ships are to start on alert,
; 648  : 			// spot them onto the appropriate launch deck:
; 649  : 			if (hangar && element && msn_elem->Count() > 0 && msn_elem->IsAlert()) {

  0067a	39 4c 24 4c	 cmp	 DWORD PTR _hangar$118771[esp+452], ecx
  0067e	0f 84 90 02 00
	00		 je	 $LN628@CreateElem@2
  00684	39 4b 38	 cmp	 DWORD PTR [ebx+56], ecx
  00687	0f 8e 87 02 00
	00		 jle	 $LN628@CreateElem@2
  0068d	38 4b 64	 cmp	 BYTE PTR [ebx+100], cl
  00690	0f 84 7e 02 00
	00		 je	 $LN628@CreateElem@2

; 650  : 				FlightDeck*       deck  = 0;
; 651  : 				int               queue = 1000;
; 652  : 				const ShipDesign* dsn   = msn_elem->GetDesign();

  00696	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00699	89 4c 24 40	 mov	 DWORD PTR _deck$118867[esp+452], ecx
  0069d	c7 44 24 6c e8
	03 00 00	 mov	 DWORD PTR _queue$118868[esp+452], 1000 ; 000003e8H
  006a5	89 44 24 58	 mov	 DWORD PTR _dsn$118869[esp+452], eax

; 653  : 
; 654  : 				if (dsn) {

  006a9	3b c1		 cmp	 eax, ecx
  006ab	0f 84 63 02 00
	00		 je	 $LN628@CreateElem@2

; 655  : 					for (int i = 0; i < carrier->NumFlightDecks(); i++) {

  006b1	8b 44 24 30	 mov	 eax, DWORD PTR _carrier$118770[esp+452]
  006b5	89 4c 24 38	 mov	 DWORD PTR _i$118871[esp+452], ecx
  006b9	e8 00 00 00 00	 call	 ?NumFlightDecks@Ship@@QBEHXZ ; Ship::NumFlightDecks
  006be	85 c0		 test	 eax, eax
  006c0	0f 8e 4e 02 00
	00		 jle	 $LN628@CreateElem@2
  006c6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL76@CreateElem@2:

; 656  : 						FlightDeck* d  = carrier->GetFlightDeck(i);

  006d0	8b 4c 24 38	 mov	 ecx, DWORD PTR _i$118871[esp+452]
  006d4	8b 44 24 30	 mov	 eax, DWORD PTR _carrier$118770[esp+452]
  006d8	e8 00 00 00 00	 call	 ?GetFlightDeck@Ship@@QBEPAVFlightDeck@@H@Z ; Ship::GetFlightDeck

; 657  : 						int         dq = hangar->PreflightQueue(d);

  006dd	8b 54 24 4c	 mov	 edx, DWORD PTR _hangar$118771[esp+452]
  006e1	8b f0		 mov	 esi, eax
  006e3	56		 push	 esi
  006e4	e8 00 00 00 00	 call	 ?PreflightQueue@Hangar@@QBEHPAVFlightDeck@@@Z ; Hangar::PreflightQueue
  006e9	8b f8		 mov	 edi, eax

; 658  : 
; 659  : 						if (d && d->IsLaunchDeck() && d->SpaceLeft(dsn->type) && dq < queue) {

  006eb	85 f6		 test	 esi, esi
  006ed	74 33		 je	 SHORT $LN75@CreateElem@2
  006ef	8b 16		 mov	 edx, DWORD PTR [esi]
  006f1	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  006f4	8b ce		 mov	 ecx, esi
  006f6	ff d0		 call	 eax
  006f8	84 c0		 test	 al, al
  006fa	74 26		 je	 SHORT $LN75@CreateElem@2
  006fc	8b 44 24 58	 mov	 eax, DWORD PTR _dsn$118869[esp+452]
  00700	8b 88 10 01 00
	00		 mov	 ecx, DWORD PTR [eax+272]
  00706	8b 16		 mov	 edx, DWORD PTR [esi]
  00708	8b 52 50	 mov	 edx, DWORD PTR [edx+80]
  0070b	51		 push	 ecx
  0070c	8b ce		 mov	 ecx, esi
  0070e	ff d2		 call	 edx
  00710	85 c0		 test	 eax, eax
  00712	74 0e		 je	 SHORT $LN75@CreateElem@2
  00714	3b 7c 24 6c	 cmp	 edi, DWORD PTR _queue$118868[esp+452]
  00718	7d 08		 jge	 SHORT $LN75@CreateElem@2

; 660  : 							queue = dq;

  0071a	89 7c 24 6c	 mov	 DWORD PTR _queue$118868[esp+452], edi

; 661  : 							deck  = d;

  0071e	89 74 24 40	 mov	 DWORD PTR _deck$118867[esp+452], esi
$LN75@CreateElem@2:

; 655  : 					for (int i = 0; i < carrier->NumFlightDecks(); i++) {

  00722	8b 4c 24 38	 mov	 ecx, DWORD PTR _i$118871[esp+452]
  00726	8b 44 24 30	 mov	 eax, DWORD PTR _carrier$118770[esp+452]
  0072a	41		 inc	 ecx
  0072b	89 4c 24 38	 mov	 DWORD PTR _i$118871[esp+452], ecx
  0072f	e8 00 00 00 00	 call	 ?NumFlightDecks@Ship@@QBEHXZ ; Ship::NumFlightDecks
  00734	3b c8		 cmp	 ecx, eax
  00736	7c 98		 jl	 SHORT $LL76@CreateElem@2

; 662  : 						}
; 663  : 					}
; 664  : 				}
; 665  : 
; 666  : 				if (deck) {

  00738	83 7c 24 40 00	 cmp	 DWORD PTR _deck$118867[esp+452], 0
  0073d	0f 84 d1 01 00
	00		 je	 $LN628@CreateElem@2

; 667  : 					alertPrep = true;
; 668  : 
; 669  : 					// choose best loadout:
; 670  : 					if (msn_elem->Loadouts().size()) {

  00743	83 bb f4 00 00
	00 00		 cmp	 DWORD PTR [ebx+244], 0
  0074a	8d 83 f4 00 00
	00		 lea	 eax, DWORD PTR [ebx+244]
  00750	c6 44 24 37 01	 mov	 BYTE PTR _alertPrep$118863[esp+452], 1
  00755	0f 84 bc 00 00
	00		 je	 $LN66@CreateElem@2

; 671  : 						MissionLoad* l = msn_elem->Loadouts().at(0);

  0075b	e8 00 00 00 00	 call	 ?at@?$List@VMissionLoad@@@@QAEAAPAVMissionLoad@@H@Z ; List<MissionLoad>::at
  00760	8b 38		 mov	 edi, DWORD PTR [eax]

; 672  : 						if (l->GetName().length()) {

  00762	8d b4 24 14 01
	00 00		 lea	 esi, DWORD PTR $T397693[esp+452]
  00769	8b c7		 mov	 eax, edi
  0076b	e8 00 00 00 00	 call	 ?GetName@MissionLoad@@QBE?AVText@@XZ ; MissionLoad::GetName
  00770	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00773	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00776	8d 8c 24 14 01
	00 00		 lea	 ecx, DWORD PTR $T397693[esp+452]
  0077d	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  00782	85 f6		 test	 esi, esi
  00784	0f 84 82 00 00
	00		 je	 $LN70@CreateElem@2

; 673  : 							ListIter<ShipLoad> sl = ((ShipDesign*) dsn)->loadouts;

  0078a	8b 4c 24 58	 mov	 ecx, DWORD PTR _dsn$118869[esp+452]
  0078e	81 c1 f8 07 00
	00		 add	 ecx, 2040		; 000007f8H

; 674  : 							while (++sl) {

  00794	8d 54 24 70	 lea	 edx, DWORD PTR _sl$118885[esp+452]
  00798	89 4c 24 70	 mov	 DWORD PTR _sl$118885[esp+452], ecx
  0079c	c7 44 24 74 ff
	ff ff ff	 mov	 DWORD PTR _sl$118885[esp+456], -1
  007a4	e8 00 00 00 00	 call	 ?next@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::next
  007a9	85 c0		 test	 eax, eax
  007ab	74 6a		 je	 SHORT $LN66@CreateElem@2
  007ad	8d 49 00	 npad	 3
$LL69@CreateElem@2:

; 675  : 								if (!_stricmp(sl->name, l->GetName()))

  007b0	8d b4 24 34 01
	00 00		 lea	 esi, DWORD PTR $T397695[esp+452]
  007b7	8b c7		 mov	 eax, edi
  007b9	e8 00 00 00 00	 call	 ?GetName@MissionLoad@@QBE?AVText@@XZ ; MissionLoad::GetName
  007be	8b 30		 mov	 esi, DWORD PTR [eax]
  007c0	8d 44 24 70	 lea	 eax, DWORD PTR _sl$118885[esp+452]
  007c4	e8 00 00 00 00	 call	 ?value@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::value
  007c9	56		 push	 esi
  007ca	50		 push	 eax
  007cb	e8 00 00 00 00	 call	 __stricmp
  007d0	83 c4 08	 add	 esp, 8
  007d3	85 c0		 test	 eax, eax
  007d5	8d 8c 24 34 01
	00 00		 lea	 ecx, DWORD PTR $T397695[esp+452]
  007dc	0f 94 44 24 3f	 sete	 BYTE PTR $T397694[esp+452]
  007e1	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  007e6	80 7c 24 3f 00	 cmp	 BYTE PTR $T397694[esp+452], 0
  007eb	74 10		 je	 SHORT $LN67@CreateElem@2

; 676  : 								loadout = sl->load;

  007ed	8d 44 24 70	 lea	 eax, DWORD PTR _sl$118885[esp+452]
  007f1	e8 00 00 00 00	 call	 ?value@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::value
  007f6	83 c0 40	 add	 eax, 64			; 00000040H
  007f9	89 44 24 50	 mov	 DWORD PTR _loadout$118864[esp+452], eax
$LN67@CreateElem@2:

; 674  : 							while (++sl) {

  007fd	8d 54 24 70	 lea	 edx, DWORD PTR _sl$118885[esp+452]
  00801	e8 00 00 00 00	 call	 ?next@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::next
  00806	85 c0		 test	 eax, eax
  00808	75 a6		 jne	 SHORT $LL69@CreateElem@2

; 677  : 							}
; 678  : 						}
; 679  : 
; 680  : 						else {

  0080a	eb 0b		 jmp	 SHORT $LN66@CreateElem@2
$LN70@CreateElem@2:

; 681  : 							loadout = l->GetStations();

  0080c	8b c7		 mov	 eax, edi
  0080e	e8 00 00 00 00	 call	 ?GetStations@MissionLoad@@QAEPAHXZ ; MissionLoad::GetStations
  00813	89 44 24 50	 mov	 DWORD PTR _loadout$118864[esp+452], eax
$LN66@CreateElem@2:

; 682  : 						}
; 683  : 					}
; 684  : 
; 685  : 					element->SetLoadout(loadout);

  00817	8b 44 24 50	 mov	 eax, DWORD PTR _loadout$118864[esp+452]
  0081b	8b 4c 24 48	 mov	 ecx, DWORD PTR _element$118774[esp+452]
  0081f	e8 00 00 00 00	 call	 ?SetLoadout@Element@@QAEXPAH@Z ; Element::SetLoadout

; 686  : 
; 687  : 					for (int i = 0; i < msn_elem->Count(); i++) {

  00824	33 ff		 xor	 edi, edi
  00826	39 7b 38	 cmp	 DWORD PTR [ebx+56], edi
  00829	0f 8e 25 09 00
	00		 jle	 $LN54@CreateElem@2
  0082f	90		 npad	 1
$LL65@CreateElem@2:

; 688  : 						int   squadron = -1;
; 689  : 						int   slot     = -1;
; 690  : 
; 691  : 						if (hangar->FindAvailSlot(msn_elem->GetDesign(), squadron, slot)) {

  00830	8b 4c 24 4c	 mov	 ecx, DWORD PTR _hangar$118771[esp+452]
  00834	8b 11		 mov	 edx, DWORD PTR [ecx]
  00836	83 c8 ff	 or	 eax, -1
  00839	8d 74 24 30	 lea	 esi, DWORD PTR _slot$118899[esp+452]
  0083d	56		 push	 esi
  0083e	89 44 24 3c	 mov	 DWORD PTR _squadron$118898[esp+456], eax
  00842	89 44 24 34	 mov	 DWORD PTR _slot$118899[esp+456], eax
  00846	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00849	8d 74 24 3c	 lea	 esi, DWORD PTR _squadron$118898[esp+456]
  0084d	56		 push	 esi
  0084e	50		 push	 eax
  0084f	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00852	ff d0		 call	 eax
  00854	84 c0		 test	 al, al
  00856	0f 84 a3 00 00
	00		 je	 $LN64@CreateElem@2

; 692  : 							alertPrep = alertPrep &&
; 693  : 							hangar->GotoAlert(squadron,
; 694  : 							slot,
; 695  : 							deck,
; 696  : 							element,
; 697  : 							loadout,
; 698  : 							true,    // package for launch
; 699  : 							true);   // expedite

  0085c	80 7c 24 37 00	 cmp	 BYTE PTR _alertPrep$118863[esp+452], 0
  00861	74 31		 je	 SHORT $LN119@CreateElem@2
  00863	8b 44 24 50	 mov	 eax, DWORD PTR _loadout$118864[esp+452]
  00867	8b 4c 24 4c	 mov	 ecx, DWORD PTR _hangar$118771[esp+452]
  0086b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0086d	8b 52 20	 mov	 edx, DWORD PTR [edx+32]
  00870	6a 01		 push	 1
  00872	6a 01		 push	 1
  00874	50		 push	 eax
  00875	8b 44 24 54	 mov	 eax, DWORD PTR _element$118774[esp+464]
  00879	50		 push	 eax
  0087a	8b 44 24 50	 mov	 eax, DWORD PTR _deck$118867[esp+468]
  0087e	50		 push	 eax
  0087f	8b 44 24 44	 mov	 eax, DWORD PTR _slot$118899[esp+472]
  00883	50		 push	 eax
  00884	8b 44 24 50	 mov	 eax, DWORD PTR _squadron$118898[esp+476]
  00888	50		 push	 eax
  00889	ff d2		 call	 edx
  0088b	c6 44 24 37 01	 mov	 BYTE PTR _alertPrep$118863[esp+452], 1
  00890	84 c0		 test	 al, al
  00892	75 05		 jne	 SHORT $LN120@CreateElem@2
$LN119@CreateElem@2:
  00894	c6 44 24 37 00	 mov	 BYTE PTR _alertPrep$118863[esp+452], 0
$LN120@CreateElem@2:

; 700  : 
; 701  : 							HangarSlot* s         = (HangarSlot*) hangar->GetSlot(squadron, slot);

  00899	8b 44 24 4c	 mov	 eax, DWORD PTR _hangar$118771[esp+452]
  0089d	8b 4c 24 30	 mov	 ecx, DWORD PTR _slot$118899[esp+452]
  008a1	50		 push	 eax
  008a2	8b 44 24 3c	 mov	 eax, DWORD PTR _squadron$118898[esp+456]
  008a6	e8 00 00 00 00	 call	 ?GetSlot@Hangar@@QBEPBVHangarSlot@@HH@Z ; Hangar::GetSlot

; 702  : 							Ship*       alertShip = hangar->GetShip(s);

  008ab	e8 00 00 00 00	 call	 ?GetShip@Hangar@@QBEPAVShip@@PBVHangarSlot@@@Z ; Hangar::GetShip
  008b0	8b f0		 mov	 esi, eax

; 703  : 
; 704  : 							if (alertShip) {

  008b2	85 f6		 test	 esi, esi
  008b4	74 49		 je	 SHORT $LN64@CreateElem@2

; 705  : 								alertShip->SetRespawnCount(respawns);

  008b6	8b 4c 24 54	 mov	 ecx, DWORD PTR _respawns$118865[esp+452]

; 706  : 
; 707  : 								if (msn_elem->Player() == i+1) {

  008ba	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  008bd	89 8e 98 04 00
	00		 mov	 DWORD PTR [esi+1176], ecx
  008c3	39 53 5c	 cmp	 DWORD PTR [ebx+92], edx
  008c6	75 37		 jne	 SHORT $LN64@CreateElem@2

; 708  : 									if (alertShip->GetRegion()) {

  008c8	8b 06		 mov	 eax, DWORD PTR [esi]
  008ca	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  008d0	8b ce		 mov	 ecx, esi
  008d2	ff d2		 call	 edx
  008d4	85 c0		 test	 eax, eax
  008d6	74 16		 je	 SHORT $LN59@CreateElem@2

; 709  : 										alertShip->GetRegion()->SetPlayerShip(alertShip);

  008d8	8b 06		 mov	 eax, DWORD PTR [esi]
  008da	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  008e0	8b ce		 mov	 ecx, esi
  008e2	ff d2		 call	 edx
  008e4	50		 push	 eax
  008e5	8b c6		 mov	 eax, esi
  008e7	e8 00 00 00 00	 call	 ?SetPlayerShip@SimRegion@@QAEXPAVShip@@@Z ; SimRegion::SetPlayerShip

; 710  : 									}
; 711  : 									else {

  008ec	eb 11		 jmp	 SHORT $LN64@CreateElem@2
$LN59@CreateElem@2:

; 712  : 										::Print("WARNING: alert ship '%s' region is null\n", alertShip->Name());

  008ee	83 c6 10	 add	 esi, 16			; 00000010H
  008f1	56		 push	 esi
  008f2	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IICEGJCO@WARNING?3?5alert?5ship?5?8?$CFs?8?5region?5@
  008f7	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  008fc	83 c4 08	 add	 esp, 8
$LN64@CreateElem@2:

; 686  : 
; 687  : 					for (int i = 0; i < msn_elem->Count(); i++) {

  008ff	47		 inc	 edi
  00900	3b 7b 38	 cmp	 edi, DWORD PTR [ebx+56]
  00903	0f 8c 27 ff ff
	ff		 jl	 $LL65@CreateElem@2

; 713  : 									}
; 714  : 								}
; 715  : 							}
; 716  : 						}
; 717  : 					}
; 718  : 				}
; 719  : 			}
; 720  : 
; 721  : 			if (!alertPrep) {

  00909	80 7c 24 37 00	 cmp	 BYTE PTR _alertPrep$118863[esp+452], 0
  0090e	0f 85 40 08 00
	00		 jne	 $LN54@CreateElem@2
$LN628@CreateElem@2:

; 722  : 				// then, create the ships:
; 723  : 				for (int i = 0; i < msn_elem->Count(); i++) {

  00914	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00918	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _i$118910[esp+452], 0
  00920	0f 8e 2e 08 00
	00		 jle	 $LN54@CreateElem@2
$LN56@CreateElem@2:

; 724  : 					MissionShip*   msn_ship = 0;
; 725  : 					Text           sname    = msn_elem->GetShipName(i);

  00926	8b 4c 24 38	 mov	 ecx, DWORD PTR _i$118910[esp+452]
  0092a	33 ff		 xor	 edi, edi
  0092c	8d b4 24 b4 00
	00 00		 lea	 esi, DWORD PTR _sname$118915[esp+452]
  00933	8b d3		 mov	 edx, ebx
  00935	89 7c 24 30	 mov	 DWORD PTR _msn_ship$118914[esp+452], edi
  00939	e8 00 00 00 00	 call	 ?GetShipName@MissionElement@@QBE?AVText@@H@Z ; MissionElement::GetShipName
  0093e	c7 84 24 c0 01
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+460], 2

; 726  : 					Text           rnum     = msn_elem->GetRegistry(i);

  00949	8b 4c 24 38	 mov	 ecx, DWORD PTR _i$118910[esp+452]
  0094d	8d b4 24 d8 00
	00 00		 lea	 esi, DWORD PTR _rnum$118917[esp+452]
  00954	8b c3		 mov	 eax, ebx
  00956	e8 00 00 00 00	 call	 ?GetRegistry@MissionElement@@QBE?AVText@@H@Z ; MissionElement::GetRegistry

; 727  : 					Text           rgn_name = msn_elem->Region();

  0095b	8d 43 68	 lea	 eax, DWORD PTR [ebx+104]
  0095e	50		 push	 eax
  0095f	8d 8c 24 e8 00
	00 00		 lea	 ecx, DWORD PTR _rgn_name$118919[esp+456]
  00966	c6 84 24 c4 01
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+464], 3
  0096e	e8 00 00 00 00	 call	 ??0Text@@QAE@ABV0@@Z	; Text::Text
  00973	c6 84 24 c0 01
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+460], 4

; 728  : 
; 729  : 					if (msn_elem->Ships().size() > i) {

  0097b	8b 4c 24 38	 mov	 ecx, DWORD PTR _i$118910[esp+452]
  0097f	39 8b 00 01 00
	00		 cmp	 DWORD PTR [ebx+256], ecx
  00985	8d 83 00 01 00
	00		 lea	 eax, DWORD PTR [ebx+256]
  0098b	7e 36		 jle	 SHORT $LN53@CreateElem@2

; 730  : 						msn_ship = msn_elem->Ships()[i];

  0098d	8b d1		 mov	 edx, ecx
  0098f	52		 push	 edx
  00990	e8 00 00 00 00	 call	 ??A?$List@VMissionShip@@@@QAEAAPAVMissionShip@@H@Z ; List<MissionShip>::operator[]
  00995	8b 38		 mov	 edi, DWORD PTR [eax]

; 731  : 						sname    = msn_ship->Name();

  00997	57		 push	 edi
  00998	8d 8c 24 b8 00
	00 00		 lea	 ecx, DWORD PTR _sname$118915[esp+456]
  0099f	89 7c 24 34	 mov	 DWORD PTR _msn_ship$118914[esp+456], edi
  009a3	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@ABV0@@Z ; Text::operator=

; 732  : 						rnum     = msn_ship->RegNum();

  009a8	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  009ab	50		 push	 eax
  009ac	8b ce		 mov	 ecx, esi
  009ae	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@ABV0@@Z ; Text::operator=

; 733  : 						rgn_name = msn_ship->Region();

  009b3	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  009b6	51		 push	 ecx
  009b7	8d 8c 24 e8 00
	00 00		 lea	 ecx, DWORD PTR _rgn_name$118919[esp+456]
  009be	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@ABV0@@Z ; Text::operator=
$LN53@CreateElem@2:

; 734  : 					}
; 735  : 
; 736  : 					Point l2 = msn_elem->Location();

  009c3	8d b4 24 ec 00
	00 00		 lea	 esi, DWORD PTR _l2$118921[esp+452]
  009ca	8b cb		 mov	 ecx, ebx
  009cc	e8 00 00 00 00	 call	 ?Location@MissionElement@@QBE?AUPoint@@XZ ; MissionElement::Location

; 737  : 
; 738  : 					if (msn_ship && fabs(msn_ship->Location().x) < 1e9) {

  009d1	85 ff		 test	 edi, edi
  009d3	74 41		 je	 SHORT $LN52@CreateElem@2
  009d5	f2 0f 10 47 20	 movsd	 xmm0, QWORD PTR [edi+32]
  009da	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@
  009e2	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@41cdcd6500000000
  009ea	66 0f 2f c8	 comisd	 xmm1, xmm0
  009ee	76 26		 jbe	 SHORT $LN52@CreateElem@2

; 739  : 						l2 = msn_ship->Location();

  009f0	f2 0f 10 47 20	 movsd	 xmm0, QWORD PTR [edi+32]
  009f5	f2 0f 11 84 24
	ec 00 00 00	 movsd	 QWORD PTR _l2$118921[esp+452], xmm0
  009fe	f2 0f 10 47 28	 movsd	 xmm0, QWORD PTR [edi+40]
  00a03	f2 0f 11 84 24
	f4 00 00 00	 movsd	 QWORD PTR _l2$118921[esp+460], xmm0
  00a0c	f2 0f 10 47 30	 movsd	 xmm0, QWORD PTR [edi+48]
  00a11	e9 ab 00 00 00	 jmp	 $LN655@CreateElem@2
$LN52@CreateElem@2:

; 740  : 					}
; 741  : 					else if (i) {

  00a16	83 7c 24 38 00	 cmp	 DWORD PTR _i$118910[esp+452], 0
  00a1b	0f 84 a9 00 00
	00		 je	 $LN446@CreateElem@2

; 742  : 						Point offset = RandomPoint();

  00a21	8d 94 24 84 00
	00 00		 lea	 edx, DWORD PTR _offset$118926[esp+452]
  00a28	52		 push	 edx
  00a29	e8 00 00 00 00	 call	 ?RandomPoint@@YA?AUPoint@@XZ ; RandomPoint

; 743  : 						offset.z = Random(-1e3, 1e3);

  00a2e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@408f400000000000
  00a36	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00a39	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  00a3f	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@c08f400000000000
  00a47	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00a4c	e8 00 00 00 00	 call	 ?Random@@YANNN@Z	; Random
  00a51	dd 9c 24 a4 00
	00 00		 fstp	 QWORD PTR _offset$118926[esp+484]

; 744  : 
; 745  : 						if (msn_elem->Count() < 5)
; 746  : 						offset *= 0.3;

  00a58	f2 0f 10 8c 24
	94 00 00 00	 movsd	 xmm1, QWORD PTR _offset$118926[esp+468]
  00a61	f2 0f 10 84 24
	9c 00 00 00	 movsd	 xmm0, QWORD PTR _offset$118926[esp+476]
  00a6a	f2 0f 10 94 24
	a4 00 00 00	 movsd	 xmm2, QWORD PTR _offset$118926[esp+484]
  00a73	83 c4 10	 add	 esp, 16			; 00000010H
  00a76	83 7b 38 05	 cmp	 DWORD PTR [ebx+56], 5
  00a7a	7d 14		 jge	 SHORT $LN444@CreateElem@2
  00a7c	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3fd3333333333333
  00a84	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00a88	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00a8c	f2 0f 59 d3	 mulsd	 xmm2, xmm3
$LN444@CreateElem@2:

; 747  : 
; 748  : 						l2 += offset;

  00a90	f2 0f 58 84 24
	f4 00 00 00	 addsd	 xmm0, QWORD PTR _l2$118921[esp+460]
  00a99	f2 0f 58 8c 24
	ec 00 00 00	 addsd	 xmm1, QWORD PTR _l2$118921[esp+452]
  00aa2	f2 0f 11 84 24
	f4 00 00 00	 movsd	 QWORD PTR _l2$118921[esp+460], xmm0
  00aab	f2 0f 10 84 24
	fc 00 00 00	 movsd	 xmm0, QWORD PTR _l2$118921[esp+468]
  00ab4	f2 0f 11 8c 24
	ec 00 00 00	 movsd	 QWORD PTR _l2$118921[esp+452], xmm1
  00abd	f2 0f 58 c2	 addsd	 xmm0, xmm2
$LN655@CreateElem@2:
  00ac1	f2 0f 11 84 24
	fc 00 00 00	 movsd	 QWORD PTR _l2$118921[esp+468], xmm0
$LN446@CreateElem@2:

; 749  : 					}
; 750  : 
; 751  : 					// choose best loadout:
; 752  : 					ListIter<MissionLoad> l = msn_elem->Loadouts();

  00aca	8d 83 f4 00 00
	00		 lea	 eax, DWORD PTR [ebx+244]

; 753  : 					while (++l) {

  00ad0	8d 54 24 64	 lea	 edx, DWORD PTR _l$118962[esp+452]
  00ad4	89 44 24 64	 mov	 DWORD PTR _l$118962[esp+452], eax
  00ad8	c7 44 24 68 ff
	ff ff ff	 mov	 DWORD PTR _l$118962[esp+456], -1
  00ae0	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionLoad@@@@QAEPAVMissionLoad@@XZ ; ListIter<MissionLoad>::next
  00ae5	85 c0		 test	 eax, eax
  00ae7	0f 84 09 01 00
	00		 je	 $LN47@CreateElem@2
$LN48@CreateElem@2:

; 754  : 						if ((l->GetShip() == i) || (l->GetShip() < 0 && loadout == 0)) {

  00aed	8d 44 24 64	 lea	 eax, DWORD PTR _l$118962[esp+452]
  00af1	e8 00 00 00 00	 call	 ?value@?$ListIter@VMissionLoad@@@@QAEPAVMissionLoad@@XZ ; ListIter<MissionLoad>::value
  00af6	8b c8		 mov	 ecx, eax
  00af8	e8 00 00 00 00	 call	 ?GetShip@MissionLoad@@QBEHXZ ; MissionLoad::GetShip
  00afd	3b 44 24 38	 cmp	 eax, DWORD PTR _i$118910[esp+452]
  00b01	74 1a		 je	 SHORT $LN45@CreateElem@2
  00b03	8b c1		 mov	 eax, ecx
  00b05	e8 00 00 00 00	 call	 ?GetShip@MissionLoad@@QBEHXZ ; MissionLoad::GetShip
  00b0a	85 c0		 test	 eax, eax
  00b0c	0f 89 d3 00 00
	00		 jns	 $LN40@CreateElem@2
  00b12	83 7c 24 50 00	 cmp	 DWORD PTR _loadout$118864[esp+452], 0
  00b17	0f 85 c8 00 00
	00		 jne	 $LN40@CreateElem@2
$LN45@CreateElem@2:

; 755  : 							if (l->GetName().length()) {

  00b1d	8d 44 24 64	 lea	 eax, DWORD PTR _l$118962[esp+452]
  00b21	e8 00 00 00 00	 call	 ?value@?$ListIter@VMissionLoad@@@@QAEPAVMissionLoad@@XZ ; ListIter<MissionLoad>::value
  00b26	8d b4 24 24 01
	00 00		 lea	 esi, DWORD PTR $T397699[esp+452]
  00b2d	e8 00 00 00 00	 call	 ?GetName@MissionLoad@@QBE?AVText@@XZ ; MissionLoad::GetName
  00b32	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00b35	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00b38	8d 8c 24 24 01
	00 00		 lea	 ecx, DWORD PTR $T397699[esp+452]
  00b3f	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  00b44	85 f6		 test	 esi, esi
  00b46	0f 84 87 00 00
	00		 je	 $LN44@CreateElem@2

; 756  : 								ListIter<ShipLoad> sl = ((ShipDesign*) msn_elem->GetDesign())->loadouts;

  00b4c	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00b4f	05 f8 07 00 00	 add	 eax, 2040		; 000007f8H

; 757  : 								while (++sl) {

  00b54	8d 54 24 78	 lea	 edx, DWORD PTR _sl$118972[esp+452]
  00b58	89 44 24 78	 mov	 DWORD PTR _sl$118972[esp+452], eax
  00b5c	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR _sl$118972[esp+456], -1
  00b64	e8 00 00 00 00	 call	 ?next@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::next
  00b69	85 c0		 test	 eax, eax
  00b6b	74 78		 je	 SHORT $LN40@CreateElem@2
  00b6d	8d 49 00	 npad	 3
$LL43@CreateElem@2:

; 758  : 									if (!_stricmp(sl->name, l->GetName()))

  00b70	8d 44 24 64	 lea	 eax, DWORD PTR _l$118962[esp+452]
  00b74	e8 00 00 00 00	 call	 ?value@?$ListIter@VMissionLoad@@@@QAEPAVMissionLoad@@XZ ; ListIter<MissionLoad>::value
  00b79	8d b4 24 0c 01
	00 00		 lea	 esi, DWORD PTR $T397701[esp+452]
  00b80	e8 00 00 00 00	 call	 ?GetName@MissionLoad@@QBE?AVText@@XZ ; MissionLoad::GetName
  00b85	8b 30		 mov	 esi, DWORD PTR [eax]
  00b87	8d 44 24 78	 lea	 eax, DWORD PTR _sl$118972[esp+452]
  00b8b	e8 00 00 00 00	 call	 ?value@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::value
  00b90	56		 push	 esi
  00b91	50		 push	 eax
  00b92	e8 00 00 00 00	 call	 __stricmp
  00b97	83 c4 08	 add	 esp, 8
  00b9a	85 c0		 test	 eax, eax
  00b9c	8d 8c 24 0c 01
	00 00		 lea	 ecx, DWORD PTR $T397701[esp+452]
  00ba3	0f 94 44 24 3f	 sete	 BYTE PTR $T397700[esp+452]
  00ba8	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  00bad	80 7c 24 3f 00	 cmp	 BYTE PTR $T397700[esp+452], 0
  00bb2	74 10		 je	 SHORT $LN41@CreateElem@2

; 759  : 									loadout = sl->load;

  00bb4	8d 44 24 78	 lea	 eax, DWORD PTR _sl$118972[esp+452]
  00bb8	e8 00 00 00 00	 call	 ?value@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::value
  00bbd	83 c0 40	 add	 eax, 64			; 00000040H
  00bc0	89 44 24 50	 mov	 DWORD PTR _loadout$118864[esp+452], eax
$LN41@CreateElem@2:

; 757  : 								while (++sl) {

  00bc4	8d 54 24 78	 lea	 edx, DWORD PTR _sl$118972[esp+452]
  00bc8	e8 00 00 00 00	 call	 ?next@?$ListIter@VShipLoad@@@@QAEPAVShipLoad@@XZ ; ListIter<ShipLoad>::next
  00bcd	85 c0		 test	 eax, eax
  00bcf	75 9f		 jne	 SHORT $LL43@CreateElem@2

; 760  : 								}
; 761  : 							}
; 762  : 
; 763  : 							else {

  00bd1	eb 12		 jmp	 SHORT $LN40@CreateElem@2
$LN44@CreateElem@2:

; 764  : 								loadout = l->GetStations();

  00bd3	8d 44 24 64	 lea	 eax, DWORD PTR _l$118962[esp+452]
  00bd7	e8 00 00 00 00	 call	 ?value@?$ListIter@VMissionLoad@@@@QAEPAVMissionLoad@@XZ ; ListIter<MissionLoad>::value
  00bdc	e8 00 00 00 00	 call	 ?GetStations@MissionLoad@@QAEPAHXZ ; MissionLoad::GetStations
  00be1	89 44 24 50	 mov	 DWORD PTR _loadout$118864[esp+452], eax
$LN40@CreateElem@2:

; 753  : 					while (++l) {

  00be5	8d 54 24 64	 lea	 edx, DWORD PTR _l$118962[esp+452]
  00be9	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionLoad@@@@QAEPAVMissionLoad@@XZ ; ListIter<MissionLoad>::next
  00bee	85 c0		 test	 eax, eax
  00bf0	0f 85 f7 fe ff
	ff		 jne	 $LN48@CreateElem@2
$LN47@CreateElem@2:

; 765  : 							}
; 766  : 						}
; 767  : 					}
; 768  : 
; 769  : 					element->SetLoadout(loadout);

  00bf6	8b 74 24 50	 mov	 esi, DWORD PTR _loadout$118864[esp+452]
  00bfa	8b 4c 24 48	 mov	 ecx, DWORD PTR _element$118774[esp+452]
  00bfe	8b c6		 mov	 eax, esi
  00c00	e8 00 00 00 00	 call	 ?SetLoadout@Element@@QAEXPAH@Z ; Element::SetLoadout

; 770  : 
; 771  : 					Ship* ship = CreateShip(sname, rnum, 
; 772  : 					(ShipDesign*) msn_elem->GetDesign(), 
; 773  : 					rgn_name, l2,
; 774  : 					msn_elem->GetIFF(),
; 775  : 					msn_elem->CommandAI(),
; 776  : 					loadout);

  00c05	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00c08	8b 53 44	 mov	 edx, DWORD PTR [ebx+68]
  00c0b	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  00c0e	56		 push	 esi
  00c0f	50		 push	 eax
  00c10	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR _rgn_name$118919[esp+460]
  00c17	52		 push	 edx
  00c18	8d 94 24 f8 00
	00 00		 lea	 edx, DWORD PTR _l2$118921[esp+464]
  00c1f	52		 push	 edx
  00c20	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR _rnum$118917[esp+468]
  00c27	50		 push	 eax
  00c28	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR _sname$118915[esp+472]
  00c2f	52		 push	 edx
  00c30	8b 54 24 5c	 mov	 edx, DWORD PTR _this$GSCopy$[esp+476]
  00c34	50		 push	 eax
  00c35	52		 push	 edx
  00c36	e8 00 00 00 00	 call	 ?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z ; Sim::CreateShip
  00c3b	8b f8		 mov	 edi, eax

; 777  : 
; 778  : 					if (ship) {

  00c3d	85 ff		 test	 edi, edi
  00c3f	0f 84 be 04 00
	00		 je	 $LN1@CreateElem@2

; 779  : 						double      heading  = msn_elem->Heading();
; 780  : 						const Skin* skin     = msn_elem->GetSkin();
; 781  : 
; 782  : 						if (msn_ship) {

  00c45	8b 44 24 30	 mov	 eax, DWORD PTR _msn_ship$118914[esp+452]
  00c49	f2 0f 10 83 c0
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+192]
  00c51	8b 73 34	 mov	 esi, DWORD PTR [ebx+52]
  00c54	f2 0f 11 84 24
	cc 00 00 00	 movsd	 QWORD PTR _heading$118984[esp+452], xmm0
  00c5d	85 c0		 test	 eax, eax
  00c5f	74 17		 je	 SHORT $LN498@CreateElem@2

; 783  : 							heading  = msn_ship->Heading();

  00c61	f2 0f 10 40 58	 movsd	 xmm0, QWORD PTR [eax+88]

; 784  : 
; 785  : 							if (msn_ship->GetSkin())

  00c66	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00c69	f2 0f 11 84 24
	cc 00 00 00	 movsd	 QWORD PTR _heading$118984[esp+452], xmm0
  00c72	85 c0		 test	 eax, eax
  00c74	74 02		 je	 SHORT $LN498@CreateElem@2

; 786  : 							skin = msn_ship->GetSkin();

  00c76	8b f0		 mov	 esi, eax
$LN498@CreateElem@2:

; 787  : 						}
; 788  : 
; 789  : 						ship->SetRogue(msn_elem->IsRogue());

  00c78	8a 53 66	 mov	 dl, BYTE PTR [ebx+102]
  00c7b	8b cf		 mov	 ecx, edi
  00c7d	e8 00 00 00 00	 call	 ?SetRogue@Ship@@QAEX_N@Z ; Ship::SetRogue

; 790  : 						ship->SetInvulnerable(msn_elem->IsInvulnerable());

  00c82	8a 43 67	 mov	 al, BYTE PTR [ebx+103]

; 791  : 						ship->SetHeading(0, 0, heading + PI);

  00c85	f2 0f 10 84 24
	cc 00 00 00	 movsd	 xmm0, QWORD PTR _heading$118984[esp+452]
  00c8e	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR _PI
  00c96	83 ec 18	 sub	 esp, 24			; 00000018H
  00c99	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  00c9f	0f 57 c0	 xorps	 xmm0, xmm0
  00ca2	88 87 22 04 00
	00		 mov	 BYTE PTR [edi+1058], al
  00ca8	8b 07		 mov	 eax, DWORD PTR [edi]
  00caa	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  00cad	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  00cb3	8b cf		 mov	 ecx, edi
  00cb5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00cba	ff d2		 call	 edx

; 792  : 						ship->SetRespawnCount(respawns);

  00cbc	8b 44 24 54	 mov	 eax, DWORD PTR _respawns$118865[esp+452]

; 793  : 						ship->UseSkin(skin);
; 794  : 
; 795  : 						if (!netgame)

  00cc0	8b 4c 24 44	 mov	 ecx, DWORD PTR _this$GSCopy$[esp+452]
  00cc4	89 87 98 04 00
	00		 mov	 DWORD PTR [edi+1176], eax
  00cca	89 b7 2c 03 00
	00		 mov	 DWORD PTR [edi+812], esi
  00cd0	83 b9 c4 00 00
	00 00		 cmp	 DWORD PTR [ecx+196], 0
  00cd7	75 4a		 jne	 SHORT $LN516@CreateElem@2

; 796  : 						ship->SetRespawnLoc(RandomPoint() * 2);

  00cd9	8d 94 24 84 00
	00 00		 lea	 edx, DWORD PTR $T397702[esp+452]
  00ce0	52		 push	 edx
  00ce1	e8 00 00 00 00	 call	 ?RandomPoint@@YA?AUPoint@@XZ ; RandomPoint
  00ce6	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00cea	f2 0f 10 48 08	 movsd	 xmm1, QWORD PTR [eax+8]
  00cef	f2 0f 10 50 10	 movsd	 xmm2, QWORD PTR [eax+16]
  00cf4	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@4000000000000000
  00cfc	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00d00	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00d04	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  00d08	83 c4 04	 add	 esp, 4
  00d0b	f2 0f 11 87 80
	04 00 00	 movsd	 QWORD PTR [edi+1152], xmm0
  00d13	f2 0f 11 8f 88
	04 00 00	 movsd	 QWORD PTR [edi+1160], xmm1
  00d1b	f2 0f 11 97 90
	04 00 00	 movsd	 QWORD PTR [edi+1168], xmm2
$LN516@CreateElem@2:

; 797  : 
; 798  : 						if (ship->IsStarship())

  00d23	8b c7		 mov	 eax, edi
  00d25	e8 00 00 00 00	 call	 ?IsStarship@Ship@@QBE_NXZ ; Ship::IsStarship
  00d2a	84 c0		 test	 al, al
  00d2c	74 11		 je	 SHORT $LN35@CreateElem@2

; 799  : 						ship->SetHelmHeading(heading);

  00d2e	f2 0f 10 84 24
	cc 00 00 00	 movsd	 xmm0, QWORD PTR _heading$118984[esp+452]
  00d37	57		 push	 edi
  00d38	e8 00 00 00 00	 call	 ?SetHelmHeading@Ship@@QAEXN@Z ; Ship::SetHelmHeading
  00d3d	eb 72		 jmp	 SHORT $LN33@CreateElem@2
$LN35@CreateElem@2:

; 800  : 
; 801  : 						else if (ship->IsAirborne() && ship->AltitudeAGL() > 25)

  00d3f	8b c7		 mov	 eax, edi
  00d41	e8 00 00 00 00	 call	 ?IsAirborne@Ship@@QBE_NXZ ; Ship::IsAirborne
  00d46	84 c0		 test	 al, al
  00d48	74 67		 je	 SHORT $LN33@CreateElem@2
  00d4a	e8 00 00 00 00	 call	 ?AltitudeAGL@Ship@@QBENXZ ; Ship::AltitudeAGL
  00d4f	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4039000000000000
  00d57	76 58		 jbe	 SHORT $LN33@CreateElem@2

; 802  : 						ship->SetVelocity(ship->Heading() * 250);

  00d59	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@406f400000000000
  00d61	8b 07		 mov	 eax, DWORD PTR [edi]
  00d63	f2 0f 10 87 a0
	00 00 00	 movsd	 xmm0, QWORD PTR [edi+160]
  00d6b	f2 0f 10 8f 98
	00 00 00	 movsd	 xmm1, QWORD PTR [edi+152]
  00d73	f2 0f 10 97 90
	00 00 00	 movsd	 xmm2, QWORD PTR [edi+144]
  00d7b	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  00d7e	8d 8c 24 84 00
	00 00		 lea	 ecx, DWORD PTR $T397705[esp+452]
  00d85	51		 push	 ecx
  00d86	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  00d8a	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00d8e	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00d92	8b cf		 mov	 ecx, edi
  00d94	f2 0f 11 94 24
	88 00 00 00	 movsd	 QWORD PTR $T397705[esp+456], xmm2
  00d9d	f2 0f 11 8c 24
	90 00 00 00	 movsd	 QWORD PTR $T397705[esp+464], xmm1
  00da6	f2 0f 11 84 24
	98 00 00 00	 movsd	 QWORD PTR $T397705[esp+472], xmm0
  00daf	ff d2		 call	 edx
$LN33@CreateElem@2:

; 803  : 
; 804  : 						if (element)
; 805  : 						element->AddShip(ship);

  00db1	8b 44 24 48	 mov	 eax, DWORD PTR _element$118774[esp+452]
  00db5	6a ff		 push	 -1
  00db7	50		 push	 eax
  00db8	8b c7		 mov	 eax, edi
  00dba	e8 00 00 00 00	 call	 ?AddShip@Element@@QAEHPAVShip@@H@Z ; Element::AddShip

; 806  : 
; 807  : 						if (hangar)

  00dbf	8b 4c 24 4c	 mov	 ecx, DWORD PTR _hangar$118771[esp+452]
  00dc3	85 c9		 test	 ecx, ecx
  00dc5	74 1a		 je	 SHORT $LN31@CreateElem@2

; 808  : 						hangar->FindSlot(ship, squadron, slot, Hangar::ACTIVE);

  00dc7	8b 11		 mov	 edx, DWORD PTR [ecx]
  00dc9	8b 52 38	 mov	 edx, DWORD PTR [edx+56]
  00dcc	6a 06		 push	 6
  00dce	8d 84 24 e4 00
	00 00		 lea	 eax, DWORD PTR _slot$118773[esp+456]
  00dd5	50		 push	 eax
  00dd6	8d 84 24 88 00
	00 00		 lea	 eax, DWORD PTR _squadron$118772[esp+460]
  00ddd	50		 push	 eax
  00dde	57		 push	 edi
  00ddf	ff d2		 call	 edx
$LN31@CreateElem@2:

; 809  : 
; 810  : 						if (ship->GetRegion() && msn_elem->Player() == i+1)

  00de1	8b 07		 mov	 eax, DWORD PTR [edi]
  00de3	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00de9	8b cf		 mov	 ecx, edi
  00deb	ff d2		 call	 edx
  00ded	85 c0		 test	 eax, eax
  00def	74 1e		 je	 SHORT $LN30@CreateElem@2
  00df1	8b 4c 24 38	 mov	 ecx, DWORD PTR _i$118910[esp+452]
  00df5	41		 inc	 ecx
  00df6	39 4b 5c	 cmp	 DWORD PTR [ebx+92], ecx
  00df9	75 14		 jne	 SHORT $LN30@CreateElem@2

; 811  : 						ship->GetRegion()->SetPlayerShip(ship);

  00dfb	8b 17		 mov	 edx, DWORD PTR [edi]
  00dfd	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00e03	8b cf		 mov	 ecx, edi
  00e05	ff d0		 call	 eax
  00e07	50		 push	 eax
  00e08	8b c7		 mov	 eax, edi
  00e0a	e8 00 00 00 00	 call	 ?SetPlayerShip@SimRegion@@QAEXPAVShip@@@Z ; SimRegion::SetPlayerShip
$LN30@CreateElem@2:

; 812  : 
; 813  : 						if (ship->NumFlightDecks()) {

  00e0f	8b c7		 mov	 eax, edi
  00e11	e8 00 00 00 00	 call	 ?NumFlightDecks@Ship@@QBEHXZ ; Ship::NumFlightDecks
  00e16	85 c0		 test	 eax, eax
  00e18	74 30		 je	 SHORT $LN26@CreateElem@2

; 814  : 							for (int i = 0; i < ship->NumFlightDecks(); i++) {

  00e1a	8b c7		 mov	 eax, edi
  00e1c	33 f6		 xor	 esi, esi
  00e1e	e8 00 00 00 00	 call	 ?NumFlightDecks@Ship@@QBEHXZ ; Ship::NumFlightDecks
  00e23	85 c0		 test	 eax, eax
  00e25	7e 23		 jle	 SHORT $LN26@CreateElem@2
$LL28@CreateElem@2:

; 815  : 								FlightDeck* deck = ship->GetFlightDeck(i);

  00e27	8b ce		 mov	 ecx, esi
  00e29	8b c7		 mov	 eax, edi
  00e2b	e8 00 00 00 00	 call	 ?GetFlightDeck@Ship@@QBEPAVFlightDeck@@H@Z ; Ship::GetFlightDeck

; 816  : 								if (deck)

  00e30	85 c0		 test	 eax, eax
  00e32	74 0a		 je	 SHORT $LN27@CreateElem@2

; 817  : 								deck->Orient(ship);

  00e34	8b 10		 mov	 edx, DWORD PTR [eax]
  00e36	8b c8		 mov	 ecx, eax
  00e38	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00e3b	57		 push	 edi
  00e3c	ff d0		 call	 eax
$LN27@CreateElem@2:

; 814  : 							for (int i = 0; i < ship->NumFlightDecks(); i++) {

  00e3e	8b c7		 mov	 eax, edi
  00e40	46		 inc	 esi
  00e41	e8 00 00 00 00	 call	 ?NumFlightDecks@Ship@@QBEHXZ ; Ship::NumFlightDecks
  00e46	3b f0		 cmp	 esi, eax
  00e48	7c dd		 jl	 SHORT $LL28@CreateElem@2
$LN26@CreateElem@2:

; 818  : 							}
; 819  : 						}
; 820  : 
; 821  : 						if (msn_ship) {

  00e4a	8b 74 24 30	 mov	 esi, DWORD PTR _msn_ship$118914[esp+452]
  00e4e	85 f6		 test	 esi, esi
  00e50	0f 84 46 01 00
	00		 je	 $LN9@CreateElem@2

; 822  : 							ship->SetVelocity(msn_ship->Velocity().OtherHand());

  00e56	8b 17		 mov	 edx, DWORD PTR [edi]
  00e58	f2 0f 10 46 38	 movsd	 xmm0, QWORD PTR [esi+56]
  00e5d	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00e65	f2 0f 10 4e 48	 movsd	 xmm1, QWORD PTR [esi+72]
  00e6a	f2 0f 10 56 40	 movsd	 xmm2, QWORD PTR [esi+64]
  00e6f	8b 52 6c	 mov	 edx, DWORD PTR [edx+108]
  00e72	8d 84 24 84 00
	00 00		 lea	 eax, DWORD PTR $T397706[esp+452]
  00e79	50		 push	 eax
  00e7a	8b cf		 mov	 ecx, edi
  00e7c	f2 0f 11 84 24
	88 00 00 00	 movsd	 QWORD PTR $T397706[esp+456], xmm0
  00e85	f2 0f 11 8c 24
	90 00 00 00	 movsd	 QWORD PTR $T397706[esp+464], xmm1
  00e8e	f2 0f 11 94 24
	98 00 00 00	 movsd	 QWORD PTR $T397706[esp+472], xmm2
  00e97	ff d2		 call	 edx

; 823  : 							ship->SetIntegrity((float) msn_ship->Integrity());

  00e99	8b 07		 mov	 eax, DWORD PTR [edi]
  00e9b	f2 0f 10 46 60	 movsd	 xmm0, QWORD PTR [esi+96]
  00ea0	8b 90 80 01 00
	00		 mov	 edx, DWORD PTR [eax+384]
  00ea6	51		 push	 ecx
  00ea7	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00eab	8b cf		 mov	 ecx, edi
  00ead	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00eb2	ff d2		 call	 edx

; 824  : 							ship->SetRespawnCount(msn_ship->Respawns());

  00eb4	8b 46 50	 mov	 eax, DWORD PTR [esi+80]

; 825  : 
; 826  : 							if (msn_ship->Ammo()[0] > -10) {

  00eb7	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  00eba	89 87 98 04 00
	00		 mov	 DWORD PTR [edi+1176], eax
  00ec0	83 39 f6	 cmp	 DWORD PTR [ecx], -10	; fffffff6H
  00ec3	7e 38		 jle	 SHORT $LN19@CreateElem@2

; 827  : 								for (int i = 0; i < 64; i++) {

  00ec5	33 c0		 xor	 eax, eax
  00ec7	89 4c 24 40	 mov	 DWORD PTR tv2640[esp+452], ecx
$LN22@CreateElem@2:

; 828  : 									Weapon* w = ship->GetWeaponByIndex(i+1);

  00ecb	8b 17		 mov	 edx, DWORD PTR [edi]
  00ecd	40		 inc	 eax
  00ece	89 44 24 58	 mov	 DWORD PTR tv2073[esp+452], eax
  00ed2	50		 push	 eax
  00ed3	8b 82 18 01 00
	00		 mov	 eax, DWORD PTR [edx+280]
  00ed9	8b cf		 mov	 ecx, edi
  00edb	ff d0		 call	 eax

; 829  : 									if (w)

  00edd	85 c0		 test	 eax, eax
  00edf	74 1c		 je	 SHORT $LN19@CreateElem@2

; 830  : 									w->SetAmmo(msn_ship->Ammo()[i]);

  00ee1	8b 4c 24 40	 mov	 ecx, DWORD PTR tv2640[esp+452]
  00ee5	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ee7	52		 push	 edx
  00ee8	8b f0		 mov	 esi, eax
  00eea	e8 00 00 00 00	 call	 ?SetAmmo@Weapon@@QAEXH@Z ; Weapon::SetAmmo
  00eef	8b 44 24 58	 mov	 eax, DWORD PTR tv2073[esp+452]
  00ef3	83 44 24 40 04	 add	 DWORD PTR tv2640[esp+452], 4
  00ef8	83 f8 40	 cmp	 eax, 64			; 00000040H
  00efb	7c ce		 jl	 SHORT $LN22@CreateElem@2
$LN19@CreateElem@2:

; 831  : 									else
; 832  : 									break;
; 833  : 								}
; 834  : 							}
; 835  : 
; 836  : 							if (msn_ship->Fuel()[0] > -10) {

  00efd	8b 44 24 30	 mov	 eax, DWORD PTR _msn_ship$118914[esp+452]
  00f01	05 b0 00 00 00	 add	 eax, 176		; 000000b0H
  00f06	83 38 f6	 cmp	 DWORD PTR [eax], -10	; fffffff6H
  00f09	7e 3f		 jle	 SHORT $LN14@CreateElem@2

; 837  : 								for (int i = 0; i < 4; i++) {

  00f0b	33 f6		 xor	 esi, esi
  00f0d	89 44 24 40	 mov	 DWORD PTR tv2675[esp+452], eax
$LL16@CreateElem@2:

; 838  : 									if (ship->Reactors().size() > i) {

  00f11	39 b7 90 03 00
	00		 cmp	 DWORD PTR [edi+912], esi
  00f17	7e 26		 jle	 SHORT $LN15@CreateElem@2

; 839  : 										PowerSource* p = ship->Reactors()[i];

  00f19	56		 push	 esi
  00f1a	8d 87 90 03 00
	00		 lea	 eax, DWORD PTR [edi+912]
  00f20	e8 00 00 00 00	 call	 ??A?$List@VPowerSource@@@@QAEAAPAVPowerSource@@H@Z ; List<PowerSource>::operator[]

; 840  : 										p->SetCapacity(msn_ship->Fuel()[i]);

  00f25	8b 4c 24 40	 mov	 ecx, DWORD PTR tv2675[esp+452]
  00f29	66 0f 6e 01	 movd	 xmm0, DWORD PTR [ecx]
  00f2d	8b 00		 mov	 eax, DWORD PTR [eax]
  00f2f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00f33	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00f37	f3 0f 11 80 84
	00 00 00	 movss	 DWORD PTR [eax+132], xmm0
$LN15@CreateElem@2:

; 837  : 								for (int i = 0; i < 4; i++) {

  00f3f	83 44 24 40 04	 add	 DWORD PTR tv2675[esp+452], 4
  00f44	46		 inc	 esi
  00f45	83 fe 04	 cmp	 esi, 4
  00f48	7c c7		 jl	 SHORT $LL16@CreateElem@2
$LN14@CreateElem@2:

; 841  : 									}
; 842  : 								}
; 843  : 							}
; 844  : 
; 845  : 							if (msn_ship->Decoys() > -10) {

  00f4a	8b 54 24 30	 mov	 edx, DWORD PTR _msn_ship$118914[esp+452]
  00f4e	83 7a 68 f6	 cmp	 DWORD PTR [edx+104], -10 ; fffffff6H
  00f52	7e 1f		 jle	 SHORT $LN11@CreateElem@2

; 846  : 								Weapon* w = ship->GetDecoy();

  00f54	8b 07		 mov	 eax, DWORD PTR [edi]
  00f56	8b 90 24 01 00
	00		 mov	 edx, DWORD PTR [eax+292]
  00f5c	8b cf		 mov	 ecx, edi
  00f5e	ff d2		 call	 edx

; 847  : 								if (w)

  00f60	85 c0		 test	 eax, eax
  00f62	74 0f		 je	 SHORT $LN11@CreateElem@2

; 848  : 								w->SetAmmo(msn_ship->Decoys());

  00f64	8b 4c 24 30	 mov	 ecx, DWORD PTR _msn_ship$118914[esp+452]
  00f68	8b 49 68	 mov	 ecx, DWORD PTR [ecx+104]
  00f6b	51		 push	 ecx
  00f6c	8b f0		 mov	 esi, eax
  00f6e	e8 00 00 00 00	 call	 ?SetAmmo@Weapon@@QAEXH@Z ; Weapon::SetAmmo
$LN11@CreateElem@2:

; 849  : 							}
; 850  : 
; 851  : 							if (msn_ship->Probes() > -10) {

  00f73	8b 54 24 30	 mov	 edx, DWORD PTR _msn_ship$118914[esp+452]
  00f77	83 7a 6c f6	 cmp	 DWORD PTR [edx+108], -10 ; fffffff6H
  00f7b	7e 1f		 jle	 SHORT $LN9@CreateElem@2

; 852  : 								Weapon* w = ship->GetProbeLauncher();

  00f7d	8b 07		 mov	 eax, DWORD PTR [edi]
  00f7f	8b 90 bc 01 00
	00		 mov	 edx, DWORD PTR [eax+444]
  00f85	8b cf		 mov	 ecx, edi
  00f87	ff d2		 call	 edx

; 853  : 								if (w)

  00f89	85 c0		 test	 eax, eax
  00f8b	74 0f		 je	 SHORT $LN9@CreateElem@2

; 854  : 								w->SetAmmo(msn_ship->Probes());

  00f8d	8b 4c 24 30	 mov	 ecx, DWORD PTR _msn_ship$118914[esp+452]
  00f91	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00f94	51		 push	 ecx
  00f95	8b f0		 mov	 esi, eax
  00f97	e8 00 00 00 00	 call	 ?SetAmmo@Weapon@@QAEXH@Z ; Weapon::SetAmmo
$LN9@CreateElem@2:

; 855  : 							}
; 856  : 						}
; 857  : 
; 858  : 						Shield* shield = ship->GetShield();

  00f9c	8b 8f 40 03 00
	00		 mov	 ecx, DWORD PTR [edi+832]

; 859  : 
; 860  : 						if (shield) {

  00fa2	85 c9		 test	 ecx, ecx
  00fa4	74 17		 je	 SHORT $LN8@CreateElem@2

; 861  : 							shield->SetPowerLevel(50);

  00fa6	8b 11		 mov	 edx, DWORD PTR [ecx]
  00fa8	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4049000000000000
  00fb0	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00fb3	83 ec 08	 sub	 esp, 8
  00fb6	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00fbb	ff d0		 call	 eax
$LN8@CreateElem@2:

; 862  : 						}
; 863  : 
; 864  : 						if (ship->Class() > Ship::FRIGATE) {

  00fbd	8b c7		 mov	 eax, edi
  00fbf	e8 00 00 00 00	 call	 ?Class@Ship@@QBE?AW4CLASSIFICATION@1@XZ ; Ship::Class
  00fc4	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00fc9	7e 5f		 jle	 SHORT $LN5@CreateElem@2

; 865  : 							ListIter<WeaponGroup> iter = ship->Weapons();

  00fcb	8d 8f 9c 03 00
	00		 lea	 ecx, DWORD PTR [edi+924]

; 866  : 							while (++iter) {

  00fd1	8d 94 24 ac 00
	00 00		 lea	 edx, DWORD PTR _iter$119066[esp+452]
  00fd8	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR _iter$119066[esp+452], ecx
  00fdf	c7 84 24 b0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR _iter$119066[esp+456], -1
  00fea	e8 00 00 00 00	 call	 ?next@?$ListIter@VWeaponGroup@@@@QAEPAVWeaponGroup@@XZ ; ListIter<WeaponGroup>::next
  00fef	85 c0		 test	 eax, eax
  00ff1	74 37		 je	 SHORT $LN5@CreateElem@2
$LL6@CreateElem@2:

; 867  : 								WeaponGroup* weapon = iter.value();

  00ff3	8d 84 24 ac 00
	00 00		 lea	 eax, DWORD PTR _iter$119066[esp+452]
  00ffa	e8 00 00 00 00	 call	 ?value@?$ListIter@VWeaponGroup@@@@QAEPAVWeaponGroup@@XZ ; ListIter<WeaponGroup>::value
  00fff	8b f0		 mov	 esi, eax

; 868  : 
; 869  : 								// anti-air weapon?
; 870  : 								if (weapon->GetDesign()->target_type & Ship::DRONE) {

  01001	e8 00 00 00 00	 call	 ?GetDesign@WeaponGroup@@QBEPAVWeaponDesign@@XZ ; WeaponGroup::GetDesign
  01006	f6 40 34 01	 test	 BYTE PTR [eax+52], 1
  0100a	74 07		 je	 SHORT $LN4@CreateElem@2

; 871  : 									weapon->SetFiringOrders(Weapon::POINT_DEFENSE);

  0100c	b8 02 00 00 00	 mov	 eax, 2

; 872  : 								}
; 873  : 								else {

  01011	eb 02		 jmp	 SHORT $LN656@CreateElem@2
$LN4@CreateElem@2:

; 874  : 									weapon->SetFiringOrders(Weapon::MANUAL);

  01013	33 c0		 xor	 eax, eax
$LN656@CreateElem@2:
  01015	e8 00 00 00 00	 call	 ?SetFiringOrders@WeaponGroup@@QAEXH@Z ; WeaponGroup::SetFiringOrders
  0101a	8d 94 24 ac 00
	00 00		 lea	 edx, DWORD PTR _iter$119066[esp+452]
  01021	e8 00 00 00 00	 call	 ?next@?$ListIter@VWeaponGroup@@@@QAEPAVWeaponGroup@@XZ ; ListIter<WeaponGroup>::next
  01026	85 c0		 test	 eax, eax
  01028	75 c9		 jne	 SHORT $LL6@CreateElem@2
$LN5@CreateElem@2:

; 875  : 								}
; 876  : 							}
; 877  : 						}
; 878  : 
; 879  : 						if (ship->Class() > Ship::DRONE && ship->Class() < Ship::STATION) {

  0102a	8b c7		 mov	 eax, edi
  0102c	e8 00 00 00 00	 call	 ?Class@Ship@@QBE?AW4CLASSIFICATION@1@XZ ; Ship::Class
  01031	83 f8 01	 cmp	 eax, 1
  01034	0f 8e c9 00 00
	00		 jle	 $LN1@CreateElem@2
  0103a	8b c7		 mov	 eax, edi
  0103c	e8 00 00 00 00	 call	 ?Class@Ship@@QBE?AW4CLASSIFICATION@1@XZ ; Ship::Class
  01041	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  01046	0f 8d b7 00 00
	00		 jge	 $LN1@CreateElem@2

; 880  : 							ShipStats* stats = ShipStats::Find(sname);

  0104c	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR _sname$118915[esp+452]
  01053	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  01058	8b f0		 mov	 esi, eax

; 881  : 							if (stats) {

  0105a	85 f6		 test	 esi, esi
  0105c	0f 84 a1 00 00
	00		 je	 $LN1@CreateElem@2

; 882  : 								char design[64];
; 883  : 								sprintf_s(design, "%s %s", ship->Abbreviation(), ship->Design()->display_name);

  01062	8b 87 00 02 00
	00		 mov	 eax, DWORD PTR [edi+512]
  01068	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  0106d	50		 push	 eax
  0106e	8b c7		 mov	 eax, edi
  01070	e8 00 00 00 00	 call	 ?Abbreviation@Ship@@QBEPBDXZ ; Ship::Abbreviation
  01075	50		 push	 eax
  01076	8d 94 24 44 01
	00 00		 lea	 edx, DWORD PTR _design$119076[esp+460]
  0107d	68 00 00 00 00	 push	 OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
  01082	52		 push	 edx
  01083	e8 00 00 00 00	 call	 ??$sprintf_s@$0EA@@@YAHAAY0EA@DPBDZZ ; sprintf_s<64>
  01088	83 c4 10	 add	 esp, 16			; 00000010H

; 884  : 								stats->SetType(design);

  0108b	8d 84 24 3c 01
	00 00		 lea	 eax, DWORD PTR _design$119076[esp+452]
  01092	8b ce		 mov	 ecx, esi
  01094	e8 00 00 00 00	 call	 ?SetType@ShipStats@@QAEXPBD@Z ; ShipStats::SetType

; 885  : 								stats->SetShipClass(ship->Class());

  01099	8b c7		 mov	 eax, edi
  0109b	e8 00 00 00 00	 call	 ?Class@Ship@@QBE?AW4CLASSIFICATION@1@XZ ; Ship::Class
  010a0	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 886  : 								stats->SetRole(Mission::RoleName(msn_elem->MissionRole()));

  010a3	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  010a6	e8 00 00 00 00	 call	 ?RoleName@Mission@@SAPBDH@Z ; Mission::RoleName
  010ab	8b ce		 mov	 ecx, esi
  010ad	e8 00 00 00 00	 call	 ?SetRole@ShipStats@@QAEXPBD@Z ; ShipStats::SetRole

; 887  : 								stats->SetIFF(ship->GetIFF());

  010b2	8b 07		 mov	 eax, DWORD PTR [edi]
  010b4	8b 90 98 01 00
	00		 mov	 edx, DWORD PTR [eax+408]
  010ba	8b cf		 mov	 ecx, edi
  010bc	ff d2		 call	 edx
  010be	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 888  : 								stats->SetRegion(msn_elem->Region());

  010c1	8b 43 68	 mov	 eax, DWORD PTR [ebx+104]
  010c4	8b ce		 mov	 ecx, esi
  010c6	e8 00 00 00 00	 call	 ?SetRegion@ShipStats@@QAEXPBD@Z ; ShipStats::SetRegion

; 889  : 								stats->SetCombatGroup(msn_elem->GetCombatGroup());

  010cb	8b 8b c8 00 00
	00		 mov	 ecx, DWORD PTR [ebx+200]
  010d1	8b c6		 mov	 eax, esi
  010d3	e8 00 00 00 00	 call	 ?SetCombatGroup@ShipStats@@QAEXPAVCombatGroup@@@Z ; ShipStats::SetCombatGroup

; 890  : 								stats->SetCombatUnit(msn_elem->GetCombatUnit());

  010d8	8b 8b cc 00 00
	00		 mov	 ecx, DWORD PTR [ebx+204]
  010de	e8 00 00 00 00	 call	 ?SetCombatUnit@ShipStats@@QAEXPAVCombatUnit@@@Z ; ShipStats::SetCombatUnit

; 891  : 								stats->SetPlayer(msn_elem->Player() == i+1);

  010e3	8b 4c 24 38	 mov	 ecx, DWORD PTR _i$118910[esp+452]
  010e7	41		 inc	 ecx
  010e8	39 4b 5c	 cmp	 DWORD PTR [ebx+92], ecx
  010eb	0f 94 c1	 sete	 cl
  010ee	e8 00 00 00 00	 call	 ?SetPlayer@ShipStats@@QAEX_N@Z ; ShipStats::SetPlayer

; 892  : 								stats->SetElementIndex(ship->GetElementIndex());

  010f3	8b c7		 mov	 eax, edi
  010f5	e8 00 00 00 00	 call	 ?GetElementIndex@Ship@@QBEHXZ ; Ship::GetElementIndex
  010fa	8b c8		 mov	 ecx, eax
  010fc	8b c6		 mov	 eax, esi
  010fe	e8 00 00 00 00	 call	 ?SetElementIndex@ShipStats@@QAEXH@Z ; ShipStats::SetElementIndex
$LN1@CreateElem@2:

; 893  : 							}
; 894  : 						}
; 895  : 					}  // ship
; 896  : 				}     // count

  01103	8d 8c 24 e4 00
	00 00		 lea	 ecx, DWORD PTR _rgn_name$118919[esp+452]
  0110a	c6 84 24 c0 01
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+460], 3
  01112	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  01117	8d 8c 24 d8 00
	00 00		 lea	 ecx, DWORD PTR _rnum$118917[esp+452]
  0111e	c6 84 24 c0 01
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+460], 2
  01126	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  0112b	8d 8c 24 b4 00
	00 00		 lea	 ecx, DWORD PTR _sname$118915[esp+452]
  01132	c7 84 24 c0 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+460], -1
  0113d	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
  01142	8b 44 24 38	 mov	 eax, DWORD PTR _i$118910[esp+452]
  01146	40		 inc	 eax
  01147	89 44 24 38	 mov	 DWORD PTR _i$118910[esp+452], eax
  0114b	3b 43 38	 cmp	 eax, DWORD PTR [ebx+56]
  0114e	0f 8c d2 f7 ff
	ff		 jl	 $LN56@CreateElem@2
$LN54@CreateElem@2:

; 484  : 	ListIter<MissionElement> e_iter = mission->GetElements();
; 485  : 	while (++e_iter) {

  01154	8d 94 24 a4 00
	00 00		 lea	 edx, DWORD PTR _e_iter$[esp+452]
  0115b	e8 00 00 00 00	 call	 ?next@?$ListIter@VMissionElement@@@@QAEPAVMissionElement@@XZ ; ListIter<MissionElement>::next
  01160	85 c0		 test	 eax, eax
  01162	0f 85 18 ef ff
	ff		 jne	 $LL634@CreateElem@2
$LN111@CreateElem@2:

; 897  : 			}
; 898  : 		}
; 899  : 	}
; 900  : }

  01168	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+452]
  0116f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01176	59		 pop	 ecx
  01177	5f		 pop	 edi
  01178	5e		 pop	 esi
  01179	5b		 pop	 ebx
  0117a	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+436]
  01181	33 cc		 xor	 ecx, esp
  01183	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01188	8b e5		 mov	 esp, ebp
  0118a	5d		 pop	 ebp
  0118b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateElements@Sim@@IAEXXZ$4:
  00000	68 60 02 00 00	 push	 608			; 00000260H
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR $T397684[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	c3		 ret	 0
__unwindfunclet$?CreateElements@Sim@@IAEXXZ$5:
  0001a	68 74 02 00 00	 push	 628			; 00000274H
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  00024	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR $T397688[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
  00033	c3		 ret	 0
__unwindfunclet$?CreateElements@Sim@@IAEXXZ$8:
  00034	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _sname$118915[ebp]
  0003a	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CreateElements@Sim@@IAEXXZ$9:
  0003f	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR _rnum$118917[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CreateElements@Sim@@IAEXXZ$10:
  0004a	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _rgn_name$118919[ebp]
  00050	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__ehhandler$?CreateElements@Sim@@IAEXXZ:
  00055	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00059	8d 82 4c fe ff
	ff		 lea	 eax, DWORD PTR [edx-436]
  0005f	8b 8a 48 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-440]
  00065	33 c8		 xor	 ecx, eax
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0006f	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00072	33 c8		 xor	 ecx, eax
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateElements@Sim@@IAEXXZ
  0007e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateElements@Sim@@IAEXXZ ENDP			; Sim::CreateElements
PUBLIC	?ExecMission@Sim@@QAEXXZ			; Sim::ExecMission
;	COMDAT xdata$x
; File c:\matrix games\dev\stars45\mission.h
xdata$x	SEGMENT
__unwindtable$?ExecMission@Sim@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecMission@Sim@@QAEXXZ$0
__ehfuncinfo$?ExecMission@Sim@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecMission@Sim@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?ExecMission@Sim@@QAEXXZ
_TEXT	SEGMENT
$T398656 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ExecMission@Sim@@QAEXXZ PROC				; Sim::ExecMission, COMDAT
; _this$ = esi

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ExecMission@Sim@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 354  : 	cam_dir = CameraDirector::GetInstance();

  00027	e8 00 00 00 00	 call	 ?GetInstance@CameraDirector@@SAPAV1@XZ ; CameraDirector::GetInstance
  0002c	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 355  : 
; 356  : 	if (!mission) {

  0002f	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00035	85 c0		 test	 eax, eax
  00037	75 1e		 jne	 SHORT $LN8@ExecMissio

; 357  : 		Print("Sim::ExecMission() - No mission to execute.\n");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@BNNLBOCC@Sim?3?3ExecMission?$CI?$CJ?5?9?5No?5mission?5@
  0003e	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00043	83 c4 04	 add	 esp, 4

; 401  : }

  00046	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00049	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00050	59		 pop	 ecx
  00051	5f		 pop	 edi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN8@ExecMissio:

; 358  : 		return;
; 359  : 	}
; 360  : 
; 361  : 	if (elements.size() || finished.size()) {

  00057	83 be 88 00 00
	00 00		 cmp	 DWORD PTR [esi+136], 0
  0005e	0f 85 4f 01 00
	00		 jne	 $LN6@ExecMissio
  00064	83 be 94 00 00
	00 00		 cmp	 DWORD PTR [esi+148], 0
  0006b	0f 85 42 01 00
	00		 jne	 $LN6@ExecMissio

; 363  : 		return;
; 364  : 	}
; 365  : 
; 366  : 	Print("\nExec Mission: '%s'\n", (const char*) mission->Name());

  00071	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [eax+148]
  00077	50		 push	 eax
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@INLOODOL@?6Exec?5Mission?3?5?8?$CFs?8?6?$AA@
  0007d	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 367  : 
; 368  : 	if (cam_dir)

  00082	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00085	83 c4 08	 add	 esp, 8
  00088	85 c9		 test	 ecx, ecx
  0008a	74 07		 je	 SHORT $LN5@ExecMissio

; 369  : 	cam_dir->Reset();

  0008c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008e	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00091	ff d2		 call	 edx
$LN5@ExecMissio:

; 370  : 
; 371  : 	if (mission->Stardate() > 0)

  00093	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00099	f2 0f 10 80 b0
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+176]
  000a1	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  000a9	76 12		 jbe	 SHORT $LN4@ExecMissio

; 372  : 	StarSystem::SetBaseTime(mission->Stardate(), true);

  000ab	83 ec 08	 sub	 esp, 8
  000ae	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000b3	6a 01		 push	 1
  000b5	e8 00 00 00 00	 call	 ?SetBaseTime@StarSystem@@SAXN_N@Z ; StarSystem::SetBaseTime
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@ExecMissio:

; 373  : 
; 374  : 	star_system = mission->GetStarSystem();

  000bd	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [esi+192]
  000c3	8b 89 dc 00 00
	00		 mov	 ecx, DWORD PTR [ecx+220]
  000c9	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 375  : 	star_system->Activate(scene);

  000cc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ce	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000d1	8d 5e 0c	 lea	 ebx, DWORD PTR [esi+12]
  000d4	53		 push	 ebx
  000d5	ff d0		 call	 eax

; 376  : 
; 377  : 	int dust_factor = 0;
; 378  : 
; 379  : 	if (Starshatter::GetInstance())

  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@Starshatter@@1PAV1@A ; Starshatter::instance
  000dc	33 ff		 xor	 edi, edi
  000de	85 c0		 test	 eax, eax
  000e0	74 06		 je	 SHORT $LN38@ExecMissio

; 380  : 	dust_factor = Starshatter::GetInstance()->Dust();

  000e2	8b b8 e8 a5 00
	00		 mov	 edi, DWORD PTR [eax+42472]
$LN38@ExecMissio:

; 381  : 
; 382  : 	if (star_system->NumDust() * dust_factor) {

  000e8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000eb	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  000f1	0f af c7	 imul	 eax, edi
  000f4	85 c0		 test	 eax, eax
  000f6	74 4e		 je	 SHORT $LN2@ExecMissio

; 383  : 		dust = new(__FILE__,__LINE__) Dust(star_system->NumDust() * 2*(dust_factor+1), dust_factor > 1);

  000f8	6a 78		 push	 120			; 00000078H
  000fa	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ff	83 c4 04	 add	 esp, 4
  00102	89 45 f0	 mov	 DWORD PTR $T398656[ebp], eax
  00105	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0010c	85 c0		 test	 eax, eax
  0010e	74 22		 je	 SHORT $LN11@ExecMissio
  00110	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00113	8b 8a 98 00 00
	00		 mov	 ecx, DWORD PTR [edx+152]
  00119	83 ff 01	 cmp	 edi, 1
  0011c	0f 9f c2	 setg	 dl
  0011f	47		 inc	 edi
  00120	0f af f9	 imul	 edi, ecx
  00123	0f b6 d2	 movzx	 edx, dl
  00126	52		 push	 edx
  00127	03 ff		 add	 edi, edi
  00129	57		 push	 edi
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ??0Dust@@QAE@H_N@Z	; Dust::Dust
  00130	eb 02		 jmp	 SHORT $LN12@ExecMissio
$LN11@ExecMissio:
  00132	33 c0		 xor	 eax, eax
$LN12@ExecMissio:
  00134	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 384  : 		scene.AddGraphic(dust);

  0013b	50		 push	 eax
  0013c	8b cb		 mov	 ecx, ebx
  0013e	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00141	e8 00 00 00 00	 call	 ?AddGraphic@Scene@@QAEXPAVGraphic@@@Z ; Scene::AddGraphic
$LN2@ExecMissio:

; 385  : 	}
; 386  : 
; 387  : 	CreateRegions();

  00146	56		 push	 esi
  00147	e8 00 00 00 00	 call	 ?CreateRegions@Sim@@IAEXXZ ; Sim::CreateRegions

; 388  : 	BuildLinks();

  0014c	56		 push	 esi
  0014d	e8 00 00 00 00	 call	 ?BuildLinks@Sim@@IAEXXZ	; Sim::BuildLinks

; 389  : 	CreateElements();

  00152	56		 push	 esi
  00153	e8 00 00 00 00	 call	 ?CreateElements@Sim@@IAEXXZ ; Sim::CreateElements

; 390  : 	CopyEvents();

  00158	8b ce		 mov	 ecx, esi
  0015a	e8 00 00 00 00	 call	 ?CopyEvents@Sim@@IAEXXZ	; Sim::CopyEvents

; 391  : 
; 392  : 	if (netgame) {

  0015f	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  00165	85 c9		 test	 ecx, ecx
  00167	74 12		 je	 SHORT $LN1@ExecMissio

; 393  : 		delete netgame;

  00169	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016b	8b 10		 mov	 edx, DWORD PTR [eax]
  0016d	6a 01		 push	 1
  0016f	ff d2		 call	 edx

; 394  : 		netgame = 0;

  00171	c7 86 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+196], 0
$LN1@ExecMissio:

; 395  : 	}
; 396  : 
; 397  : 	first_frame = true;

  0017b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _first_frame, 1

; 398  : 	start_time  = Game::GameTime();

  00182	e8 00 00 00 00	 call	 ?GameTime@Game@@SAKXZ	; Game::GameTime
  00187	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax

; 399  : 
; 400  : 	AudioConfig::SetTraining(mission->Type() == Mission::TRAINING);

  0018d	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00193	83 b8 a4 00 00
	00 16		 cmp	 DWORD PTR [eax+164], 22	; 00000016H
  0019a	0f 94 c1	 sete	 cl
  0019d	e8 00 00 00 00	 call	 ?SetTraining@AudioConfig@@SAX_N@Z ; AudioConfig::SetTraining

; 401  : }

  001a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ac	59		 pop	 ecx
  001ad	5f		 pop	 edi
  001ae	5b		 pop	 ebx
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
$LN6@ExecMissio:

; 362  : 		Print("Sim::ExecMission(%s) mission is already executing.\n", mission->Name());

  001b3	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  001b9	51		 push	 ecx
  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@LJMJJDEL@Sim?3?3ExecMission?$CI?$CFs?$CJ?5mission?5is?5@
  001bf	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  001c4	83 c4 08	 add	 esp, 8

; 401  : }

  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	5f		 pop	 edi
  001d3	5b		 pop	 ebx
  001d4	8b e5		 mov	 esp, ebp
  001d6	5d		 pop	 ebp
  001d7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecMission@Sim@@QAEXXZ$0:
  00000	68 7f 01 00 00	 push	 383			; 0000017fH
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_07MHJMBJCP@Sim?4cpp?$AA@
  0000a	8b 45 f0	 mov	 eax, DWORD PTR $T398656[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXPBDH@Z	; operator delete
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c3		 ret	 0
__ehhandler$?ExecMission@Sim@@QAEXXZ:
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ExecMission@Sim@@QAEXXZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ExecMission@Sim@@QAEXXZ ENDP				; Sim::ExecMission
PUBLIC	?ResolveTimeSkip@SimRegion@@QAEXN@Z		; SimRegion::ResolveTimeSkip
; Function compile flags: /Ogtp
;	COMDAT ?ResolveTimeSkip@SimRegion@@QAEXN@Z
_TEXT	SEGMENT
tv1346 = -168						; size = 8
tv1320 = -168						; size = 8
tv864 = -168						; size = 4
_ward$121317 = -168					; size = 4
$T405749 = -160						; size = 24
_ward_heading$121376 = -160				; size = 24
$T405741 = -160						; size = 24
$T405740 = -160						; size = 24
_delta$121349 = -160					; size = 24
_i$121312 = -132					; size = 4
_speed$121340 = -128					; size = 8
_contact$121319 = -120					; size = 8
_dest$121338 = -112					; size = 24
$T405751 = -88						; size = 24
$T405745 = -88						; size = 24
$T405742 = -88						; size = 24
$T405731 = -88						; size = 24
_unit$121360 = -64					; size = 24
_dist$121361 = -40					; size = 8
_space$121341 = -32					; size = 8
_trans$121366 = -24					; size = 24
_this$ = 8						; size = 4
_seconds$ = 12						; size = 8
?ResolveTimeSkip@SimRegion@@QAEXN@Z PROC		; SimRegion::ResolveTimeSkip, COMDAT

; 3611 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H

; 3612 : 	for (int i = 0; i < ships.size(); i++) {

  0000c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0000f	53		 push	 ebx
  00010	33 c9		 xor	 ecx, ecx
  00012	8d 42 4c	 lea	 eax, DWORD PTR [edx+76]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 4c 24 3c	 mov	 DWORD PTR _i$121312[esp+192], ecx
  0001b	39 08		 cmp	 DWORD PTR [eax], ecx
  0001d	0f 8e 65 07 00
	00		 jle	 $LN34@ResolveTim
$LL36@ResolveTim:

; 3613 : 		Ship* ship = ships[i];

  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??A?$List@VShip@@@@QAEAAPAVShip@@H@Z ; List<Ship>::operator[]
  00029	8b 38		 mov	 edi, DWORD PTR [eax]

; 3614 : 		Ship* ward = ship->GetWard();

  0002b	8b 87 1c 03 00
	00		 mov	 eax, DWORD PTR [edi+796]

; 3615 : 
; 3616 : 		// remember to burn fuel and fix stuff...
; 3617 : 		ship->ExecSystems(seconds);

  00031	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  00036	83 ec 08	 sub	 esp, 8
  00039	89 44 24 20	 mov	 DWORD PTR _ward$121317[esp+200], eax
  0003d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00042	e8 00 00 00 00	 call	 ?ExecSystems@Ship@@QAEXN@Z ; Ship::ExecSystems

; 3618 : 		ship->ExecMaintFrame(seconds);

  00047	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  0004c	83 ec 08	 sub	 esp, 8
  0004f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ?ExecMaintFrame@Ship@@QAEXN@Z ; Ship::ExecMaintFrame

; 3619 : 
; 3620 : 		ship->ClearTrack();

  0005a	8b f7		 mov	 esi, edi
  0005c	e8 00 00 00 00	 call	 ?ClearTrack@Ship@@QAEXXZ ; Ship::ClearTrack

; 3621 : 		ListIter<Contact> contact = ship->ContactList();

  00061	e8 00 00 00 00	 call	 ?ContactList@Ship@@QAEAAV?$List@VContact@@@@XZ ; Ship::ContactList

; 3622 : 		while (++contact)

  00066	8d 54 24 48	 lea	 edx, DWORD PTR _contact$121319[esp+192]
  0006a	89 44 24 48	 mov	 DWORD PTR _contact$121319[esp+192], eax
  0006e	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR _contact$121319[esp+196], -1
  00076	e8 00 00 00 00	 call	 ?next@?$ListIter@VContact@@@@QAEPAVContact@@XZ ; ListIter<Contact>::next
  0007b	85 c0		 test	 eax, eax
  0007d	74 1e		 je	 SHORT $LN32@ResolveTim
  0007f	90		 npad	 1
$LL33@ResolveTim:

; 3623 : 		contact->ClearTrack();

  00080	8d 44 24 48	 lea	 eax, DWORD PTR _contact$121319[esp+192]
  00084	e8 00 00 00 00	 call	 ?value@?$ListIter@VContact@@@@QAEPAVContact@@XZ ; ListIter<Contact>::value
  00089	8b f0		 mov	 esi, eax
  0008b	e8 00 00 00 00	 call	 ?ClearTrack@Contact@@QAEXXZ ; Contact::ClearTrack
  00090	8d 54 24 48	 lea	 edx, DWORD PTR _contact$121319[esp+192]
  00094	e8 00 00 00 00	 call	 ?next@?$ListIter@VContact@@@@QAEPAVContact@@XZ ; ListIter<Contact>::next
  00099	85 c0		 test	 eax, eax
  0009b	75 e3		 jne	 SHORT $LL33@ResolveTim
$LN32@ResolveTim:

; 3624 : 
; 3625 : 		if (ship->IsStatic())

  0009d	8b c7		 mov	 eax, edi
  0009f	e8 00 00 00 00	 call	 ?IsStatic@Ship@@QBE_NXZ	; Ship::IsStatic
  000a4	84 c0		 test	 al, al
  000a6	0f 85 c5 06 00
	00		 jne	 $LN35@ResolveTim

; 3626 : 		continue;
; 3627 : 
; 3628 : 		// if ship is cleared inbound, land him:
; 3629 : 		InboundSlot* inbound = ship->GetInbound();

  000ac	8b 9f 34 04 00
	00		 mov	 ebx, DWORD PTR [edi+1076]

; 3630 : 		if (inbound) {

  000b2	85 db		 test	 ebx, ebx
  000b4	74 4a		 je	 SHORT $LN30@ResolveTim

; 3631 : 			if (inbound->Cleared()) {

  000b6	83 7b 20 00	 cmp	 DWORD PTR [ebx+32], 0
  000ba	0f 84 b1 06 00
	00		 je	 $LN35@ResolveTim

; 3632 : 				FlightDeck* deck = inbound->GetDeck();

  000c0	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 3633 : 
; 3634 : 				if (deck) {

  000c3	85 f6		 test	 esi, esi
  000c5	0f 84 a6 06 00
	00		 je	 $LN35@ResolveTim

; 3635 : 					ship->SetCarrier((Ship*) deck->GetCarrier(), deck);

  000cb	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  000d1	56		 push	 esi
  000d2	8b cf		 mov	 ecx, edi
  000d4	e8 00 00 00 00	 call	 ?SetCarrier@Ship@@QAEXPAV1@PAVFlightDeck@@@Z ; Ship::SetCarrier

; 3636 : 					ship->SetFlightPhase(Ship::DOCKED);

  000d9	8b 17		 mov	 edx, DWORD PTR [edi]
  000db	8b 82 d8 00 00
	00		 mov	 eax, DWORD PTR [edx+216]
  000e1	6a 00		 push	 0
  000e3	8b cf		 mov	 ecx, edi
  000e5	ff d0		 call	 eax

; 3637 : 					ship->Stow();

  000e7	8b d7		 mov	 edx, edi
  000e9	e8 00 00 00 00	 call	 ?Stow@Ship@@QAEXXZ	; Ship::Stow

; 3638 : 					deck->Clear(inbound->Index());

  000ee	8b 16		 mov	 edx, DWORD PTR [esi]
  000f0	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000f3	8b 52 58	 mov	 edx, DWORD PTR [edx+88]
  000f6	50		 push	 eax
  000f7	8b ce		 mov	 ecx, esi
  000f9	ff d2		 call	 edx

; 3639 : 				}
; 3640 : 			}
; 3641 : 
; 3642 : 			// cleared or not, once you're inbound, don't seek navpoints:
; 3643 : 			continue;

  000fb	e9 71 06 00 00	 jmp	 $LN35@ResolveTim
$LN30@ResolveTim:

; 3644 : 		}
; 3645 : 
; 3646 : 		if (ship->GetHangar()) {

  00100	8b 8f 68 03 00
	00		 mov	 ecx, DWORD PTR [edi+872]
  00106	85 c9		 test	 ecx, ecx
  00108	74 51		 je	 SHORT $LN24@ResolveTim

; 3647 : 			ship->GetHangar()->ExecFrame(seconds);

  0010a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010c	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  00111	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00114	83 ec 08	 sub	 esp, 8
  00117	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011c	ff d2		 call	 edx

; 3648 : 
; 3649 : 			List<FlightDeck>& flight_decks = ship->FlightDecks();
; 3650 : 			for (int n = 0; n < flight_decks.size(); n++)

  0011e	33 f6		 xor	 esi, esi
  00120	39 b7 c0 03 00
	00		 cmp	 DWORD PTR [edi+960], esi
  00126	7e 33		 jle	 SHORT $LN24@ResolveTim
  00128	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL26@ResolveTim:

; 3651 : 			flight_decks[n]->ExecFrame(seconds);

  00130	56		 push	 esi
  00131	8d 87 c0 03 00
	00		 lea	 eax, DWORD PTR [edi+960]
  00137	e8 00 00 00 00	 call	 ??A?$List@VFlightDeck@@@@QAEAAPAVFlightDeck@@H@Z ; List<FlightDeck>::operator[]
  0013c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00140	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  00145	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00148	83 ec 08	 sub	 esp, 8
  0014b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00150	ff d2		 call	 edx
  00152	46		 inc	 esi
  00153	3b b7 c0 03 00
	00		 cmp	 esi, DWORD PTR [edi+960]
  00159	7c d5		 jl	 SHORT $LL26@ResolveTim
$LN24@ResolveTim:

; 3652 : 		}
; 3653 : 
; 3654 : 		Instruction* navpt = ship->GetNextNavPoint();

  0015b	8b cf		 mov	 ecx, edi
  0015d	e8 00 00 00 00	 call	 ?GetNextNavPoint@Ship@@QAEPAVInstruction@@XZ ; Ship::GetNextNavPoint

; 3655 : 		Point        dest  = ship->Location();

  00162	f2 0f 10 47 48	 movsd	 xmm0, QWORD PTR [edi+72]
  00167	f2 0f 11 44 24
	50		 movsd	 QWORD PTR _dest$121338[esp+192], xmm0
  0016d	f2 0f 10 47 50	 movsd	 xmm0, QWORD PTR [edi+80]
  00172	f2 0f 11 44 24
	58		 movsd	 QWORD PTR _dest$121338[esp+200], xmm0
  00178	f2 0f 10 47 58	 movsd	 xmm0, QWORD PTR [edi+88]
  0017d	8b d8		 mov	 ebx, eax
  0017f	f2 0f 11 44 24
	60		 movsd	 QWORD PTR _dest$121338[esp+208], xmm0

; 3656 : 		double       speed = 500;

  00185	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@407f400000000000

; 3657 : 		double       space = 2.0e3 * (ship->GetElementIndex() - 1);

  0018d	8b c7		 mov	 eax, edi
  0018f	f2 0f 11 44 24
	40		 movsd	 QWORD PTR _speed$121340[esp+192], xmm0
  00195	e8 00 00 00 00	 call	 ?GetElementIndex@Ship@@QBEHXZ ; Ship::GetElementIndex
  0019a	48		 dec	 eax
  0019b	0f 57 c0	 xorps	 xmm0, xmm0
  0019e	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  001a2	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@409f400000000000

; 3658 : 
; 3659 : 		if (ship->IsStarship())

  001aa	8b c7		 mov	 eax, edi
  001ac	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR _space$121341[esp+192], xmm0
  001b5	e8 00 00 00 00	 call	 ?IsStarship@Ship@@QBE_NXZ ; Ship::IsStarship
  001ba	84 c0		 test	 al, al
  001bc	74 11		 je	 SHORT $LN23@ResolveTim

; 3660 : 		space *= 5;

  001be	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4014000000000000
  001c6	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR _space$121341[esp+192], xmm0
$LN23@ResolveTim:

; 3661 : 
; 3662 : 		if (navpt && navpt->Action() == Instruction::LAUNCH) {

  001cf	85 db		 test	 ebx, ebx
  001d1	74 75		 je	 SHORT $LN21@ResolveTim
  001d3	83 7b 70 01	 cmp	 DWORD PTR [ebx+112], 1
  001d7	75 14		 jne	 SHORT $LN22@ResolveTim

; 3663 : 			ship->SetNavptStatus(navpt, Instruction::COMPLETE);

  001d9	6a 05		 push	 5
  001db	8b c3		 mov	 eax, ebx
  001dd	8b f7		 mov	 esi, edi
  001df	e8 00 00 00 00	 call	 ?SetNavptStatus@Ship@@QAEXPAVInstruction@@H@Z ; Ship::SetNavptStatus

; 3664 : 			navpt = ship->GetNextNavPoint();

  001e4	8b cf		 mov	 ecx, edi
  001e6	e8 00 00 00 00	 call	 ?GetNextNavPoint@Ship@@QAEPAVInstruction@@XZ ; Ship::GetNextNavPoint
  001eb	8b d8		 mov	 ebx, eax
$LN22@ResolveTim:

; 3665 : 		}
; 3666 : 
; 3667 : 		if (navpt) {

  001ed	85 db		 test	 ebx, ebx
  001ef	74 57		 je	 SHORT $LN21@ResolveTim

; 3668 : 			dest  = navpt->Location().OtherHand();

  001f1	8d 74 24 68	 lea	 esi, DWORD PTR $T405731[esp+192]
  001f5	8b cb		 mov	 ecx, ebx
  001f7	e8 00 00 00 00	 call	 ?Location@Instruction@@QBE?AUPoint@@XZ ; Instruction::Location
  001fc	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00200	f2 0f 10 48 10	 movsd	 xmm1, QWORD PTR [eax+16]
  00205	f2 0f 10 50 08	 movsd	 xmm2, QWORD PTR [eax+8]
  0020a	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@

; 3669 : 			speed = navpt->Speed();

  00212	8b 74 24 18	 mov	 esi, DWORD PTR _ward$121317[esp+192]
  00216	66 0f 28 d8	 movapd	 xmm3, xmm0
  0021a	66 0f 28 e1	 movapd	 xmm4, xmm1
  0021e	66 0f 28 ea	 movapd	 xmm5, xmm2
  00222	f2 0f 11 5c 24
	50		 movsd	 QWORD PTR _dest$121338[esp+192], xmm3
  00228	f2 0f 11 64 24
	58		 movsd	 QWORD PTR _dest$121338[esp+200], xmm4
  0022e	f2 0f 11 6c 24
	60		 movsd	 QWORD PTR _dest$121338[esp+208], xmm5
  00234	66 0f 6e 43 7c	 movd	 xmm0, DWORD PTR [ebx+124]
  00239	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0023d	f2 0f 11 44 24
	40		 movsd	 QWORD PTR _speed$121340[esp+192], xmm0
  00243	e9 cd 00 00 00	 jmp	 $LN115@ResolveTim
$LN21@ResolveTim:

; 3670 : 		}
; 3671 : 
; 3672 : 		else if (ward) {

  00248	8b 74 24 18	 mov	 esi, DWORD PTR _ward$121317[esp+192]
  0024c	85 f6		 test	 esi, esi
  0024e	0f 84 af 00 00
	00		 je	 $LN235@ResolveTim

; 3673 : 			Point delta = ship->Location() - ward->Location();

  00254	f2 0f 10 47 48	 movsd	 xmm0, QWORD PTR [edi+72]
  00259	f2 0f 5c 46 48	 subsd	 xmm0, QWORD PTR [esi+72]

; 3674 : 			delta.y = 0;

  0025e	0f 57 d2	 xorps	 xmm2, xmm2
  00261	f2 0f 10 5e 58	 movsd	 xmm3, QWORD PTR [esi+88]
  00266	f2 0f 10 4f 58	 movsd	 xmm1, QWORD PTR [edi+88]
  0026b	f2 0f 11 44 24
	20		 movsd	 QWORD PTR _delta$121349[esp+192], xmm0
  00271	f2 0f 5c cb	 subsd	 xmm1, xmm3

; 3675 : 
; 3676 : 			if (delta.length() > 25e3) {

  00275	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00279	f2 0f 11 54 24
	28		 movsd	 QWORD PTR _delta$121349[esp+200], xmm2
  0027f	f2 0f 11 4c 24
	30		 movsd	 QWORD PTR _delta$121349[esp+208], xmm1
  00285	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  00289	f2 0f 58 c2	 addsd	 xmm0, xmm2
  0028d	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00291	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00295	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  00299	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@40d86a0000000000
  002a1	76 60		 jbe	 SHORT $LN235@ResolveTim

; 3677 : 				delta.Normalize();

  002a3	8d 4c 24 20	 lea	 ecx, DWORD PTR _delta$121349[esp+192]
  002a7	e8 00 00 00 00	 call	 ?Normalize@Point@@QAENXZ ; Point::Normalize
  002ac	dd d8		 fstp	 ST(0)

; 3678 : 				dest = ward->Location() + delta * 25e3;

  002ae	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@40d86a0000000000
  002b6	f2 0f 10 66 50	 movsd	 xmm4, QWORD PTR [esi+80]
  002bb	f2 0f 10 6e 58	 movsd	 xmm5, QWORD PTR [esi+88]
  002c0	f2 0f 10 44 24
	20		 movsd	 xmm0, QWORD PTR _delta$121349[esp+192]
  002c6	f2 0f 10 4c 24
	28		 movsd	 xmm1, QWORD PTR _delta$121349[esp+200]
  002cc	f2 0f 10 54 24
	30		 movsd	 xmm2, QWORD PTR _delta$121349[esp+208]
  002d2	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  002d6	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  002da	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  002de	f2 0f 10 5e 48	 movsd	 xmm3, QWORD PTR [esi+72]
  002e3	f2 0f 58 d8	 addsd	 xmm3, xmm0
  002e7	f2 0f 58 e1	 addsd	 xmm4, xmm1
  002eb	f2 0f 58 ea	 addsd	 xmm5, xmm2
  002ef	f2 0f 11 5c 24
	50		 movsd	 QWORD PTR _dest$121338[esp+192], xmm3
  002f5	f2 0f 11 64 24
	58		 movsd	 QWORD PTR _dest$121338[esp+200], xmm4
  002fb	f2 0f 11 6c 24
	60		 movsd	 QWORD PTR _dest$121338[esp+208], xmm5
  00301	eb 12		 jmp	 SHORT $LN115@ResolveTim
$LN235@ResolveTim:
  00303	f2 0f 10 64 24
	58		 movsd	 xmm4, QWORD PTR _dest$121338[esp+200]
  00309	f2 0f 10 6c 24
	60		 movsd	 xmm5, QWORD PTR _dest$121338[esp+208]
  0030f	f2 0f 10 5c 24
	50		 movsd	 xmm3, QWORD PTR _dest$121338[esp+192]
$LN115@ResolveTim:

; 3679 : 			}
; 3680 : 		}
; 3681 : 
; 3682 : 		Point    delta = dest - ship->Location();

  00315	f2 0f 5c 5f 48	 subsd	 xmm3, QWORD PTR [edi+72]
  0031a	f2 0f 5c 67 50	 subsd	 xmm4, QWORD PTR [edi+80]
  0031f	f2 0f 5c 6f 58	 subsd	 xmm5, QWORD PTR [edi+88]
  00324	66 0f 28 c3	 movapd	 xmm0, xmm3
  00328	66 0f 28 cc	 movapd	 xmm1, xmm4
  0032c	66 0f 28 d5	 movapd	 xmm2, xmm5

; 3683 : 		Point    unit  = delta;
; 3684 : 		double   dist  = unit.Normalize() - space;

  00330	8d 8c 24 80 00
	00 00		 lea	 ecx, DWORD PTR _unit$121360[esp+192]
  00337	f2 0f 11 84 24
	80 00 00 00	 movsd	 QWORD PTR _unit$121360[esp+192], xmm0
  00340	f2 0f 11 8c 24
	88 00 00 00	 movsd	 QWORD PTR _unit$121360[esp+200], xmm1
  00349	f2 0f 11 94 24
	90 00 00 00	 movsd	 QWORD PTR _unit$121360[esp+208], xmm2
  00352	e8 00 00 00 00	 call	 ?Normalize@Point@@QAENXZ ; Point::Normalize
  00357	dc a4 24 a0 00
	00 00		 fsub	 QWORD PTR _space$121341[esp+192]
  0035e	dd 94 24 98 00
	00 00		 fst	 QWORD PTR _dist$121361[esp+192]

; 3685 : 
; 3686 : 		if (dist > 1e3) {

  00365	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@408f400000000000
  0036b	d9 c9		 fxch	 ST(1)
  0036d	df f1		 fcomip	 ST(1)
  0036f	dd d8		 fstp	 ST(0)
  00371	0f 86 74 01 00
	00		 jbe	 $LN17@ResolveTim

; 3687 : 			if (speed < 50)

  00377	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4049000000000000
  0037f	f2 0f 10 4c 24
	40		 movsd	 xmm1, QWORD PTR _speed$121340[esp+192]
  00385	66 0f 2f c1	 comisd	 xmm0, xmm1
  00389	76 0e		 jbe	 SHORT $LN16@ResolveTim

; 3688 : 			speed = 500;

  0038b	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@407f400000000000
  00393	f2 0f 11 4c 24
	40		 movsd	 QWORD PTR _speed$121340[esp+192], xmm1
$LN16@ResolveTim:

; 3689 : 
; 3690 : 			double etr = dist / speed;

  00399	f2 0f 10 84 24
	98 00 00 00	 movsd	 xmm0, QWORD PTR _dist$121361[esp+192]

; 3691 : 
; 3692 : 			if (etr > seconds)

  003a2	f2 0f 10 55 0c	 movsd	 xmm2, QWORD PTR _seconds$[ebp]
  003a7	f2 0f 5e c1	 divsd	 xmm0, xmm1
  003ab	66 0f 2f c2	 comisd	 xmm0, xmm2
  003af	76 04		 jbe	 SHORT $LN15@ResolveTim

; 3693 : 			etr = seconds;

  003b1	66 0f 28 c2	 movapd	 xmm0, xmm2
$LN15@ResolveTim:

; 3694 : 
; 3695 : 			Point trans = unit * (speed * etr);

  003b5	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  003b9	66 0f 28 c8	 movapd	 xmm1, xmm0
  003bd	f2 0f 59 8c 24
	80 00 00 00	 mulsd	 xmm1, QWORD PTR _unit$121360[esp+192]
  003c6	f2 0f 11 8c 24
	a8 00 00 00	 movsd	 QWORD PTR _trans$121366[esp+192], xmm1
  003cf	f2 0f 10 8c 24
	88 00 00 00	 movsd	 xmm1, QWORD PTR _unit$121360[esp+200]
  003d8	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  003dc	f2 0f 11 8c 24
	b0 00 00 00	 movsd	 QWORD PTR _trans$121366[esp+200], xmm1
  003e5	f2 0f 10 8c 24
	90 00 00 00	 movsd	 xmm1, QWORD PTR _unit$121360[esp+208]
  003ee	f2 0f 59 c8	 mulsd	 xmm1, xmm0

; 3696 : 
; 3697 : 			if (ship->GetFuelLevel() > 1) {

  003f2	8b c7		 mov	 eax, edi
  003f4	f2 0f 11 8c 24
	b8 00 00 00	 movsd	 QWORD PTR _trans$121366[esp+208], xmm1
  003fd	e8 00 00 00 00	 call	 ?GetFuelLevel@Ship@@QBEHXZ ; Ship::GetFuelLevel
  00402	83 f8 01	 cmp	 eax, 1
  00405	0f 8e 97 00 00
	00		 jle	 $LN14@ResolveTim

; 3698 : 				ship->MoveTo(ship->Location() + trans);

  0040b	8b 07		 mov	 eax, DWORD PTR [edi]
  0040d	f2 0f 10 47 48	 movsd	 xmm0, QWORD PTR [edi+72]
  00412	f2 0f 10 4f 50	 movsd	 xmm1, QWORD PTR [edi+80]
  00417	f2 0f 10 57 58	 movsd	 xmm2, QWORD PTR [edi+88]
  0041c	f2 0f 58 84 24
	a8 00 00 00	 addsd	 xmm0, QWORD PTR _trans$121366[esp+192]
  00425	f2 0f 58 8c 24
	b0 00 00 00	 addsd	 xmm1, QWORD PTR _trans$121366[esp+200]
  0042e	f2 0f 58 94 24
	b8 00 00 00	 addsd	 xmm2, QWORD PTR _trans$121366[esp+208]
  00437	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0043a	8d 4c 24 20	 lea	 ecx, DWORD PTR $T405740[esp+192]
  0043e	51		 push	 ecx
  0043f	8b cf		 mov	 ecx, edi
  00441	f2 0f 11 44 24
	24		 movsd	 QWORD PTR $T405740[esp+196], xmm0
  00447	f2 0f 11 4c 24
	2c		 movsd	 QWORD PTR $T405740[esp+204], xmm1
  0044d	f2 0f 11 54 24
	34		 movsd	 QWORD PTR $T405740[esp+212], xmm2
  00453	ff d2		 call	 edx

; 3699 : 				ship->SetVelocity(unit * speed);

  00455	f2 0f 10 44 24
	40		 movsd	 xmm0, QWORD PTR _speed$121340[esp+192]
  0045b	f2 0f 10 8c 24
	80 00 00 00	 movsd	 xmm1, QWORD PTR _unit$121360[esp+192]
  00464	8b 07		 mov	 eax, DWORD PTR [edi]
  00466	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  00469	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0046d	f2 0f 11 4c 24
	20		 movsd	 QWORD PTR $T405741[esp+192], xmm1
  00473	f2 0f 10 8c 24
	88 00 00 00	 movsd	 xmm1, QWORD PTR _unit$121360[esp+200]
  0047c	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00480	f2 0f 11 4c 24
	28		 movsd	 QWORD PTR $T405741[esp+200], xmm1
  00486	f2 0f 10 8c 24
	90 00 00 00	 movsd	 xmm1, QWORD PTR _unit$121360[esp+208]
  0048f	8d 4c 24 20	 lea	 ecx, DWORD PTR $T405741[esp+192]
  00493	51		 push	 ecx
  00494	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00498	8b cf		 mov	 ecx, edi
  0049a	f2 0f 11 4c 24
	34		 movsd	 QWORD PTR $T405741[esp+212], xmm1
  004a0	ff d2		 call	 edx
$LN14@ResolveTim:

; 3700 : 			}
; 3701 : 			ship->LookAt(dest);

  004a2	8b 07		 mov	 eax, DWORD PTR [edi]
  004a4	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  004a7	8d 4c 24 50	 lea	 ecx, DWORD PTR _dest$121338[esp+192]
  004ab	51		 push	 ecx
  004ac	8b cf		 mov	 ecx, edi
  004ae	ff d2		 call	 edx

; 3702 : 
; 3703 : 			if (ship->IsStarship()) {

  004b0	8b c7		 mov	 eax, edi
  004b2	e8 00 00 00 00	 call	 ?IsStarship@Ship@@QBE_NXZ ; Ship::IsStarship
  004b7	84 c0		 test	 al, al
  004b9	74 49		 je	 SHORT $LN11@ResolveTim

; 3704 : 				ship->SetFLCSMode(Ship::FLCS_HELM);

  004bb	6a 02		 push	 2
  004bd	8b c7		 mov	 eax, edi
  004bf	e8 00 00 00 00	 call	 ?SetFLCSMode@Ship@@QAEXH@Z ; Ship::SetFLCSMode

; 3705 : 				ship->SetHelmHeading(ship->CompassHeading());

  004c4	8b c7		 mov	 eax, edi
  004c6	e8 00 00 00 00	 call	 ?CompassHeading@Ship@@QBENXZ ; Ship::CompassHeading
  004cb	57		 push	 edi
  004cc	e8 00 00 00 00	 call	 ?SetHelmHeading@Ship@@QAEXN@Z ; Ship::SetHelmHeading

; 3706 : 				ship->SetHelmPitch(ship->CompassPitch());

  004d1	8b c7		 mov	 eax, edi
  004d3	e8 00 00 00 00	 call	 ?CompassPitch@Ship@@QBENXZ ; Ship::CompassPitch
  004d8	dd 5c 24 18	 fstp	 QWORD PTR tv1346[esp+192]
  004dc	f2 0f 10 54 24
	18		 movsd	 xmm2, QWORD PTR tv1346[esp+192]
  004e2	8b c7		 mov	 eax, edi
  004e4	e8 00 00 00 00	 call	 ?SetHelmPitch@Ship@@QAEXN@Z ; Ship::SetHelmPitch

; 3707 : 			}
; 3708 : 		}

  004e9	eb 19		 jmp	 SHORT $LN11@ResolveTim
$LN17@ResolveTim:

; 3709 : 
; 3710 : 		else if (navpt && navpt->Status() <= Instruction::ACTIVE) {

  004eb	85 db		 test	 ebx, ebx
  004ed	74 15		 je	 SHORT $LN11@ResolveTim
  004ef	83 7b 78 01	 cmp	 DWORD PTR [ebx+120], 1
  004f3	7f 0f		 jg	 SHORT $LN11@ResolveTim

; 3711 : 			ship->SetNavptStatus(navpt, Instruction::COMPLETE);

  004f5	6a 05		 push	 5
  004f7	8b c3		 mov	 eax, ebx
  004f9	8b f7		 mov	 esi, edi
  004fb	e8 00 00 00 00	 call	 ?SetNavptStatus@Ship@@QAEXPAVInstruction@@H@Z ; Ship::SetNavptStatus
  00500	8b 74 24 18	 mov	 esi, DWORD PTR _ward$121317[esp+192]
$LN11@ResolveTim:

; 3712 : 		}
; 3713 : 
; 3714 : 		if (ward) {

  00504	85 f6		 test	 esi, esi
  00506	0f 84 26 01 00
	00		 je	 $LN8@ResolveTim

; 3715 : 			Point ward_heading = ward->Heading();

  0050c	f2 0f 10 86 90
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+144]
  00514	f2 0f 11 44 24
	20		 movsd	 QWORD PTR _ward_heading$121376[esp+192], xmm0
  0051a	f2 0f 10 86 a0
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+160]
  00522	f2 0f 11 44 24
	30		 movsd	 QWORD PTR _ward_heading$121376[esp+208], xmm0

; 3716 : 			ward_heading.y = 0;

  00528	0f 57 c0	 xorps	 xmm0, xmm0

; 3717 : 			ward_heading.Normalize();

  0052b	8d 4c 24 20	 lea	 ecx, DWORD PTR _ward_heading$121376[esp+192]
  0052f	f2 0f 11 44 24
	28		 movsd	 QWORD PTR _ward_heading$121376[esp+200], xmm0
  00535	e8 00 00 00 00	 call	 ?Normalize@Point@@QAENXZ ; Point::Normalize
  0053a	dd d8		 fstp	 ST(0)

; 3718 : 
; 3719 : 			if (ship->GetFuelLevel() > 1) {

  0053c	8b c7		 mov	 eax, edi
  0053e	e8 00 00 00 00	 call	 ?GetFuelLevel@Ship@@QBEHXZ ; Ship::GetFuelLevel
  00543	83 f8 01	 cmp	 eax, 1
  00546	7e 50		 jle	 SHORT $LN9@ResolveTim

; 3720 : 				ship->SetVelocity(ward->Velocity());

  00548	f2 0f 10 86 c0
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+192]
  00550	f2 0f 58 86 a8
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+168]
  00558	8b 07		 mov	 eax, DWORD PTR [edi]
  0055a	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  0055d	f2 0f 11 44 24
	68		 movsd	 QWORD PTR $T405742[esp+192], xmm0
  00563	f2 0f 10 86 c8
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+200]
  0056b	f2 0f 58 86 b0
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+176]
  00573	f2 0f 11 44 24
	70		 movsd	 QWORD PTR $T405742[esp+200], xmm0
  00579	f2 0f 10 86 d0
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+208]
  00581	f2 0f 58 86 b8
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+184]
  00589	8d 4c 24 68	 lea	 ecx, DWORD PTR $T405742[esp+192]
  0058d	51		 push	 ecx
  0058e	8b cf		 mov	 ecx, edi
  00590	f2 0f 11 44 24
	7c		 movsd	 QWORD PTR $T405742[esp+212], xmm0
  00596	ff d2		 call	 edx
$LN9@ResolveTim:

; 3721 : 			}
; 3722 : 			ship->LookAt(ship->Location() + ward_heading * 1e6);

  00598	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@412e848000000000
  005a0	f2 0f 10 44 24
	20		 movsd	 xmm0, QWORD PTR _ward_heading$121376[esp+192]
  005a6	f2 0f 10 4c 24
	28		 movsd	 xmm1, QWORD PTR _ward_heading$121376[esp+200]
  005ac	f2 0f 10 54 24
	30		 movsd	 xmm2, QWORD PTR _ward_heading$121376[esp+208]
  005b2	8b 07		 mov	 eax, DWORD PTR [edi]
  005b4	f2 0f 10 67 50	 movsd	 xmm4, QWORD PTR [edi+80]
  005b9	f2 0f 10 6f 58	 movsd	 xmm5, QWORD PTR [edi+88]
  005be	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  005c1	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  005c5	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  005c9	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  005cd	f2 0f 10 5f 48	 movsd	 xmm3, QWORD PTR [edi+72]
  005d2	8d 4c 24 68	 lea	 ecx, DWORD PTR $T405745[esp+192]
  005d6	51		 push	 ecx
  005d7	f2 0f 58 d8	 addsd	 xmm3, xmm0
  005db	f2 0f 58 e1	 addsd	 xmm4, xmm1
  005df	f2 0f 58 ea	 addsd	 xmm5, xmm2
  005e3	8b cf		 mov	 ecx, edi
  005e5	f2 0f 11 5c 24
	6c		 movsd	 QWORD PTR $T405745[esp+196], xmm3
  005eb	f2 0f 11 64 24
	74		 movsd	 QWORD PTR $T405745[esp+204], xmm4
  005f1	f2 0f 11 6c 24
	7c		 movsd	 QWORD PTR $T405745[esp+212], xmm5
  005f7	ff d2		 call	 edx

; 3723 : 
; 3724 : 			if (ship->IsStarship()) {

  005f9	8b c7		 mov	 eax, edi
  005fb	e8 00 00 00 00	 call	 ?IsStarship@Ship@@QBE_NXZ ; Ship::IsStarship
  00600	84 c0		 test	 al, al
  00602	74 2e		 je	 SHORT $LN8@ResolveTim

; 3725 : 				ship->SetFLCSMode(Ship::FLCS_HELM);

  00604	6a 02		 push	 2
  00606	8b c7		 mov	 eax, edi
  00608	e8 00 00 00 00	 call	 ?SetFLCSMode@Ship@@QAEXH@Z ; Ship::SetFLCSMode

; 3726 : 				ship->SetHelmHeading(ship->CompassHeading());

  0060d	8b c7		 mov	 eax, edi
  0060f	e8 00 00 00 00	 call	 ?CompassHeading@Ship@@QBENXZ ; Ship::CompassHeading
  00614	57		 push	 edi
  00615	e8 00 00 00 00	 call	 ?SetHelmHeading@Ship@@QAEXN@Z ; Ship::SetHelmHeading

; 3727 : 				ship->SetHelmPitch(ship->CompassPitch());

  0061a	8b c7		 mov	 eax, edi
  0061c	e8 00 00 00 00	 call	 ?CompassPitch@Ship@@QBENXZ ; Ship::CompassPitch
  00621	dd 5c 24 18	 fstp	 QWORD PTR tv1320[esp+192]
  00625	f2 0f 10 54 24
	18		 movsd	 xmm2, QWORD PTR tv1320[esp+192]
  0062b	8b c7		 mov	 eax, edi
  0062d	e8 00 00 00 00	 call	 ?SetHelmPitch@Ship@@QAEXN@Z ; Ship::SetHelmPitch
$LN8@ResolveTim:

; 3728 : 			}
; 3729 : 		}
; 3730 : 
; 3731 : 		if (dist > 1 || ward) {

  00632	f2 0f 10 84 24
	98 00 00 00	 movsd	 xmm0, QWORD PTR _dist$121361[esp+192]
  0063b	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  00643	77 08		 ja	 SHORT $LN6@ResolveTim
  00645	85 f6		 test	 esi, esi
  00647	0f 84 24 01 00
	00		 je	 $LN35@ResolveTim
$LN6@ResolveTim:

; 3732 : 			for (int j = 0; j < ships.size(); j++) {

  0064d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00650	83 c0 4c	 add	 eax, 76			; 0000004cH
  00653	33 db		 xor	 ebx, ebx
  00655	89 44 24 18	 mov	 DWORD PTR tv864[esp+192], eax
  00659	39 18		 cmp	 DWORD PTR [eax], ebx
  0065b	0f 8e 10 01 00
	00		 jle	 $LN35@ResolveTim
$LL5@ResolveTim:

; 3733 : 				Ship* test = ships[j];

  00661	53		 push	 ebx
  00662	e8 00 00 00 00	 call	 ??A?$List@VShip@@@@QAEAAPAVShip@@H@Z ; List<Ship>::operator[]
  00667	8b 30		 mov	 esi, DWORD PTR [eax]

; 3734 : 
; 3735 : 				if (ship != test && test->Mass() >= ship->Mass()) {

  00669	3b fe		 cmp	 edi, esi
  0066b	0f 84 f3 00 00
	00		 je	 $LN4@ResolveTim
  00671	f3 0f 10 86 b4
	01 00 00	 movss	 xmm0, DWORD PTR [esi+436]
  00679	f3 0f 10 8f b4
	01 00 00	 movss	 xmm1, DWORD PTR [edi+436]
  00681	0f 5a c0	 cvtps2pd xmm0, xmm0
  00684	0f 5a c9	 cvtps2pd xmm1, xmm1
  00687	66 0f 2f c1	 comisd	 xmm0, xmm1
  0068b	0f 82 d3 00 00
	00		 jb	 $LN4@ResolveTim

; 3736 : 					Point delta = ship->Location() - test->Location();

  00691	f2 0f 10 5e 48	 movsd	 xmm3, QWORD PTR [esi+72]
  00696	f2 0f 10 66 50	 movsd	 xmm4, QWORD PTR [esi+80]
  0069b	f2 0f 10 47 48	 movsd	 xmm0, QWORD PTR [edi+72]
  006a0	f2 0f 10 4f 50	 movsd	 xmm1, QWORD PTR [edi+80]
  006a5	f2 0f 10 57 58	 movsd	 xmm2, QWORD PTR [edi+88]
  006aa	f2 0f 10 6e 58	 movsd	 xmm5, QWORD PTR [esi+88]
  006af	f2 0f 5c c3	 subsd	 xmm0, xmm3

; 3737 : 
; 3738 : 					if (delta.length() < ship->Radius() * 2 + test->Radius() * 2) {

  006b3	f3 0f 10 9f b0
	01 00 00	 movss	 xmm3, DWORD PTR [edi+432]
  006bb	f2 0f 5c cc	 subsd	 xmm1, xmm4
  006bf	f2 0f 5c d5	 subsd	 xmm2, xmm5
  006c3	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  006c7	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  006cb	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  006cf	f2 0f 58 c8	 addsd	 xmm1, xmm0
  006d3	f3 0f 10 86 b0
	01 00 00	 movss	 xmm0, DWORD PTR [esi+432]
  006db	f2 0f 58 ca	 addsd	 xmm1, xmm2
  006df	0f 57 d2	 xorps	 xmm2, xmm2
  006e2	0f 5a d0	 cvtps2pd xmm2, xmm0
  006e5	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  006ed	0f 5a db	 cvtps2pd xmm3, xmm3
  006f0	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  006f4	f2 0f 59 d8	 mulsd	 xmm3, xmm0
  006f8	f2 0f 51 c9	 sqrtsd	 xmm1, xmm1
  006fc	f2 0f 58 d3	 addsd	 xmm2, xmm3
  00700	66 0f 2f d1	 comisd	 xmm2, xmm1
  00704	76 5e		 jbe	 SHORT $LN4@ResolveTim

; 3739 : 						ship->MoveTo(test->Location() + RandomPoint().OtherHand());

  00706	8d 44 24 20	 lea	 eax, DWORD PTR $T405749[esp+192]
  0070a	50		 push	 eax
  0070b	e8 00 00 00 00	 call	 ?RandomPoint@@YA?AUPoint@@XZ ; RandomPoint
  00710	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00714	f2 0f 10 60 10	 movsd	 xmm4, QWORD PTR [eax+16]
  00719	f2 0f 10 68 08	 movsd	 xmm5, QWORD PTR [eax+8]
  0071e	8b 17		 mov	 edx, DWORD PTR [edi]
  00720	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00728	f2 0f 10 4e 48	 movsd	 xmm1, QWORD PTR [esi+72]
  0072d	f2 0f 10 56 50	 movsd	 xmm2, QWORD PTR [esi+80]
  00732	f2 0f 10 5e 58	 movsd	 xmm3, QWORD PTR [esi+88]
  00737	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  0073a	83 c4 04	 add	 esp, 4
  0073d	8d 44 24 68	 lea	 eax, DWORD PTR $T405751[esp+192]
  00741	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00745	f2 0f 58 d4	 addsd	 xmm2, xmm4
  00749	f2 0f 58 dd	 addsd	 xmm3, xmm5
  0074d	50		 push	 eax
  0074e	8b cf		 mov	 ecx, edi
  00750	f2 0f 11 4c 24
	6c		 movsd	 QWORD PTR $T405751[esp+196], xmm1
  00756	f2 0f 11 54 24
	74		 movsd	 QWORD PTR $T405751[esp+204], xmm2
  0075c	f2 0f 11 5c 24
	7c		 movsd	 QWORD PTR $T405751[esp+212], xmm3
  00762	ff d2		 call	 edx
$LN4@ResolveTim:

; 3732 : 			for (int j = 0; j < ships.size(); j++) {

  00764	8b 44 24 18	 mov	 eax, DWORD PTR tv864[esp+192]
  00768	43		 inc	 ebx
  00769	3b 18		 cmp	 ebx, DWORD PTR [eax]
  0076b	0f 8c f0 fe ff
	ff		 jl	 $LL5@ResolveTim
$LN35@ResolveTim:

; 3612 : 	for (int i = 0; i < ships.size(); i++) {

  00771	8b 4c 24 3c	 mov	 ecx, DWORD PTR _i$121312[esp+192]
  00775	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00778	41		 inc	 ecx
  00779	8d 42 4c	 lea	 eax, DWORD PTR [edx+76]
  0077c	89 4c 24 3c	 mov	 DWORD PTR _i$121312[esp+192], ecx
  00780	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00782	0f 8c 9b f8 ff
	ff		 jl	 $LL36@ResolveTim
$LN34@ResolveTim:

; 3740 : 					}
; 3741 : 				}
; 3742 : 			}
; 3743 : 		}
; 3744 : 	}
; 3745 : 
; 3746 : 	DockShips();

  00788	52		 push	 edx
  00789	e8 00 00 00 00	 call	 ?DockShips@SimRegion@@IAEXXZ ; SimRegion::DockShips

; 3747 : }

  0078e	5f		 pop	 edi
  0078f	5e		 pop	 esi
  00790	5b		 pop	 ebx
  00791	8b e5		 mov	 esp, ebp
  00793	5d		 pop	 ebp
  00794	c2 0c 00	 ret	 12			; 0000000cH
?ResolveTimeSkip@SimRegion@@QAEXN@Z ENDP		; SimRegion::ResolveTimeSkip
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?DestroyShip@SimRegion@@IAEXPAVShip@@@Z		; SimRegion::DestroyShip
;	COMDAT xdata$x
; File c:\matrix games\dev\ngenex\physical.h
xdata$x	SEGMENT
__unwindtable$?DestroyShip@SimRegion@@IAEXPAVShip@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DestroyShip@SimRegion@@IAEXPAVShip@@@Z$0
__ehfuncinfo$?DestroyShip@SimRegion@@IAEXPAVShip@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DestroyShip@SimRegion@@IAEXPAVShip@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?DestroyShip@SimRegion@@IAEXPAVShip@@@Z
_TEXT	SEGMENT
_respawn$ = -271					; size = 1
_observe$ = -270					; size = 1
_player_destroyed$ = -269				; size = 1
tv584 = -268						; size = 4
tv485 = -268						; size = 4
_ship_iff$ = -268					; size = 4
_this$GSCopy$ = -264					; size = 4
_cmd_ai$ = -260						; size = 4
_rgn_name$ = -256					; size = 8
_spawn_loc$121051 = -248				; size = 24
$T406237 = -224						; size = 24
_ship_name$ = -200					; size = 64
_ship_reg$ = -136					; size = 64
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
_ship$ = 8						; size = 4
?DestroyShip@SimRegion@@IAEXPAVShip@@@Z PROC		; SimRegion::DestroyShip, COMDAT
; _this$ = ecx

; 3186 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?DestroyShip@SimRegion@@IAEXPAVShip@@@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	89 84 24 f0 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+308], eax
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c4		 xor	 eax, esp
  00032	50		 push	 eax
  00033	8d 84 24 38 01
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+324]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	8b 5d 08	 mov	 ebx, DWORD PTR _ship$[ebp]
  00043	8b f1		 mov	 esi, ecx

; 3257 : 		}
; 3258 : 	}
; 3259 : 
; 3260 : 	sim->ProcessEventTrigger(MissionEvent::TRIGGER_DESTROYED, 0, ship->Name());

  00045	89 74 24 3c	 mov	 DWORD PTR _this$GSCopy$[esp+324], esi
  00049	85 db		 test	 ebx, ebx
  0004b	0f 84 68 03 00
	00		 je	 $LN20@DestroyShi

; 3187 : 	if (!ship) return;
; 3188 : 
; 3189 : 	Ship*    spawn = 0;
; 3190 : 
; 3191 : 	ships.remove(ship);

  00051	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  00054	8b fb		 mov	 edi, ebx
  00056	e8 00 00 00 00	 call	 ?remove@?$List@VShip@@@@QAEPAVShip@@PBV2@@Z ; List<Ship>::remove

; 3192 : 	carriers.remove(ship);

  0005b	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  0005e	e8 00 00 00 00	 call	 ?remove@?$List@VShip@@@@QAEPAVShip@@PBV2@@Z ; List<Ship>::remove

; 3193 : 	selection.remove(ship);

  00063	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00066	e8 00 00 00 00	 call	 ?remove@?$List@VShip@@@@QAEPAVShip@@PBV2@@Z ; List<Ship>::remove

; 3194 : 
; 3195 : 	Text rgn_name;

  0006b	8d 4c 24 44	 lea	 ecx, DWORD PTR _rgn_name$[esp+324]
  0006f	e8 00 00 00 00	 call	 ??0Text@@QAE@XZ		; Text::Text
  00074	c7 84 24 40 01
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+332], 0

; 3196 : 	if (ship->GetRegion())

  0007f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00081	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00087	8b cb		 mov	 ecx, ebx
  00089	ff d2		 call	 edx
  0008b	85 c0		 test	 eax, eax
  0008d	74 19		 je	 SHORT $LN18@DestroyShi

; 3197 : 	rgn_name = ship->GetRegion()->Name();

  0008f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00091	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00097	8b cb		 mov	 ecx, ebx
  00099	ff d2		 call	 edx
  0009b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0009e	50		 push	 eax
  0009f	8d 4c 24 48	 lea	 ecx, DWORD PTR _rgn_name$[esp+328]
  000a3	e8 00 00 00 00	 call	 ??4Text@@QAEAAV0@PBD@Z	; Text::operator=
$LN18@DestroyShi:

; 3198 : 
; 3199 : 	bool player_destroyed = (player_ship == ship);

  000a8	39 5e 44	 cmp	 DWORD PTR [esi+68], ebx

; 3200 : 
; 3201 : 	char        ship_name[64];
; 3202 : 	char        ship_reg[64];
; 3203 : 	strcpy_s(ship_name, ship->Name());

  000ab	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  000ae	50		 push	 eax
  000af	8d 84 24 80 00
	00 00		 lea	 eax, DWORD PTR _ship_name$[esp+328]
  000b6	6a 40		 push	 64			; 00000040H
  000b8	50		 push	 eax
  000b9	0f 94 44 24 43	 sete	 BYTE PTR _player_destroyed$[esp+336]
  000be	e8 00 00 00 00	 call	 _strcpy_s
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3204 : 	strcpy_s(ship_reg,  ship->Registry());

  000c6	8d 8b f0 01 00
	00		 lea	 ecx, DWORD PTR [ebx+496]
  000cc	51		 push	 ecx
  000cd	8d 94 24 c0 00
	00 00		 lea	 edx, DWORD PTR _ship_reg$[esp+328]
  000d4	6a 40		 push	 64			; 00000040H
  000d6	52		 push	 edx
  000d7	e8 00 00 00 00	 call	 _strcpy_s

; 3205 : 
; 3206 : 	ShipDesign* ship_design = (ShipDesign*) ship->Design();
; 3207 : 	int         ship_iff    = ship->GetIFF();

  000dc	8b 03		 mov	 eax, DWORD PTR [ebx]
  000de	8b 90 98 01 00
	00		 mov	 edx, DWORD PTR [eax+408]
  000e4	8b bb 00 02 00
	00		 mov	 edi, DWORD PTR [ebx+512]
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ed	8b cb		 mov	 ecx, ebx
  000ef	ff d2		 call	 edx

; 3208 : 	int         cmd_ai      = ship->GetCommandAILevel();
; 3209 : 	bool        respawn     = sim->IsTestMode() && !ship->IsGroundUnit();

  000f1	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000f4	80 ba bc 00 00
	00 00		 cmp	 BYTE PTR [edx+188], 0
  000fb	89 44 24 38	 mov	 DWORD PTR _ship_iff$[esp+324], eax
  000ff	0f b6 83 15 04
	00 00		 movzx	 eax, BYTE PTR [ebx+1045]
  00106	89 44 24 40	 mov	 DWORD PTR _cmd_ai$[esp+324], eax
  0010a	74 13		 je	 SHORT $LN22@DestroyShi
  0010c	8b c3		 mov	 eax, ebx
  0010e	e8 00 00 00 00	 call	 ?IsGroundUnit@Ship@@QBE_NXZ ; Ship::IsGroundUnit
  00113	84 c0		 test	 al, al
  00115	75 08		 jne	 SHORT $LN22@DestroyShi
  00117	b0 01		 mov	 al, 1
  00119	88 44 24 35	 mov	 BYTE PTR _respawn$[esp+324], al
  0011d	eb 09		 jmp	 SHORT $LN23@DestroyShi
$LN22@DestroyShi:
  0011f	c6 44 24 35 00	 mov	 BYTE PTR _respawn$[esp+324], 0
  00124	8a 44 24 35	 mov	 al, BYTE PTR _respawn$[esp+324]
$LN23@DestroyShi:

; 3210 : 	bool        observe     = false;

  00128	c6 44 24 36 00	 mov	 BYTE PTR _observe$[esp+324], 0

; 3211 : 
; 3212 : 	if (!respawn)

  0012d	84 c0		 test	 al, al
  0012f	75 10		 jne	 SHORT $LN17@DestroyShi

; 3213 : 	respawn = ship->RespawnCount() > 0;

  00131	83 bb 98 04 00
	00 00		 cmp	 DWORD PTR [ebx+1176], 0
  00138	0f 9f 44 24 35	 setg	 BYTE PTR _respawn$[esp+324]
  0013d	8a 44 24 35	 mov	 al, BYTE PTR _respawn$[esp+324]
$LN17@DestroyShi:

; 3214 : 
; 3215 : 	if (sim->netgame) {

  00141	8b 92 c4 00 00
	00		 mov	 edx, DWORD PTR [edx+196]
  00147	85 d2		 test	 edx, edx
  00149	0f 84 db 00 00
	00		 je	 $LN15@DestroyShi

; 3216 : 		if (!respawn)

  0014f	84 c0		 test	 al, al
  00151	75 10		 jne	 SHORT $LN13@DestroyShi

; 3217 : 		observe = player_destroyed;

  00153	8a 4c 24 37	 mov	 cl, BYTE PTR _player_destroyed$[esp+324]
  00157	88 4c 24 36	 mov	 BYTE PTR _observe$[esp+324], cl

; 3218 : 	}
; 3219 : 
; 3220 : 	if (respawn || observe) {

  0015b	84 c9		 test	 cl, cl
  0015d	0f 84 18 02 00
	00		 je	 $LN4@DestroyShi
$LN13@DestroyShi:

; 3221 : 		if (!sim->netgame || !respawn)

  00163	85 d2		 test	 edx, edx
  00165	74 04		 je	 SHORT $LN11@DestroyShi
  00167	84 c0		 test	 al, al
  00169	75 47		 jne	 SHORT $LN53@DestroyShi
$LN11@DestroyShi:

; 3222 : 		ship->SetRespawnLoc(RandomPoint() * 2);

  0016b	8d 4c 24 64	 lea	 ecx, DWORD PTR $T406237[esp+324]
  0016f	51		 push	 ecx
  00170	e8 00 00 00 00	 call	 ?RandomPoint@@YA?AUPoint@@XZ ; RandomPoint
  00175	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00179	f2 0f 10 48 08	 movsd	 xmm1, QWORD PTR [eax+8]
  0017e	f2 0f 10 50 10	 movsd	 xmm2, QWORD PTR [eax+16]
  00183	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@4000000000000000
  0018b	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  0018f	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00193	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  00197	83 c4 04	 add	 esp, 4
  0019a	f2 0f 11 83 80
	04 00 00	 movsd	 QWORD PTR [ebx+1152], xmm0
  001a2	f2 0f 11 8b 88
	04 00 00	 movsd	 QWORD PTR [ebx+1160], xmm1
  001aa	f2 0f 11 93 90
	04 00 00	 movsd	 QWORD PTR [ebx+1168], xmm2
$LN53@DestroyShi:

; 3223 : 
; 3224 : 		Point spawn_loc = ship->RespawnLoc();

  001b2	f2 0f 10 83 80
	04 00 00	 movsd	 xmm0, QWORD PTR [ebx+1152]
  001ba	f2 0f 11 44 24
	4c		 movsd	 QWORD PTR _spawn_loc$121051[esp+324], xmm0
  001c0	f2 0f 10 83 88
	04 00 00	 movsd	 xmm0, QWORD PTR [ebx+1160]
  001c8	f2 0f 11 44 24
	54		 movsd	 QWORD PTR _spawn_loc$121051[esp+332], xmm0
  001ce	f2 0f 10 83 90
	04 00 00	 movsd	 xmm0, QWORD PTR [ebx+1168]

; 3225 : 
; 3226 : 		if (ship->IsAirborne() && spawn_loc.z < 5e3)

  001d6	8b c3		 mov	 eax, ebx
  001d8	f2 0f 11 44 24
	5c		 movsd	 QWORD PTR _spawn_loc$121051[esp+340], xmm0
  001de	e8 00 00 00 00	 call	 ?IsAirborne@Ship@@QBE_NXZ ; Ship::IsAirborne
  001e3	84 c0		 test	 al, al
  001e5	74 38		 je	 SHORT $LN10@DestroyShi
  001e7	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@40b3880000000000
  001ef	66 0f 2f c8	 comisd	 xmm1, xmm0
  001f3	76 2a		 jbe	 SHORT $LN10@DestroyShi

; 3227 : 		spawn_loc.z = Random(8e3, 10e3);

  001f5	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@40c3880000000000
  001fd	83 ec 10	 sub	 esp, 16			; 00000010H
  00200	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  00206	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _TRACK_BOTTOM
  0020e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00213	e8 00 00 00 00	 call	 ?Random@@YANNN@Z	; Random
  00218	dd 5c 24 6c	 fstp	 QWORD PTR _spawn_loc$121051[esp+356]
  0021c	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@DestroyShi:

; 3228 : 
; 3229 : 		spawn = sim->CreateShip(ship_name, ship_reg, ship_design, rgn_name, spawn_loc, ship_iff, cmd_ai, observe ? 0 : ship->GetLoadout());

  0021f	80 7c 24 36 00	 cmp	 BYTE PTR _observe$[esp+324], 0
  00224	74 33		 je	 SHORT $LN24@DestroyShi
  00226	33 c0		 xor	 eax, eax
  00228	eb 3b		 jmp	 SHORT $LN25@DestroyShi
$LN15@DestroyShi:

; 3218 : 	}
; 3219 : 
; 3220 : 	if (respawn || observe) {

  0022a	84 c0		 test	 al, al
  0022c	0f 85 31 ff ff
	ff		 jne	 $LN13@DestroyShi

; 3250 : 	}
; 3251 : 	else {
; 3252 : 		// close mission, return to menu:
; 3253 : 		if (player_destroyed) {

  00232	38 44 24 37	 cmp	 BYTE PTR _player_destroyed$[esp+324], al
  00236	0f 84 3f 01 00
	00		 je	 $LN4@DestroyShi

; 3254 : 			Starshatter* stars = Starshatter::GetInstance();

  0023c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?instance@Starshatter@@1PAV1@A ; Starshatter::instance

; 3255 : 			if (stars)

  00242	85 c9		 test	 ecx, ecx
  00244	0f 84 31 01 00
	00		 je	 $LN4@DestroyShi

; 3256 : 			stars->SetGameMode(Starshatter::PLAN_MODE);

  0024a	bf 04 00 00 00	 mov	 edi, 4
  0024f	e8 00 00 00 00	 call	 ?SetGameMode@Starshatter@@QAEXH@Z ; Starshatter::SetGameMode
  00254	e9 22 01 00 00	 jmp	 $LN4@DestroyShi
$LN24@DestroyShi:

; 3228 : 
; 3229 : 		spawn = sim->CreateShip(ship_name, ship_reg, ship_design, rgn_name, spawn_loc, ship_iff, cmd_ai, observe ? 0 : ship->GetLoadout());

  00259	8b 13		 mov	 edx, DWORD PTR [ebx]
  0025b	8b 82 30 01 00
	00		 mov	 eax, DWORD PTR [edx+304]
  00261	8b cb		 mov	 ecx, ebx
  00263	ff d0		 call	 eax
$LN25@DestroyShi:
  00265	8b 4c 24 40	 mov	 ecx, DWORD PTR _cmd_ai$[esp+324]
  00269	8b 54 24 38	 mov	 edx, DWORD PTR _ship_iff$[esp+324]
  0026d	50		 push	 eax
  0026e	51		 push	 ecx
  0026f	8b 4c 24 4c	 mov	 ecx, DWORD PTR _rgn_name$[esp+332]
  00273	52		 push	 edx
  00274	8d 44 24 58	 lea	 eax, DWORD PTR _spawn_loc$121051[esp+336]
  00278	50		 push	 eax
  00279	51		 push	 ecx
  0027a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0027d	8d 94 24 d0 00
	00 00		 lea	 edx, DWORD PTR _ship_reg$[esp+344]
  00284	52		 push	 edx
  00285	8d 84 24 94 00
	00 00		 lea	 eax, DWORD PTR _ship_name$[esp+348]
  0028c	50		 push	 eax
  0028d	51		 push	 ecx
  0028e	8b cf		 mov	 ecx, edi
  00290	e8 00 00 00 00	 call	 ?CreateShip@Sim@@QAEPAVShip@@PBD0PAVShipDesign@@0ABUPoint@@HHPBH@Z ; Sim::CreateShip

; 3230 : 		spawn->SetRespawnCount(ship->RespawnCount() - 1);
; 3231 : 		spawn->SetNetObserver(observe);

  00295	8a 54 24 36	 mov	 dl, BYTE PTR _observe$[esp+324]
  00299	8b f8		 mov	 edi, eax
  0029b	8b 83 98 04 00
	00		 mov	 eax, DWORD PTR [ebx+1176]
  002a1	48		 dec	 eax
  002a2	89 87 98 04 00
	00		 mov	 DWORD PTR [edi+1176], eax
  002a8	88 97 17 04 00
	00		 mov	 BYTE PTR [edi+1047], dl

; 3232 : 
; 3233 : 		if (sim->netgame && respawn)

  002ae	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002b1	83 b8 c4 00 00
	00 00		 cmp	 DWORD PTR [eax+196], 0
  002b8	74 33		 je	 SHORT $LN9@DestroyShi
  002ba	80 7c 24 35 00	 cmp	 BYTE PTR _respawn$[esp+324], 0
  002bf	74 2c		 je	 SHORT $LN9@DestroyShi

; 3234 : 		sim->netgame->Respawn(ship->GetObjID(), spawn);

  002c1	8b 90 c4 00 00
	00		 mov	 edx, DWORD PTR [eax+196]
  002c7	8b 02		 mov	 eax, DWORD PTR [edx]
  002c9	8b 13		 mov	 edx, DWORD PTR [ebx]
  002cb	89 44 24 38	 mov	 DWORD PTR tv584[esp+324], eax
  002cf	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  002d5	57		 push	 edi
  002d6	8b cb		 mov	 ecx, ebx
  002d8	ff d0		 call	 eax
  002da	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  002dd	8b 54 24 3c	 mov	 edx, DWORD PTR tv584[esp+328]
  002e1	8b 89 c4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+196]
  002e7	50		 push	 eax
  002e8	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  002eb	ff d0		 call	 eax
$LN9@DestroyShi:

; 3235 : 
; 3236 : 		int n = strlen(ship_name); 

  002ed	8d 44 24 7c	 lea	 eax, DWORD PTR _ship_name$[esp+324]
  002f1	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL73@DestroyShi:
  002f4	8a 08		 mov	 cl, BYTE PTR [eax]
  002f6	40		 inc	 eax
  002f7	84 c9		 test	 cl, cl
  002f9	75 f9		 jne	 SHORT $LL73@DestroyShi
  002fb	2b c2		 sub	 eax, edx

; 3237 : 		if (n > 2) {

  002fd	83 f8 02	 cmp	 eax, 2
  00300	7e 28		 jle	 SHORT $LN7@DestroyShi

; 3238 : 			if (ship_name[n-2] == ' ' && isdigit(ship_name[n-1]))

  00302	80 7c 04 7a 20	 cmp	 BYTE PTR _ship_name$[esp+eax+322], 32 ; 00000020H
  00307	8d 44 04 7c	 lea	 eax, DWORD PTR _ship_name$[esp+eax+324]
  0030b	89 44 24 38	 mov	 DWORD PTR tv485[esp+324], eax
  0030f	75 19		 jne	 SHORT $LN7@DestroyShi
  00311	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  00315	51		 push	 ecx
  00316	e8 00 00 00 00	 call	 _isdigit
  0031b	83 c4 04	 add	 esp, 4
  0031e	85 c0		 test	 eax, eax
  00320	74 08		 je	 SHORT $LN7@DestroyShi

; 3239 : 				ship_name[n-2] = 0;

  00322	8b 54 24 38	 mov	 edx, DWORD PTR tv485[esp+324]
  00326	c6 42 fe 00	 mov	 BYTE PTR [edx-2], 0
$LN7@DestroyShi:

; 3240 : 		}
; 3241 : 
; 3242 : 		Element* elem = sim->FindElement(ship_name);

  0032a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0032d	50		 push	 eax
  0032e	8d b4 24 80 00
	00 00		 lea	 esi, DWORD PTR _ship_name$[esp+328]
  00335	e8 00 00 00 00	 call	 ?FindElement@Sim@@QAEPAVElement@@PBD@Z ; Sim::FindElement
  0033a	8b c8		 mov	 ecx, eax

; 3243 : 		if (elem)

  0033c	85 c9		 test	 ecx, ecx
  0033e	74 12		 je	 SHORT $LN6@DestroyShi

; 3244 : 		elem->AddShip(spawn, ship->GetOrigElementIndex());

  00340	8b c3		 mov	 eax, ebx
  00342	e8 00 00 00 00	 call	 ?GetOrigElementIndex@Ship@@QBEHXZ ; Ship::GetOrigElementIndex
  00347	50		 push	 eax
  00348	51		 push	 ecx
  00349	8b c7		 mov	 eax, edi
  0034b	e8 00 00 00 00	 call	 ?AddShip@Element@@QAEHPAVShip@@H@Z ; Element::AddShip

; 3245 : 		else

  00350	eb 12		 jmp	 SHORT $LN5@DestroyShi
$LN6@DestroyShi:

; 3246 : 		Print("Warning: No Element found for '%s' on respawn.\n", ship_name);

  00352	8d 4c 24 7c	 lea	 ecx, DWORD PTR _ship_name$[esp+324]
  00356	51		 push	 ecx
  00357	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@FMJBEPL@Warning?3?5No?5Element?5found?5for?5?8?$CF@
  0035c	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00361	83 c4 08	 add	 esp, 8
$LN5@DestroyShi:

; 3247 : 
; 3248 : 		if (player_destroyed)

  00364	80 7c 24 37 00	 cmp	 BYTE PTR _player_destroyed$[esp+324], 0
  00369	74 0c		 je	 SHORT $LN75@DestroyShi

; 3249 : 		SetPlayerShip(spawn);

  0036b	8b 54 24 3c	 mov	 edx, DWORD PTR _this$GSCopy$[esp+324]
  0036f	52		 push	 edx
  00370	8b c7		 mov	 eax, edi
  00372	e8 00 00 00 00	 call	 ?SetPlayerShip@SimRegion@@QAEXPAVShip@@@Z ; SimRegion::SetPlayerShip
$LN75@DestroyShi:
  00377	8b 74 24 3c	 mov	 esi, DWORD PTR _this$GSCopy$[esp+324]
$LN4@DestroyShi:

; 3257 : 		}
; 3258 : 	}
; 3259 : 
; 3260 : 	sim->ProcessEventTrigger(MissionEvent::TRIGGER_DESTROYED, 0, ship->Name());

  0037b	6a 00		 push	 0
  0037d	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00380	50		 push	 eax
  00381	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00384	6a 00		 push	 0
  00386	6a 02		 push	 2
  00388	50		 push	 eax
  00389	e8 00 00 00 00	 call	 ?ProcessEventTrigger@Sim@@QAEXHHPBDH@Z ; Sim::ProcessEventTrigger

; 3261 : 
; 3262 : 	dead_ships.insert(ship);

  0038e	53		 push	 ebx
  0038f	8d 46 70	 lea	 eax, DWORD PTR [esi+112]
  00392	33 ff		 xor	 edi, edi
  00394	e8 00 00 00 00	 call	 ?insert@?$List@VShip@@@@QAEXPBVShip@@H@Z ; List<Ship>::insert

; 3263 : 	ship->Destroy();

  00399	8b 13		 mov	 edx, DWORD PTR [ebx]
  0039b	8b 82 84 01 00
	00		 mov	 eax, DWORD PTR [edx+388]
  003a1	8b cb		 mov	 ecx, ebx
  003a3	ff d0		 call	 eax

; 3264 : }

  003a5	8d 4c 24 44	 lea	 ecx, DWORD PTR _rgn_name$[esp+324]
  003a9	c7 84 24 40 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+332], -1
  003b4	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
$LN20@DestroyShi:
  003b9	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+324]
  003c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003c7	59		 pop	 ecx
  003c8	5f		 pop	 edi
  003c9	5e		 pop	 esi
  003ca	5b		 pop	 ebx
  003cb	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+308]
  003d2	33 cc		 xor	 ecx, esp
  003d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d9	8b e5		 mov	 esp, ebp
  003db	5d		 pop	 ebp
  003dc	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DestroyShip@SimRegion@@IAEXPAVShip@@@Z$0:
  00000	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _rgn_name$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__ehhandler$?DestroyShip@SimRegion@@IAEXPAVShip@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 82 cc fe ff
	ff		 lea	 eax, DWORD PTR [edx-308]
  00015	8b 8a c8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-312]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	83 c0 0c	 add	 eax, 12			; 0000000cH
  00025	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DestroyShip@SimRegion@@IAEXPAVShip@@@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DestroyShip@SimRegion@@IAEXPAVShip@@@Z ENDP		; SimRegion::DestroyShip
PUBLIC	?DestroyShips@SimRegion@@IAEXXZ			; SimRegion::DestroyShips
; Function compile flags: /Ogtp
;	COMDAT ?DestroyShips@SimRegion@@IAEXXZ
_TEXT	SEGMENT
_ship_iter$ = -8					; size = 8
?DestroyShips@SimRegion@@IAEXXZ PROC			; SimRegion::DestroyShips, COMDAT
; _this$ = edi

; 3168 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3169 : 	ListIter<Ship> ship_iter = ships;

  00006	8d 47 4c	 lea	 eax, DWORD PTR [edi+76]
  00009	56		 push	 esi

; 3170 : 	while (++ship_iter) {

  0000a	8d 55 f8	 lea	 edx, DWORD PTR _ship_iter$[ebp]
  0000d	89 45 f8	 mov	 DWORD PTR _ship_iter$[ebp], eax
  00010	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ship_iter$[ebp+4], -1
  00017	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  0001c	85 c0		 test	 eax, eax
  0001e	74 2f		 je	 SHORT $LN2@DestroyShi@2
$LL3@DestroyShi@2:

; 3171 : 		Ship*    ship = ship_iter.value();

  00020	8d 45 f8	 lea	 eax, DWORD PTR _ship_iter$[ebp]
  00023	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  00028	8b f0		 mov	 esi, eax

; 3172 : 
; 3173 : 		if (ship->IsDead()) {

  0002a	83 be 60 04 00
	00 06		 cmp	 DWORD PTR [esi+1120], 6
  00031	75 10		 jne	 SHORT $LN1@DestroyShi@2

; 3174 : 			// must use the iterator to remove the current
; 3175 : 			// item from the container:
; 3176 : 			ship_iter.removeItem();

  00033	8d 55 f8	 lea	 edx, DWORD PTR _ship_iter$[ebp]
  00036	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::removeItem

; 3177 : 			DestroyShip(ship);

  0003b	56		 push	 esi
  0003c	8b cf		 mov	 ecx, edi
  0003e	e8 00 00 00 00	 call	 ?DestroyShip@SimRegion@@IAEXPAVShip@@@Z ; SimRegion::DestroyShip
$LN1@DestroyShi@2:

; 3170 : 	while (++ship_iter) {

  00043	8d 55 f8	 lea	 edx, DWORD PTR _ship_iter$[ebp]
  00046	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  0004b	85 c0		 test	 eax, eax
  0004d	75 d1		 jne	 SHORT $LL3@DestroyShi@2
$LN2@DestroyShi@2:

; 3178 : 		}
; 3179 : 	}
; 3180 : }

  0004f	5e		 pop	 esi
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?DestroyShips@SimRegion@@IAEXXZ ENDP			; SimRegion::DestroyShips
_TEXT	ENDS
PUBLIC	?CrashShips@SimRegion@@IAEXXZ			; SimRegion::CrashShips
; Function compile flags: /Ogtp
;	COMDAT ?CrashShips@SimRegion@@IAEXXZ
_TEXT	SEGMENT
$T406373 = -20						; size = 8
_shot_iter$ = -12					; size = 8
_ship_iter$ = -12					; size = 8
_this$ = 8						; size = 4
?CrashShips@SimRegion@@IAEXXZ PROC			; SimRegion::CrashShips, COMDAT

; 3116 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 3117 : 	if (type != AIR_SPACE || NetGame::IsNetGameClient())

  0000a	83 7b 14 01	 cmp	 DWORD PTR [ebx+20], 1
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	0f 85 ee 01 00
	00		 jne	 $LN14@CrashShips
  00016	e8 00 00 00 00	 call	 ?IsNetGameClient@NetGame@@SA_NXZ ; NetGame::IsNetGameClient
  0001b	84 c0		 test	 al, al
  0001d	0f 85 e1 01 00
	00		 jne	 $LN14@CrashShips

; 3118 : 	return;
; 3119 : 
; 3120 : 	ListIter<Ship> ship_iter = ships;

  00023	8d 43 4c	 lea	 eax, DWORD PTR [ebx+76]

; 3121 : 	while (++ship_iter) {

  00026	8d 55 f4	 lea	 edx, DWORD PTR _ship_iter$[ebp]
  00029	89 45 f4	 mov	 DWORD PTR _ship_iter$[ebp], eax
  0002c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _ship_iter$[ebp+4], -1
  00033	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 12 01 00
	00		 je	 $LN12@CrashShips
$LL13@CrashShips:

; 3122 : 		Ship* ship = ship_iter.value();

  00040	8d 45 f4	 lea	 eax, DWORD PTR _ship_iter$[ebp]
  00043	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  00048	8b f8		 mov	 edi, eax

; 3123 : 
; 3124 : 		if (!ship->IsGroundUnit() && 
; 3125 : 				!ship->InTransition() && 
; 3126 : 				ship->Class() != Ship::LCA &&
; 3127 : 				ship->AltitudeAGL() < ship->Radius()/2) {

  0004a	e8 00 00 00 00	 call	 ?IsGroundUnit@Ship@@QBE_NXZ ; Ship::IsGroundUnit
  0004f	84 c0		 test	 al, al
  00051	0f 85 eb 00 00
	00		 jne	 $LN8@CrashShips
  00057	83 bf 60 04 00
	00 00		 cmp	 DWORD PTR [edi+1120], 0
  0005e	0f 85 de 00 00
	00		 jne	 $LN8@CrashShips
  00064	8b c7		 mov	 eax, edi
  00066	e8 00 00 00 00	 call	 ?Class@Ship@@QBE?AW4CLASSIFICATION@1@XZ ; Ship::Class
  0006b	83 f8 08	 cmp	 eax, 8
  0006e	0f 84 ce 00 00
	00		 je	 $LN8@CrashShips
  00074	f3 0f 10 87 b0
	01 00 00	 movss	 xmm0, DWORD PTR [edi+432]
  0007c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0007f	f2 0f 11 45 ec	 movsd	 QWORD PTR $T406373[ebp], xmm0
  00084	e8 00 00 00 00	 call	 ?AltitudeAGL@Ship@@QBENXZ ; Ship::AltitudeAGL
  00089	66 0f 28 c8	 movapd	 xmm1, xmm0
  0008d	f2 0f 10 45 ec	 movsd	 xmm0, QWORD PTR $T406373[ebp]
  00092	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR _BLEED
  0009a	66 0f 2f c1	 comisd	 xmm0, xmm1
  0009e	0f 86 9e 00 00
	00		 jbe	 $LN8@CrashShips

; 3128 : 			if (ship->GetFlightPhase() == Ship::ACTIVE || ship->GetFlightPhase() == Ship::APPROACH) {

  000a4	8b 17		 mov	 edx, DWORD PTR [edi]
  000a6	8b 82 d4 00 00
	00		 mov	 eax, DWORD PTR [edx+212]
  000ac	8b cf		 mov	 ecx, edi
  000ae	ff d0		 call	 eax
  000b0	83 f8 05	 cmp	 eax, 5
  000b3	74 11		 je	 SHORT $LN9@CrashShips
  000b5	8b 17		 mov	 edx, DWORD PTR [edi]
  000b7	8b 82 d4 00 00
	00		 mov	 eax, DWORD PTR [edx+212]
  000bd	8b cf		 mov	 ecx, edi
  000bf	ff d0		 call	 eax
  000c1	83 f8 06	 cmp	 eax, 6
  000c4	75 7c		 jne	 SHORT $LN8@CrashShips
$LN9@CrashShips:

; 3129 : 				ship->InflictDamage(1e6);

  000c6	0f 57 c0	 xorps	 xmm0, xmm0
  000c9	83 ec 18	 sub	 esp, 24			; 00000018H
  000cc	8b c4		 mov	 eax, esp
  000ce	6a 03		 push	 3
  000d0	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  000d4	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0
  000d9	f2 0f 11 40 10	 movsd	 QWORD PTR [eax+16], xmm0
  000de	8b 17		 mov	 edx, DWORD PTR [edi]
  000e0	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@412e848000000000
  000e8	8b 82 6c 01 00
	00		 mov	 eax, DWORD PTR [edx+364]
  000ee	6a 00		 push	 0
  000f0	83 ec 08	 sub	 esp, 8
  000f3	8b cf		 mov	 ecx, edi
  000f5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000fa	ff d0		 call	 eax
  000fc	dd d8		 fstp	 ST(0)

; 3130 : 
; 3131 : 				if (ship->Integrity() < 1.0f) {

  000fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00106	0f 2f 87 b8 01
	00 00		 comiss	 xmm0, DWORD PTR [edi+440]
  0010d	76 33		 jbe	 SHORT $LN8@CrashShips

; 3132 : 					Print("    ship destroyed by crash: %s (%s)\n", ship->Name(), FormatGameTime());

  0010f	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  00112	e8 00 00 00 00	 call	 ?FormatGameTime@@YAPBDXZ ; FormatGameTime
  00117	50		 push	 eax
  00118	56		 push	 esi
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GLNEEKDA@?5?5?5?5ship?5destroyed?5by?5crash?3?5?$CFs?5@
  0011e	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3133 : 					ShipStats* r = ShipStats::Find(ship->Name());

  00126	8b ce		 mov	 ecx, esi
  00128	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find

; 3134 : 					if (r) r->AddEvent(SimEvent::CRASH);

  0012d	85 c0		 test	 eax, eax
  0012f	74 0a		 je	 SHORT $LN7@CrashShips
  00131	6a 00		 push	 0
  00133	6a 05		 push	 5
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
$LN7@CrashShips:

; 3135 : 
; 3136 : 					ship->DeathSpiral();

  0013b	8b c7		 mov	 eax, edi
  0013d	e8 00 00 00 00	 call	 ?DeathSpiral@Ship@@QAEXXZ ; Ship::DeathSpiral
$LN8@CrashShips:

; 3121 : 	while (++ship_iter) {

  00142	8d 55 f4	 lea	 edx, DWORD PTR _ship_iter$[ebp]
  00145	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  0014a	85 c0		 test	 eax, eax
  0014c	0f 85 ee fe ff
	ff		 jne	 $LL13@CrashShips
$LN12@CrashShips:

; 3137 : 				}
; 3138 : 			}
; 3139 : 		}
; 3140 : 	}
; 3141 : 
; 3142 : 	ListIter<Shot> shot_iter = shots;

  00152	8d 4b 7c	 lea	 ecx, DWORD PTR [ebx+124]

; 3143 : 	while (++shot_iter) {

  00155	8d 55 f4	 lea	 edx, DWORD PTR _shot_iter$[ebp]
  00158	89 4d f4	 mov	 DWORD PTR _shot_iter$[ebp], ecx
  0015b	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _shot_iter$[ebp+4], -1
  00162	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  00167	85 c0		 test	 eax, eax
  00169	0f 84 95 00 00
	00		 je	 $LN14@CrashShips
  0016f	90		 npad	 1
$LL6@CrashShips:

; 3144 : 		Shot* shot = shot_iter.value();

  00170	8d 45 f4	 lea	 eax, DWORD PTR _shot_iter$[ebp]
  00173	e8 00 00 00 00	 call	 ?value@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::value
  00178	8b f8		 mov	 edi, eax

; 3145 : 
; 3146 : 		if (shot->IsBeam() || shot->IsDecoy())

  0017a	8b 17		 mov	 edx, DWORD PTR [edi]
  0017c	8b 82 d8 00 00
	00		 mov	 eax, DWORD PTR [edx+216]
  00182	8b cf		 mov	 ecx, edi
  00184	ff d0		 call	 eax
  00186	84 c0		 test	 al, al
  00188	75 6a		 jne	 SHORT $LN18@CrashShips
  0018a	8b 17		 mov	 edx, DWORD PTR [edi]
  0018c	8b 82 c8 00 00
	00		 mov	 eax, DWORD PTR [edx+200]
  00192	8b cf		 mov	 ecx, edi
  00194	ff d0		 call	 eax
  00196	84 c0		 test	 al, al
  00198	75 5a		 jne	 SHORT $LN18@CrashShips

; 3147 : 		continue;
; 3148 : 
; 3149 : 		if (shot->AltitudeMSL() < 5e3 &&
; 3150 : 				shot->AltitudeAGL() < 5) {

  0019a	8b c7		 mov	 eax, edi
  0019c	e8 00 00 00 00	 call	 ?AltitudeMSL@Shot@@QBENXZ ; Shot::AltitudeMSL
  001a1	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@40b3880000000000
  001a9	66 0f 2f c8	 comisd	 xmm1, xmm0
  001ad	76 45		 jbe	 SHORT $LN18@CrashShips
  001af	e8 00 00 00 00	 call	 ?AltitudeAGL@Shot@@QBENXZ ; Shot::AltitudeAGL
  001b4	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4014000000000000
  001bc	66 0f 2f c8	 comisd	 xmm1, xmm0
  001c0	76 32		 jbe	 SHORT $LN18@CrashShips

; 3151 : 
; 3152 : 			// shot hit the ground, destroy it:
; 3153 : 			NetUtil::SendWepDestroy(shot);

  001c2	e8 00 00 00 00	 call	 ?SendWepDestroy@NetUtil@@SAXPAVShot@@@Z ; NetUtil::SendWepDestroy

; 3154 : 
; 3155 : 			if (shot->IsDrone())

  001c7	8b 17		 mov	 edx, DWORD PTR [edi]
  001c9	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  001cf	8b cf		 mov	 ecx, edi
  001d1	ff d0		 call	 eax
  001d3	84 c0		 test	 al, al
  001d5	74 0b		 je	 SHORT $LN1@CrashShips

; 3156 : 			drones.remove((Drone*) shot);

  001d7	8d 83 88 00 00
	00		 lea	 eax, DWORD PTR [ebx+136]
  001dd	e8 00 00 00 00	 call	 ?remove@?$List@VDrone@@@@QAEPAVDrone@@PBV2@@Z ; List<Drone>::remove
$LN1@CrashShips:

; 3157 : 
; 3158 : 			shot_iter.removeItem();

  001e2	8d 55 f4	 lea	 edx, DWORD PTR _shot_iter$[ebp]
  001e5	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::removeItem

; 3159 : 			delete shot;

  001ea	8b 17		 mov	 edx, DWORD PTR [edi]
  001ec	8b 02		 mov	 eax, DWORD PTR [edx]
  001ee	6a 01		 push	 1
  001f0	8b cf		 mov	 ecx, edi
  001f2	ff d0		 call	 eax
$LN18@CrashShips:

; 3143 : 	while (++shot_iter) {

  001f4	8d 55 f4	 lea	 edx, DWORD PTR _shot_iter$[ebp]
  001f7	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  001fc	85 c0		 test	 eax, eax
  001fe	0f 85 6c ff ff
	ff		 jne	 $LL6@CrashShips
$LN14@CrashShips:

; 3160 : 		}
; 3161 : 	}
; 3162 : }

  00204	5f		 pop	 edi
  00205	5e		 pop	 esi
  00206	5b		 pop	 ebx
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c2 04 00	 ret	 4
?CrashShips@SimRegion@@IAEXXZ ENDP			; SimRegion::CrashShips
_TEXT	ENDS
PUBLIC	?CollideShips@SimRegion@@IAEXXZ			; SimRegion::CollideShips
;	COMDAT xdata$x
; File c:\matrix games\dev\foundationex\list.h
xdata$x	SEGMENT
__unwindtable$?CollideShips@SimRegion@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CollideShips@SimRegion@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CollideShips@SimRegion@@IAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?CollideShips@SimRegion@@IAEXXZ$2
__ehfuncinfo$?CollideShips@SimRegion@@IAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?CollideShips@SimRegion@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
xdata$x	ENDS
;	COMDAT ?CollideShips@SimRegion@@IAEXXZ
_TEXT	SEGMENT
tv2793 = -328						; size = 4
$T407032 = -328						; size = 4
$T406868 = -328						; size = 4
$T406889 = -328						; size = 4
_targ$120860 = -328					; size = 4
_killed$ = -324						; size = 8
_ship_iter$ = -324					; size = 8
_kill_list$ = -316					; size = 12
_s_index$ = -304					; size = 4
$T406432 = -300						; size = 4
$T406418 = -300						; size = 4
$T406409 = -300						; size = 4
$T406408 = -300						; size = 4
_debris_iter$120910 = -296				; size = 8
_a_iter$120949 = -288					; size = 8
_targ_iter$120856 = -280				; size = 8
_dvs$120885 = -272					; size = 8
$T406745 = -260						; size = 4
$T407002 = -256						; size = 4
$T406507 = -252						; size = 4
$T406971 = -248						; size = 4
$T406839 = -244						; size = 4
$T407001 = -240						; size = 4
$T406838 = -236						; size = 4
$T406970 = -232						; size = 4
$T406837 = -228						; size = 4
$T406539 = -224						; size = 4
$T406808 = -220						; size = 4
$T406538 = -216						; size = 4
$T406807 = -212						; size = 4
$T406571 = -208						; size = 4
$T406806 = -204						; size = 4
$T406509 = -200						; size = 4
$T407003 = -196						; size = 4
$T406570 = -192						; size = 4
_t_index$120854 = -188					; size = 4
$T406508 = -184						; size = 4
$T406776 = -180						; size = 4
_dvt$120887 = -176					; size = 8
$T406746 = -164						; size = 4
_old_integrity$120892 = -160				; size = 8
$T406744 = -152						; size = 4
$T406540 = -148						; size = 4
$T406569 = -144						; size = 4
$T406972 = -140						; size = 4
$T406775 = -136						; size = 4
$T406777 = -132						; size = 4
$T406427 = -128						; size = 8
$T406434 = -120						; size = 8
$T406421 = -112						; size = 24
$T406422 = -88						; size = 24
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?CollideShips@SimRegion@@IAEXXZ PROC			; SimRegion::CollideShips, COMDAT

; 2929 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?CollideShips@SimRegion@@IAEXXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c4		 xor	 eax, esp
  00024	50		 push	 eax
  00025	8d 84 24 78 01
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+388]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2930 : 	if (ships.size() < 2 && debris.size() < 1)

  00032	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  00035	83 7f 4c 02	 cmp	 DWORD PTR [edi+76], 2
  00039	8d 4f 4c	 lea	 ecx, DWORD PTR [edi+76]
  0003c	7d 0d		 jge	 SHORT $LN46@CollideShi
  0003e	83 bf a0 00 00
	00 01		 cmp	 DWORD PTR [edi+160], 1
  00045	0f 8c 34 0e 00
	00		 jl	 $LN314@CollideShi
$LN46@CollideShi:

; 2931 : 	return;
; 2932 : 
; 2933 : 	List<Ship> kill_list;

  0004b	33 f6		 xor	 esi, esi
  0004d	89 74 24 48	 mov	 DWORD PTR _kill_list$[esp+388], esi
  00051	89 74 24 4c	 mov	 DWORD PTR _kill_list$[esp+392], esi
  00055	89 74 24 50	 mov	 DWORD PTR _kill_list$[esp+396], esi
  00059	89 b4 24 80 01
	00 00		 mov	 DWORD PTR __$EHRec$[esp+396], esi

; 2934 : 
; 2935 : 	int s_index = 0;
; 2936 : 
; 2937 : 	ListIter<Ship> ship_iter = ships;

  00060	83 cb ff	 or	 ebx, -1

; 2938 : 	while (++ship_iter) {

  00063	8d 54 24 40	 lea	 edx, DWORD PTR _ship_iter$[esp+388]
  00067	89 74 24 54	 mov	 DWORD PTR _s_index$[esp+388], esi
  0006b	89 4c 24 40	 mov	 DWORD PTR _ship_iter$[esp+388], ecx
  0006f	89 5c 24 44	 mov	 DWORD PTR _ship_iter$[esp+392], ebx
  00073	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00078	85 c0		 test	 eax, eax
  0007a	0f 84 af 0d 00
	00		 je	 $LN44@CollideShi
  00080	eb 02		 jmp	 SHORT $LN45@CollideShi
$LL340@CollideShi:
  00082	33 f6		 xor	 esi, esi
$LN45@CollideShi:

; 2939 : 		Ship* ship = ship_iter.value();

  00084	8d 44 24 40	 lea	 eax, DWORD PTR _ship_iter$[esp+388]
  00088	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  0008d	8b d8		 mov	 ebx, eax

; 2940 : 		
; 2941 : 		if (ship->InTransition()                  || 
; 2942 : 				ship->GetFlightPhase() < Ship::ACTIVE ||
; 2943 : 				ship->MissionClock() < 10000          ||
; 2944 : 				ship->IsNetObserver())

  0008f	39 b3 60 04 00
	00		 cmp	 DWORD PTR [ebx+1120], esi
  00095	0f 85 80 0d 00
	00		 jne	 $LN42@CollideShi
  0009b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009d	8b 90 d4 00 00
	00		 mov	 edx, DWORD PTR [eax+212]
  000a3	8b cb		 mov	 ecx, ebx
  000a5	ff d2		 call	 edx
  000a7	83 f8 05	 cmp	 eax, 5
  000aa	0f 8c 6b 0d 00
	00		 jl	 $LN42@CollideShi
  000b0	8b f3		 mov	 esi, ebx
  000b2	e8 00 00 00 00	 call	 ?MissionClock@Ship@@QBEKXZ ; Ship::MissionClock
  000b7	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  000bc	0f 82 59 0d 00
	00		 jb	 $LN42@CollideShi
  000c2	80 bb 17 04 00
	00 00		 cmp	 BYTE PTR [ebx+1047], 0
  000c9	0f 85 4c 0d 00
	00		 jne	 $LN42@CollideShi

; 2945 : 		continue;
; 2946 : 
; 2947 : 		int t_index = 0;
; 2948 : 		ListIter<Ship> targ_iter = ships;

  000cf	8d 47 4c	 lea	 eax, DWORD PTR [edi+76]

; 2949 : 		while (++targ_iter) {

  000d2	8d 54 24 6c	 lea	 edx, DWORD PTR _targ_iter$120856[esp+388]
  000d6	33 f6		 xor	 esi, esi
  000d8	89 44 24 6c	 mov	 DWORD PTR _targ_iter$120856[esp+388], eax
  000dc	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR _targ_iter$120856[esp+392], -1
  000e4	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  000e9	85 c0		 test	 eax, eax
  000eb	0f 84 15 06 00
	00		 je	 $LN40@CollideShi
  000f1	eb 14		 jmp	 SHORT $LN41@CollideShi
  000f3	eb 0b 8d a4 24
	00 00 00 00 8d
	64 24 00	 npad	 13
$LL339@CollideShi:
  00100	8b b4 24 c8 00
	00 00		 mov	 esi, DWORD PTR _t_index$120854[esp+388]
$LN41@CollideShi:

; 2950 : 			Ship* targ = targ_iter.value();

  00107	8d 44 24 6c	 lea	 eax, DWORD PTR _targ_iter$120856[esp+388]
  0010b	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  00110	8b f8		 mov	 edi, eax

; 2951 : 
; 2952 : 			if (t_index++ <= s_index) continue;

  00112	8b c6		 mov	 eax, esi
  00114	46		 inc	 esi
  00115	89 7c 24 3c	 mov	 DWORD PTR _targ$120860[esp+388], edi
  00119	89 b4 24 c8 00
	00 00		 mov	 DWORD PTR _t_index$120854[esp+388], esi
  00120	3b 44 24 54	 cmp	 eax, DWORD PTR _s_index$[esp+388]
  00124	0f 8e c8 05 00
	00		 jle	 $LN22@CollideShi

; 2953 : 
; 2954 : 			if (targ == ship) continue;

  0012a	3b fb		 cmp	 edi, ebx
  0012c	0f 84 c0 05 00
	00		 je	 $LN22@CollideShi

; 2955 : 
; 2956 : 			if (targ->InTransition()                  || 
; 2957 : 					targ->GetFlightPhase() < Ship::ACTIVE ||
; 2958 : 					targ->MissionClock() < 10000          ||
; 2959 : 					targ->IsNetObserver())

  00132	83 bf 60 04 00
	00 00		 cmp	 DWORD PTR [edi+1120], 0
  00139	0f 85 b3 05 00
	00		 jne	 $LN22@CollideShi
  0013f	8b 17		 mov	 edx, DWORD PTR [edi]
  00141	8b 82 d4 00 00
	00		 mov	 eax, DWORD PTR [edx+212]
  00147	8b cf		 mov	 ecx, edi
  00149	ff d0		 call	 eax
  0014b	83 f8 05	 cmp	 eax, 5
  0014e	0f 8c 9e 05 00
	00		 jl	 $LN22@CollideShi
  00154	8b f7		 mov	 esi, edi
  00156	e8 00 00 00 00	 call	 ?MissionClock@Ship@@QBEKXZ ; Ship::MissionClock
  0015b	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  00160	0f 82 8c 05 00
	00		 jb	 $LN22@CollideShi
  00166	80 bf 17 04 00
	00 00		 cmp	 BYTE PTR [edi+1047], 0
  0016d	0f 85 7f 05 00
	00		 jne	 $LN22@CollideShi

; 2960 : 			continue;
; 2961 : 
; 2962 : 			// ignore AI fighter collisions:
; 2963 : 			if (ship->IsDropship()     &&
; 2964 : 					ship != player_ship    &&
; 2965 : 					targ->IsDropship()     &&
; 2966 : 					targ != player_ship)

  00173	8b c3		 mov	 eax, ebx
  00175	e8 00 00 00 00	 call	 ?IsDropship@Ship@@QBE_NXZ ; Ship::IsDropship
  0017a	84 c0		 test	 al, al
  0017c	74 1d		 je	 SHORT $LN35@CollideShi
  0017e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00184	3b da		 cmp	 ebx, edx
  00186	74 13		 je	 SHORT $LN35@CollideShi
  00188	8b c7		 mov	 eax, edi
  0018a	e8 00 00 00 00	 call	 ?IsDropship@Ship@@QBE_NXZ ; Ship::IsDropship
  0018f	84 c0		 test	 al, al
  00191	74 08		 je	 SHORT $LN35@CollideShi
  00193	3b fa		 cmp	 edi, edx
  00195	0f 85 57 05 00
	00		 jne	 $LN22@CollideShi
$LN35@CollideShi:

; 2967 : 			continue;
; 2968 : 
; 2969 : 			// don't collide with own runway!
; 2970 : 			if (ship->IsAirborne() && ship->GetCarrier() == targ)

  0019b	8b c3		 mov	 eax, ebx
  0019d	e8 00 00 00 00	 call	 ?IsAirborne@Ship@@QBE_NXZ ; Ship::IsAirborne
  001a2	84 c0		 test	 al, al
  001a4	74 0c		 je	 SHORT $LN34@CollideShi
  001a6	39 bb 2c 04 00
	00		 cmp	 DWORD PTR [ebx+1068], edi
  001ac	0f 84 40 05 00
	00		 je	 $LN22@CollideShi
$LN34@CollideShi:

; 2971 : 			continue;
; 2972 : 			if (targ->IsAirborne() && targ->GetCarrier() == ship)

  001b2	8b c7		 mov	 eax, edi
  001b4	e8 00 00 00 00	 call	 ?IsAirborne@Ship@@QBE_NXZ ; Ship::IsAirborne
  001b9	84 c0		 test	 al, al
  001bb	74 0c		 je	 SHORT $LN33@CollideShi
  001bd	39 9f 2c 04 00
	00		 cmp	 DWORD PTR [edi+1068], ebx
  001c3	0f 84 29 05 00
	00		 je	 $LN22@CollideShi
$LN33@CollideShi:

; 2973 : 			continue;
; 2974 : 
; 2975 : 			// impact:
; 2976 : 			if (ship->CollidesWith(*targ)) {

  001c9	8b 13		 mov	 edx, DWORD PTR [ebx]
  001cb	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  001ce	57		 push	 edi
  001cf	8b cb		 mov	 ecx, ebx
  001d1	ff d0		 call	 eax
  001d3	85 c0		 test	 eax, eax
  001d5	0f 84 17 05 00
	00		 je	 $LN22@CollideShi

; 2977 : 				Vec3 tv1 = targ->Velocity();

  001db	f2 0f 10 87 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [edi+168]
  001e3	f2 0f 58 87 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [edi+192]
  001eb	f2 0f 10 8f c8
	00 00 00	 movsd	 xmm1, QWORD PTR [edi+200]
  001f3	f2 0f 58 8f b0
	00 00 00	 addsd	 xmm1, QWORD PTR [edi+176]
  001fb	f2 0f 10 97 b8
	00 00 00	 movsd	 xmm2, QWORD PTR [edi+184]
  00203	f2 0f 58 97 d0
	00 00 00	 addsd	 xmm2, QWORD PTR [edi+208]
  0020b	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0020f	f3 0f 11 84 24
	bc 00 00 00	 movss	 DWORD PTR $T406509[esp+388], xmm0

; 2978 : 				Vec3 sv1 = ship->Velocity();
; 2979 : 
; 2980 : 				Physical::SemiElasticCollision(*ship, *targ);

  00218	57		 push	 edi
  00219	53		 push	 ebx
  0021a	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  0021e	f2 0f 10 8b c8
	00 00 00	 movsd	 xmm1, QWORD PTR [ebx+200]
  00226	f2 0f 58 8b b0
	00 00 00	 addsd	 xmm1, QWORD PTR [ebx+176]
  0022e	f3 0f 11 84 24
	d4 00 00 00	 movss	 DWORD PTR $T406508[esp+396], xmm0
  00237	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  0023b	f2 0f 10 93 b8
	00 00 00	 movsd	 xmm2, QWORD PTR [ebx+184]
  00243	f2 0f 58 93 d0
	00 00 00	 addsd	 xmm2, QWORD PTR [ebx+208]
  0024b	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR $T406507[esp+396], xmm0
  00254	f2 0f 10 83 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+168]
  0025c	f2 0f 58 83 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [ebx+192]
  00264	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00268	f3 0f 11 84 24
	f8 00 00 00	 movss	 DWORD PTR $T406540[esp+396], xmm0
  00271	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00275	f3 0f 11 84 24
	ac 00 00 00	 movss	 DWORD PTR $T406539[esp+396], xmm0
  0027e	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  00282	f3 0f 11 84 24
	b4 00 00 00	 movss	 DWORD PTR $T406538[esp+396], xmm0
  0028b	e8 00 00 00 00	 call	 ?SemiElasticCollision@Physical@@SAXAAV1@0@Z ; Physical::SemiElasticCollision

; 2981 : 
; 2982 : 				Vec3 tv2 = targ->Velocity();

  00290	f2 0f 10 87 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [edi+168]
  00298	f2 0f 58 87 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [edi+192]
  002a0	f2 0f 10 8f c8
	00 00 00	 movsd	 xmm1, QWORD PTR [edi+200]
  002a8	f2 0f 58 8f b0
	00 00 00	 addsd	 xmm1, QWORD PTR [edi+176]
  002b0	f2 0f 10 97 b8
	00 00 00	 movsd	 xmm2, QWORD PTR [edi+184]
  002b8	f2 0f 58 97 d0
	00 00 00	 addsd	 xmm2, QWORD PTR [edi+208]

; 2983 : 				Vec3 sv2 = ship->Velocity();
; 2984 : 
; 2985 : 				double dvs = (sv2-sv1).length();

  002c0	f3 0f 10 9c 24
	f8 00 00 00	 movss	 xmm3, DWORD PTR $T406540[esp+396]
  002c9	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  002cd	f3 0f 11 84 24
	bc 00 00 00	 movss	 DWORD PTR $T406571[esp+396], xmm0
  002d6	0f 5a db	 cvtps2pd xmm3, xmm3
  002d9	83 c4 04	 add	 esp, 4
  002dc	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  002e0	f2 0f 10 8b c8
	00 00 00	 movsd	 xmm1, QWORD PTR [ebx+200]
  002e8	f2 0f 58 8b b0
	00 00 00	 addsd	 xmm1, QWORD PTR [ebx+176]
  002f0	f3 0f 11 84 24
	c8 00 00 00	 movss	 DWORD PTR $T406570[esp+392], xmm0
  002f9	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  002fd	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00301	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  00305	f2 0f 10 93 b8
	00 00 00	 movsd	 xmm2, QWORD PTR [ebx+184]
  0030d	f2 0f 58 93 d0
	00 00 00	 addsd	 xmm2, QWORD PTR [ebx+208]
  00315	f3 0f 11 84 24
	f8 00 00 00	 movss	 DWORD PTR $T406569[esp+392], xmm0
  0031e	f2 0f 10 83 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+168]
  00326	f2 0f 58 83 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [ebx+192]
  0032e	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00332	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00336	f2 0f 5c c3	 subsd	 xmm0, xmm3
  0033a	f3 0f 10 9c 24
	a8 00 00 00	 movss	 xmm3, DWORD PTR $T406539[esp+392]
  00343	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  00347	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0034b	0f 5a db	 cvtps2pd xmm3, xmm3
  0034e	f2 0f 5c cb	 subsd	 xmm1, xmm3
  00352	f3 0f 10 9c 24
	b0 00 00 00	 movss	 xmm3, DWORD PTR $T406538[esp+392]
  0035b	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  0035f	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00363	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00367	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0036b	0f 5a db	 cvtps2pd xmm3, xmm3
  0036e	f2 0f 5c d3	 subsd	 xmm2, xmm3
  00372	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00376	66 0f 5a d2	 cvtpd2ps xmm2, xmm2
  0037a	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  0037e	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  00382	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00386	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  0038a	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0038e	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00392	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00397	e8 00 00 00 00	 call	 _sqrtf
  0039c	dd 5c 24 78	 fstp	 QWORD PTR _dvs$120885[esp+392]

; 2986 : 				double dvt = (tv2-tv1).length();

  003a0	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR $T406571[esp+392]
  003a9	f3 0f 10 8c 24
	c0 00 00 00	 movss	 xmm1, DWORD PTR $T406509[esp+392]
  003b2	0f 5a c0	 cvtps2pd xmm0, xmm0
  003b5	0f 5a c9	 cvtps2pd xmm1, xmm1
  003b8	f2 0f 5c c1	 subsd	 xmm0, xmm1
  003bc	f3 0f 10 94 24
	d0 00 00 00	 movss	 xmm2, DWORD PTR $T406508[esp+392]
  003c5	f3 0f 10 8c 24
	c8 00 00 00	 movss	 xmm1, DWORD PTR $T406570[esp+392]
  003ce	f3 0f 10 9c 24
	8c 00 00 00	 movss	 xmm3, DWORD PTR $T406507[esp+392]
  003d7	0f 5a d2	 cvtps2pd xmm2, xmm2
  003da	0f 5a c9	 cvtps2pd xmm1, xmm1
  003dd	f2 0f 5c ca	 subsd	 xmm1, xmm2
  003e1	f3 0f 10 94 24
	f8 00 00 00	 movss	 xmm2, DWORD PTR $T406569[esp+392]
  003ea	0f 5a d2	 cvtps2pd xmm2, xmm2
  003ed	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003f1	f2 0f 5a c9	 cvtsd2ss xmm1, xmm1
  003f5	0f 5a db	 cvtps2pd xmm3, xmm3
  003f8	f2 0f 5c d3	 subsd	 xmm2, xmm3
  003fc	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00400	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00404	f2 0f 5a d2	 cvtsd2ss xmm2, xmm2
  00408	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0040c	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00410	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00414	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  00418	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  0041c	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00420	0f 57 c0	 xorps	 xmm0, xmm0
  00423	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  00427	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0042c	e8 00 00 00 00	 call	 _sqrtf
  00431	dd 9c 24 d8 00
	00 00		 fstp	 QWORD PTR _dvt$120887[esp+392]

; 2987 : 
; 2988 : 				if (dvs > 20) dvs *= dvs;

  00438	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4034000000000000
  0043e	83 c4 04	 add	 esp, 4
  00441	dd 44 24 74	 fld	 QWORD PTR _dvs$120885[esp+388]
  00445	df f1		 fcomip	 ST(1)
  00447	dd d8		 fstp	 ST(0)
  00449	76 10		 jbe	 SHORT $LN31@CollideShi
  0044b	f2 0f 10 44 24
	74		 movsd	 xmm0, QWORD PTR _dvs$120885[esp+388]
  00451	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00455	f2 0f 11 44 24
	74		 movsd	 QWORD PTR _dvs$120885[esp+388], xmm0
$LN31@CollideShi:

; 2989 : 				if (dvt > 20) dvt *= dvt;

  0045b	f2 0f 10 84 24
	d4 00 00 00	 movsd	 xmm0, QWORD PTR _dvt$120887[esp+388]
  00464	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4034000000000000
  0046c	76 0d		 jbe	 SHORT $LN30@CollideShi
  0046e	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00472	f2 0f 11 84 24
	d4 00 00 00	 movsd	 QWORD PTR _dvt$120887[esp+388], xmm0
$LN30@CollideShi:

; 2990 : 
; 2991 : 				if (!NetGame::IsNetGameClient()) {

  0047b	e8 00 00 00 00	 call	 ?IsNetGameClient@NetGame@@SA_NXZ ; NetGame::IsNetGameClient
  00480	84 c0		 test	 al, al
  00482	0f 85 f7 00 00
	00		 jne	 $LN29@CollideShi

; 2992 : 					double old_integrity = ship->Integrity();

  00488	f3 0f 10 83 b8
	01 00 00	 movss	 xmm0, DWORD PTR [ebx+440]

; 2993 : 					ship->InflictDamage(dvs);

  00490	83 ec 18	 sub	 esp, 24			; 00000018H
  00493	8b c4		 mov	 eax, esp
  00495	0f 5a c0	 cvtps2pd xmm0, xmm0
  00498	89 64 24 70	 mov	 DWORD PTR $T406408[esp+412], esp
  0049c	f2 0f 11 84 24
	fc 00 00 00	 movsd	 QWORD PTR _old_integrity$120892[esp+412], xmm0
  004a5	0f 57 c0	 xorps	 xmm0, xmm0
  004a8	6a 03		 push	 3
  004aa	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  004ae	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0
  004b3	f2 0f 11 40 10	 movsd	 QWORD PTR [eax+16], xmm0
  004b8	8b 13		 mov	 edx, DWORD PTR [ebx]
  004ba	f2 0f 10 84 24
	90 00 00 00	 movsd	 xmm0, QWORD PTR _dvs$120885[esp+416]
  004c3	8b 82 6c 01 00
	00		 mov	 eax, DWORD PTR [edx+364]
  004c9	6a 00		 push	 0
  004cb	83 ec 08	 sub	 esp, 8
  004ce	8b cb		 mov	 ecx, ebx
  004d0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004d5	ff d0		 call	 eax
  004d7	dd d8		 fstp	 ST(0)

; 2994 : 					double hull_damage = old_integrity - ship->Integrity();
; 2995 : 					NetUtil::SendObjDamage(ship, hull_damage);

  004d9	f3 0f 10 83 b8
	01 00 00	 movss	 xmm0, DWORD PTR [ebx+440]
  004e1	0f 5a c8	 cvtps2pd xmm1, xmm0
  004e4	f2 0f 10 84 24
	e4 00 00 00	 movsd	 xmm0, QWORD PTR _old_integrity$120892[esp+388]
  004ed	6a 00		 push	 0
  004ef	83 ec 08	 sub	 esp, 8
  004f2	f2 0f 5c c1	 subsd	 xmm0, xmm1
  004f6	8b f3		 mov	 esi, ebx
  004f8	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004fd	e8 00 00 00 00	 call	 ?SendObjDamage@NetUtil@@SAXPAVSimObject@@NPAVShot@@@Z ; NetUtil::SendObjDamage

; 2996 : 
; 2997 : 					old_integrity = targ->Integrity();

  00502	f3 0f 10 87 b8
	01 00 00	 movss	 xmm0, DWORD PTR [edi+440]

; 2998 : 					targ->InflictDamage(dvt);

  0050a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0050d	8b c4		 mov	 eax, esp
  0050f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00512	89 64 24 70	 mov	 DWORD PTR $T406409[esp+412], esp
  00516	f2 0f 11 84 24
	fc 00 00 00	 movsd	 QWORD PTR _old_integrity$120892[esp+412], xmm0
  0051f	0f 57 c0	 xorps	 xmm0, xmm0
  00522	6a 03		 push	 3
  00524	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  00528	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0
  0052d	f2 0f 11 40 10	 movsd	 QWORD PTR [eax+16], xmm0
  00532	8b 17		 mov	 edx, DWORD PTR [edi]
  00534	f2 0f 10 84 24
	f0 00 00 00	 movsd	 xmm0, QWORD PTR _dvt$120887[esp+416]
  0053d	8b 82 6c 01 00
	00		 mov	 eax, DWORD PTR [edx+364]
  00543	6a 00		 push	 0
  00545	83 ec 08	 sub	 esp, 8
  00548	8b cf		 mov	 ecx, edi
  0054a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0054f	ff d0		 call	 eax
  00551	dd d8		 fstp	 ST(0)

; 2999 : 					hull_damage = old_integrity - targ->Integrity();

  00553	f3 0f 10 87 b8
	01 00 00	 movss	 xmm0, DWORD PTR [edi+440]
  0055b	0f 5a c8	 cvtps2pd xmm1, xmm0
  0055e	f2 0f 10 84 24
	e4 00 00 00	 movsd	 xmm0, QWORD PTR _old_integrity$120892[esp+388]

; 3000 : 					NetUtil::SendObjDamage(targ, hull_damage);

  00567	6a 00		 push	 0
  00569	83 ec 08	 sub	 esp, 8
  0056c	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00570	8b f7		 mov	 esi, edi
  00572	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00577	e8 00 00 00 00	 call	 ?SendObjDamage@NetUtil@@SAXPAVSimObject@@NPAVShot@@@Z ; NetUtil::SendObjDamage
  0057c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN29@CollideShi:

; 3001 : 				}
; 3002 : 
; 3003 : 				// then delete the ship:
; 3004 : 				if (targ->Integrity() < 1.0f) {

  0057f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00587	0f 2f 87 b8 01
	00 00		 comiss	 xmm0, DWORD PTR [edi+440]
  0058e	0f 86 a6 00 00
	00		 jbe	 $LN27@CollideShi

; 3005 : 					NetUtil::SendObjKill(targ, ship, NetObjKill::KILL_COLLISION);

  00594	6a 00		 push	 0
  00596	6a 03		 push	 3
  00598	53		 push	 ebx
  00599	8b cf		 mov	 ecx, edi
  0059b	e8 00 00 00 00	 call	 ?SendObjKill@NetUtil@@SAXPAVShip@@PBV2@HH@Z ; NetUtil::SendObjKill
  005a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3006 : 					Print("   ship %s died in collision with %s (%s)\n", targ->Name(), ship->Name(), FormatGameTime());

  005a3	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  005a6	e8 00 00 00 00	 call	 ?FormatGameTime@@YAPBDXZ ; FormatGameTime
  005ab	50		 push	 eax
  005ac	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  005af	50		 push	 eax
  005b0	56		 push	 esi
  005b1	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@IBPHLHIK@?5?5?5ship?5?$CFs?5died?5in?5collision?5wit@
  005b6	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  005bb	83 c4 10	 add	 esp, 16			; 00000010H

; 3007 : 					if (!kill_list.contains(targ)) {

  005be	8b c7		 mov	 eax, edi
  005c0	8d 4c 24 48	 lea	 ecx, DWORD PTR _kill_list$[esp+388]
  005c4	e8 00 00 00 00	 call	 ?contains@?$List@VShip@@@@QBE_NPBVShip@@@Z ; List<Ship>::contains
  005c9	84 c0		 test	 al, al
  005cb	75 6d		 jne	 SHORT $LN27@CollideShi

; 3008 : 						ShipStats* r = ShipStats::Find(targ->Name());

  005cd	8b ce		 mov	 ecx, esi
  005cf	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find

; 3009 : 						if (r) r->AddEvent(SimEvent::COLLIDE, ship->Name());

  005d4	85 c0		 test	 eax, eax
  005d6	74 0c		 je	 SHORT $LN26@CollideShi
  005d8	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  005db	51		 push	 ecx
  005dc	6a 06		 push	 6
  005de	50		 push	 eax
  005df	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
$LN26@CollideShi:

; 3010 : 
; 3011 : 						if (targ->GetIFF() > 0 && ship->GetIFF() != targ->GetIFF()) {

  005e4	8b 17		 mov	 edx, DWORD PTR [edi]
  005e6	8b 82 98 01 00
	00		 mov	 eax, DWORD PTR [edx+408]
  005ec	8b cf		 mov	 ecx, edi
  005ee	ff d0		 call	 eax
  005f0	85 c0		 test	 eax, eax
  005f2	7e 36		 jle	 SHORT $LN164@CollideShi
  005f4	8b 13		 mov	 edx, DWORD PTR [ebx]
  005f6	8b 82 98 01 00
	00		 mov	 eax, DWORD PTR [edx+408]
  005fc	8b cb		 mov	 ecx, ebx
  005fe	ff d0		 call	 eax
  00600	8b 17		 mov	 edx, DWORD PTR [edi]
  00602	8b f0		 mov	 esi, eax
  00604	8b 82 98 01 00
	00		 mov	 eax, DWORD PTR [edx+408]
  0060a	8b cf		 mov	 ecx, edi
  0060c	ff d0		 call	 eax
  0060e	3b f0		 cmp	 esi, eax
  00610	74 18		 je	 SHORT $LN164@CollideShi

; 3012 : 							r = ShipStats::Find(ship->Name());

  00612	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  00615	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  0061a	8b d0		 mov	 edx, eax

; 3013 : 							if (r) r->AddPoints(targ->Value());

  0061c	85 d2		 test	 edx, edx
  0061e	74 0a		 je	 SHORT $LN164@CollideShi
  00620	8b c7		 mov	 eax, edi
  00622	e8 00 00 00 00	 call	 ?Value@Ship@@QBEHXZ	; Ship::Value
  00627	01 42 58	 add	 DWORD PTR [edx+88], eax
$LN164@CollideShi:

; 3014 : 						}
; 3015 : 
; 3016 : 						kill_list.insert(targ);

  0062a	57		 push	 edi
  0062b	33 ff		 xor	 edi, edi
  0062d	8d 44 24 4c	 lea	 eax, DWORD PTR _kill_list$[esp+392]
  00631	e8 00 00 00 00	 call	 ?insert@?$List@VShip@@@@QAEXPBVShip@@H@Z ; List<Ship>::insert
  00636	8b 7c 24 3c	 mov	 edi, DWORD PTR _targ$120860[esp+388]
$LN27@CollideShi:

; 3017 : 					}
; 3018 : 				}
; 3019 : 
; 3020 : 				if (ship->Integrity() < 1.0f) {

  0063a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00642	0f 2f 83 b8 01
	00 00		 comiss	 xmm0, DWORD PTR [ebx+440]
  00649	0f 86 a3 00 00
	00		 jbe	 $LN22@CollideShi

; 3021 : 					NetUtil::SendObjKill(ship, targ, NetObjKill::KILL_COLLISION);

  0064f	6a 00		 push	 0
  00651	6a 03		 push	 3
  00653	57		 push	 edi
  00654	8b cb		 mov	 ecx, ebx
  00656	e8 00 00 00 00	 call	 ?SendObjKill@NetUtil@@SAXPAVShip@@PBV2@HH@Z ; NetUtil::SendObjKill
  0065b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3022 : 					Print("   ship %s died in collision with %s (%s)\n", ship->Name(), targ->Name(), FormatGameTime());

  0065e	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  00661	e8 00 00 00 00	 call	 ?FormatGameTime@@YAPBDXZ ; FormatGameTime
  00666	50		 push	 eax
  00667	56		 push	 esi
  00668	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  0066b	50		 push	 eax
  0066c	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@IBPHLHIK@?5?5?5ship?5?$CFs?5died?5in?5collision?5wit@
  00671	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00676	83 c4 10	 add	 esp, 16			; 00000010H

; 3023 : 					if (!kill_list.contains(ship)) {

  00679	8b c3		 mov	 eax, ebx
  0067b	8d 4c 24 48	 lea	 ecx, DWORD PTR _kill_list$[esp+388]
  0067f	e8 00 00 00 00	 call	 ?contains@?$List@VShip@@@@QBE_NPBVShip@@@Z ; List<Ship>::contains
  00684	84 c0		 test	 al, al
  00686	75 6a		 jne	 SHORT $LN22@CollideShi

; 3024 : 						ShipStats* r = ShipStats::Find(ship->Name());

  00688	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  0068b	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find

; 3025 : 						if (r) r->AddEvent(SimEvent::COLLIDE, targ->Name());

  00690	85 c0		 test	 eax, eax
  00692	74 09		 je	 SHORT $LN21@CollideShi
  00694	56		 push	 esi
  00695	6a 06		 push	 6
  00697	50		 push	 eax
  00698	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
$LN21@CollideShi:

; 3026 : 
; 3027 : 						if (ship->GetIFF() > 0 && ship->GetIFF() != targ->GetIFF()) {

  0069d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0069f	8b 82 98 01 00
	00		 mov	 eax, DWORD PTR [edx+408]
  006a5	8b cb		 mov	 ecx, ebx
  006a7	ff d0		 call	 eax
  006a9	85 c0		 test	 eax, eax
  006ab	7e 39		 jle	 SHORT $LN178@CollideShi
  006ad	8b 13		 mov	 edx, DWORD PTR [ebx]
  006af	8b 82 98 01 00
	00		 mov	 eax, DWORD PTR [edx+408]
  006b5	8b cb		 mov	 ecx, ebx
  006b7	ff d0		 call	 eax
  006b9	8b 17		 mov	 edx, DWORD PTR [edi]
  006bb	8b 92 98 01 00
	00		 mov	 edx, DWORD PTR [edx+408]
  006c1	8b cf		 mov	 ecx, edi
  006c3	89 44 24 3c	 mov	 DWORD PTR tv2793[esp+388], eax
  006c7	ff d2		 call	 edx
  006c9	39 44 24 3c	 cmp	 DWORD PTR tv2793[esp+388], eax
  006cd	74 17		 je	 SHORT $LN178@CollideShi

; 3028 : 							r = ShipStats::Find(targ->Name());

  006cf	8b ce		 mov	 ecx, esi
  006d1	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  006d6	8b d0		 mov	 edx, eax

; 3029 : 							if (r) r->AddPoints(ship->Value());

  006d8	85 d2		 test	 edx, edx
  006da	74 0a		 je	 SHORT $LN178@CollideShi
  006dc	8b c3		 mov	 eax, ebx
  006de	e8 00 00 00 00	 call	 ?Value@Ship@@QBEHXZ	; Ship::Value
  006e3	01 42 58	 add	 DWORD PTR [edx+88], eax
$LN178@CollideShi:

; 3030 : 						}
; 3031 : 
; 3032 : 						kill_list.insert(ship);

  006e6	53		 push	 ebx
  006e7	33 ff		 xor	 edi, edi
  006e9	8d 44 24 4c	 lea	 eax, DWORD PTR _kill_list$[esp+392]
  006ed	e8 00 00 00 00	 call	 ?insert@?$List@VShip@@@@QAEXPBVShip@@H@Z ; List<Ship>::insert
$LN22@CollideShi:

; 2949 : 		while (++targ_iter) {

  006f2	8d 54 24 6c	 lea	 edx, DWORD PTR _targ_iter$120856[esp+388]
  006f6	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  006fb	85 c0		 test	 eax, eax
  006fd	0f 85 fd f9 ff
	ff		 jne	 $LL339@CollideShi
  00703	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
$LN40@CollideShi:

; 3033 : 					}
; 3034 : 				}
; 3035 : 			}
; 3036 : 		}
; 3037 : 
; 3038 : 		ListIter<Debris> debris_iter = debris;

  00706	8d 87 a0 00 00
	00		 lea	 eax, DWORD PTR [edi+160]

; 3039 : 		while (++debris_iter) {

  0070c	8d 54 24 5c	 lea	 edx, DWORD PTR _debris_iter$120910[esp+388]
  00710	89 44 24 5c	 mov	 DWORD PTR _debris_iter$120910[esp+388], eax
  00714	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR _debris_iter$120910[esp+392], -1
  0071c	e8 00 00 00 00	 call	 ?next@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::next
  00721	85 c0		 test	 eax, eax
  00723	0f 84 85 04 00
	00		 je	 $LN17@CollideShi
  00729	8d a4 24 00 00
	00 00		 npad	 7
$LL18@CollideShi:

; 3040 : 			Debris* d = debris_iter.value();

  00730	8d 44 24 5c	 lea	 eax, DWORD PTR _debris_iter$120910[esp+388]
  00734	e8 00 00 00 00	 call	 ?value@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::value

; 3041 : 
; 3042 : 			if (d->Radius() < 50)

  00739	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4049000000000000
  00741	8b f0		 mov	 esi, eax
  00743	f3 0f 10 86 b0
	01 00 00	 movss	 xmm0, DWORD PTR [esi+432]
  0074b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0074e	66 0f 2f c8	 comisd	 xmm1, xmm0
  00752	0f 87 45 04 00
	00		 ja	 $LN11@CollideShi

; 3043 : 			continue;
; 3044 : 
; 3045 : 			if (ship->CollidesWith(*d)) {

  00758	8b 13		 mov	 edx, DWORD PTR [ebx]
  0075a	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0075d	56		 push	 esi
  0075e	8b cb		 mov	 ecx, ebx
  00760	ff d0		 call	 eax
  00762	85 c0		 test	 eax, eax
  00764	0f 84 33 04 00
	00		 je	 $LN11@CollideShi

; 3046 : 				Vec3 tv1 = d->Velocity();

  0076a	f2 0f 10 86 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+168]
  00772	f2 0f 58 86 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+192]
  0077a	f2 0f 10 8e b0
	00 00 00	 movsd	 xmm1, QWORD PTR [esi+176]
  00782	f2 0f 58 8e c8
	00 00 00	 addsd	 xmm1, QWORD PTR [esi+200]
  0078a	f2 0f 10 96 d0
	00 00 00	 movsd	 xmm2, QWORD PTR [esi+208]
  00792	f2 0f 58 96 b8
	00 00 00	 addsd	 xmm2, QWORD PTR [esi+184]
  0079a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0079e	f3 0f 11 84 24
	e0 00 00 00	 movss	 DWORD PTR $T406746[esp+388], xmm0

; 3047 : 				Vec3 sv1 = ship->Velocity();
; 3048 : 
; 3049 : 				Physical::SemiElasticCollision(*ship, *d);

  007a7	56		 push	 esi
  007a8	53		 push	 ebx
  007a9	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  007ad	f2 0f 10 8b c8
	00 00 00	 movsd	 xmm1, QWORD PTR [ebx+200]
  007b5	f2 0f 58 8b b0
	00 00 00	 addsd	 xmm1, QWORD PTR [ebx+176]
  007bd	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR $T406745[esp+396], xmm0
  007c6	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  007ca	f2 0f 10 93 b8
	00 00 00	 movsd	 xmm2, QWORD PTR [ebx+184]
  007d2	f2 0f 58 93 d0
	00 00 00	 addsd	 xmm2, QWORD PTR [ebx+208]
  007da	f3 0f 11 84 24
	f4 00 00 00	 movss	 DWORD PTR $T406744[esp+396], xmm0
  007e3	f2 0f 10 83 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+168]
  007eb	f2 0f 58 83 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [ebx+192]
  007f3	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  007f7	f3 0f 11 84 24
	08 01 00 00	 movss	 DWORD PTR $T406777[esp+396], xmm0
  00800	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00804	f3 0f 11 84 24
	d8 00 00 00	 movss	 DWORD PTR $T406776[esp+396], xmm0
  0080d	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  00811	f3 0f 11 84 24
	04 01 00 00	 movss	 DWORD PTR $T406775[esp+396], xmm0
  0081a	e8 00 00 00 00	 call	 ?SemiElasticCollision@Physical@@SAXAAV1@0@Z ; Physical::SemiElasticCollision

; 3050 : 
; 3051 : 				Vec3 tv2 = d->Velocity();

  0081f	f2 0f 10 86 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+168]
  00827	f2 0f 58 86 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+192]
  0082f	f2 0f 10 8e b0
	00 00 00	 movsd	 xmm1, QWORD PTR [esi+176]
  00837	f2 0f 58 8e c8
	00 00 00	 addsd	 xmm1, QWORD PTR [esi+200]
  0083f	f2 0f 10 96 d0
	00 00 00	 movsd	 xmm2, QWORD PTR [esi+208]
  00847	f2 0f 58 96 b8
	00 00 00	 addsd	 xmm2, QWORD PTR [esi+184]
  0084f	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00853	f3 0f 11 84 24
	b0 00 00 00	 movss	 DWORD PTR $T406808[esp+396], xmm0
  0085c	83 c4 08	 add	 esp, 8
  0085f	66 0f 5a c1	 cvtpd2ps xmm0, xmm1

; 3052 : 				Vec3 sv2 = ship->Velocity();

  00863	f2 0f 10 8b c8
	00 00 00	 movsd	 xmm1, QWORD PTR [ebx+200]
  0086b	f2 0f 58 8b b0
	00 00 00	 addsd	 xmm1, QWORD PTR [ebx+176]
  00873	f3 0f 11 84 24
	b0 00 00 00	 movss	 DWORD PTR $T406807[esp+388], xmm0
  0087c	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  00880	f2 0f 10 93 b8
	00 00 00	 movsd	 xmm2, QWORD PTR [ebx+184]
  00888	f2 0f 58 93 d0
	00 00 00	 addsd	 xmm2, QWORD PTR [ebx+208]
  00890	f3 0f 11 84 24
	b8 00 00 00	 movss	 DWORD PTR $T406806[esp+388], xmm0
  00899	f2 0f 10 83 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+168]
  008a1	f2 0f 58 83 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [ebx+192]
  008a9	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  008ad	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR $T406839[esp+388], xmm0
  008b6	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  008ba	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR $T406838[esp+388], xmm0
  008c3	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  008c7	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR $T406837[esp+388], xmm0

; 3053 : 
; 3054 : 				if (!NetGame::IsNetGameClient()) {

  008d0	e8 00 00 00 00	 call	 ?IsNetGameClient@NetGame@@SA_NXZ ; NetGame::IsNetGameClient
  008d5	84 c0		 test	 al, al
  008d7	0f 85 cf 00 00
	00		 jne	 $LN14@CollideShi

; 3055 : 					ship->InflictDamage((sv2-sv1).length());

  008dd	0f 57 c0	 xorps	 xmm0, xmm0
  008e0	f3 0f 10 8c 24
	00 01 00 00	 movss	 xmm1, DWORD PTR $T406777[esp+388]
  008e9	f3 0f 10 94 24
	d0 00 00 00	 movss	 xmm2, DWORD PTR $T406776[esp+388]
  008f2	f3 0f 10 9c 24
	fc 00 00 00	 movss	 xmm3, DWORD PTR $T406775[esp+388]
  008fb	0f 5a c9	 cvtps2pd xmm1, xmm1
  008fe	83 ec 18	 sub	 esp, 24			; 00000018H
  00901	8b c4		 mov	 eax, esp
  00903	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  00907	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0
  0090c	f2 0f 11 40 10	 movsd	 QWORD PTR [eax+16], xmm0
  00911	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR $T406839[esp+412]
  0091a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0091d	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00921	f3 0f 10 8c 24
	b0 00 00 00	 movss	 xmm1, DWORD PTR $T406838[esp+412]
  0092a	0f 5a d2	 cvtps2pd xmm2, xmm2
  0092d	0f 5a c9	 cvtps2pd xmm1, xmm1
  00930	f2 0f 5c ca	 subsd	 xmm1, xmm2
  00934	f3 0f 10 94 24
	b8 00 00 00	 movss	 xmm2, DWORD PTR $T406837[esp+412]
  0093d	0f 5a d2	 cvtps2pd xmm2, xmm2
  00940	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00944	f2 0f 5a c9	 cvtsd2ss xmm1, xmm1
  00948	0f 5a db	 cvtps2pd xmm3, xmm3
  0094b	f2 0f 5c d3	 subsd	 xmm2, xmm3
  0094f	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00953	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00957	f2 0f 5a d2	 cvtsd2ss xmm2, xmm2
  0095b	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0095f	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00963	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00967	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  0096b	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  0096f	89 64 24 70	 mov	 DWORD PTR $T406418[esp+412], esp
  00973	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00977	0f 57 c0	 xorps	 xmm0, xmm0
  0097a	51		 push	 ecx
  0097b	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  0097f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00984	e8 00 00 00 00	 call	 _sqrtf
  00989	d9 5c 24 58	 fstp	 DWORD PTR $T406868[esp+416]
  0098d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0098f	d9 44 24 58	 fld	 DWORD PTR $T406868[esp+416]
  00993	8b 82 6c 01 00
	00		 mov	 eax, DWORD PTR [edx+364]
  00999	83 c4 04	 add	 esp, 4
  0099c	6a 03		 push	 3
  0099e	6a 00		 push	 0
  009a0	83 ec 08	 sub	 esp, 8
  009a3	8b cb		 mov	 ecx, ebx
  009a5	dd 1c 24	 fstp	 QWORD PTR [esp]
  009a8	ff d0		 call	 eax
  009aa	dd d8		 fstp	 ST(0)
$LN14@CollideShi:

; 3056 : 				}
; 3057 : 
; 3058 : 				d->InflictDamage((tv2-tv1).length());

  009ac	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR $T406808[esp+388]
  009b5	f3 0f 10 8c 24
	e0 00 00 00	 movss	 xmm1, DWORD PTR $T406746[esp+388]
  009be	f3 0f 10 94 24
	80 00 00 00	 movss	 xmm2, DWORD PTR $T406745[esp+388]
  009c7	f3 0f 10 9c 24
	ec 00 00 00	 movss	 xmm3, DWORD PTR $T406744[esp+388]
  009d0	0f 5a c9	 cvtps2pd xmm1, xmm1
  009d3	0f 5a c0	 cvtps2pd xmm0, xmm0
  009d6	f2 0f 5c c1	 subsd	 xmm0, xmm1
  009da	f3 0f 10 8c 24
	b0 00 00 00	 movss	 xmm1, DWORD PTR $T406807[esp+388]
  009e3	0f 5a d2	 cvtps2pd xmm2, xmm2
  009e6	0f 5a c9	 cvtps2pd xmm1, xmm1
  009e9	f2 0f 5c ca	 subsd	 xmm1, xmm2
  009ed	f3 0f 10 94 24
	b8 00 00 00	 movss	 xmm2, DWORD PTR $T406806[esp+388]
  009f6	0f 5a d2	 cvtps2pd xmm2, xmm2
  009f9	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  009fd	f2 0f 5a c9	 cvtsd2ss xmm1, xmm1
  00a01	0f 5a db	 cvtps2pd xmm3, xmm3
  00a04	f2 0f 5c d3	 subsd	 xmm2, xmm3
  00a08	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00a0c	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00a10	f2 0f 5a d2	 cvtsd2ss xmm2, xmm2
  00a14	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00a18	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00a1c	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00a20	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  00a24	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  00a28	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00a2c	0f 57 c0	 xorps	 xmm0, xmm0
  00a2f	51		 push	 ecx
  00a30	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  00a34	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a39	e8 00 00 00 00	 call	 _sqrtf
  00a3e	d9 5c 24 40	 fstp	 DWORD PTR $T406889[esp+392]
  00a42	8b 16		 mov	 edx, DWORD PTR [esi]
  00a44	d9 44 24 40	 fld	 DWORD PTR $T406889[esp+392]
  00a48	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00a4b	83 c4 04	 add	 esp, 4
  00a4e	6a 00		 push	 0
  00a50	83 ec 08	 sub	 esp, 8
  00a53	8b ce		 mov	 ecx, esi
  00a55	dd 1c 24	 fstp	 QWORD PTR [esp]
  00a58	ff d0		 call	 eax

; 3059 : 
; 3060 : 				// then delete the debris:
; 3061 : 				if (d->Integrity() < 1.0f) {

  00a5a	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00a62	0f 2f 9e b8 01
	00 00		 comiss	 xmm3, DWORD PTR [esi+440]
  00a69	0f 86 bd 00 00
	00		 jbe	 $LN49@CollideShi

; 3062 : 					sim->CreateExplosion(d->Location(), d->Velocity(), Explosion::LARGE_EXPLOSION, 1.0f, 1.0f, this);

  00a6f	f2 0f 10 86 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+168]
  00a77	f2 0f 58 86 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+192]
  00a7f	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00a82	f2 0f 10 8e b0
	00 00 00	 movsd	 xmm1, QWORD PTR [esi+176]
  00a8a	f2 0f 10 96 d0
	00 00 00	 movsd	 xmm2, QWORD PTR [esi+208]
  00a92	f2 0f 58 8e c8
	00 00 00	 addsd	 xmm1, QWORD PTR [esi+200]
  00a9a	f2 0f 58 96 b8
	00 00 00	 addsd	 xmm2, QWORD PTR [esi+184]
  00aa2	6a 00		 push	 0
  00aa4	57		 push	 edi
  00aa5	83 ec 08	 sub	 esp, 8
  00aa8	f2 0f 11 84 24
	24 01 00 00	 movsd	 QWORD PTR $T406421[esp+404], xmm0
  00ab1	f2 0f 10 46 48	 movsd	 xmm0, QWORD PTR [esi+72]
  00ab6	f3 0f 11 5c 24
	04		 movss	 DWORD PTR [esp+4], xmm3
  00abc	f3 0f 11 1c 24	 movss	 DWORD PTR [esp], xmm3
  00ac1	f2 0f 11 84 24
	3c 01 00 00	 movsd	 QWORD PTR $T406422[esp+404], xmm0
  00aca	f2 0f 10 46 50	 movsd	 xmm0, QWORD PTR [esi+80]
  00acf	6a 0b		 push	 11			; 0000000bH
  00ad1	f2 0f 11 84 24
	48 01 00 00	 movsd	 QWORD PTR $T406422[esp+416], xmm0
  00ada	f2 0f 10 46 58	 movsd	 xmm0, QWORD PTR [esi+88]
  00adf	51		 push	 ecx
  00ae0	8d bc 24 2c 01
	00 00		 lea	 edi, DWORD PTR $T406421[esp+412]
  00ae7	8d 8c 24 44 01
	00 00		 lea	 ecx, DWORD PTR $T406422[esp+412]
  00aee	f2 0f 11 8c 24
	34 01 00 00	 movsd	 QWORD PTR $T406421[esp+420], xmm1
  00af7	f2 0f 11 94 24
	3c 01 00 00	 movsd	 QWORD PTR $T406421[esp+428], xmm2
  00b00	f2 0f 11 84 24
	54 01 00 00	 movsd	 QWORD PTR $T406422[esp+428], xmm0
  00b09	e8 00 00 00 00	 call	 ?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z ; Sim::CreateExplosion

; 3063 : 					debris_iter.removeItem();

  00b0e	8d 54 24 5c	 lea	 edx, DWORD PTR _debris_iter$120910[esp+388]
  00b12	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::removeItem

; 3064 : 					delete d;

  00b17	8b 16		 mov	 edx, DWORD PTR [esi]
  00b19	8b 02		 mov	 eax, DWORD PTR [edx]
  00b1b	6a 01		 push	 1
  00b1d	8b ce		 mov	 ecx, esi
  00b1f	ff d0		 call	 eax
  00b21	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00b29	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
$LN49@CollideShi:

; 3065 : 				}
; 3066 : 
; 3067 : 				if (ship->Integrity() < 1.0f) {

  00b2c	0f 2f 9b b8 01
	00 00		 comiss	 xmm3, DWORD PTR [ebx+440]
  00b33	76 68		 jbe	 SHORT $LN11@CollideShi

; 3068 : 					if (!kill_list.contains(ship)) {

  00b35	8b c3		 mov	 eax, ebx
  00b37	8d 4c 24 48	 lea	 ecx, DWORD PTR _kill_list$[esp+388]
  00b3b	e8 00 00 00 00	 call	 ?contains@?$List@VShip@@@@QBE_NPBVShip@@@Z ; List<Ship>::contains
  00b40	84 c0		 test	 al, al
  00b42	75 59		 jne	 SHORT $LN11@CollideShi

; 3069 : 						ShipStats* r = ShipStats::Find(ship->Name());

  00b44	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  00b47	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  00b4c	8b f0		 mov	 esi, eax

; 3070 : 						if (r) r->AddEvent(SimEvent::COLLIDE, Game::GetText("DEBRIS"));

  00b4e	85 f6		 test	 esi, esi
  00b50	74 3c		 je	 SHORT $LN10@CollideShi
  00b52	8d 8c 24 04 01
	00 00		 lea	 ecx, DWORD PTR $T406427[esp+388]
  00b59	68 00 00 00 00	 push	 OFFSET ??_C@_06CAKIJOOM@DEBRIS?$AA@
  00b5e	51		 push	 ecx
  00b5f	e8 00 00 00 00	 call	 ?GetText@Game@@SA?AVText@@PBD@Z ; Game::GetText
  00b64	83 c4 08	 add	 esp, 8
  00b67	c6 84 24 80 01
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+396], 1
  00b6f	8b 00		 mov	 eax, DWORD PTR [eax]
  00b71	50		 push	 eax
  00b72	6a 06		 push	 6
  00b74	56		 push	 esi
  00b75	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
  00b7a	8d 8c 24 04 01
	00 00		 lea	 ecx, DWORD PTR $T406427[esp+388]
  00b81	c6 84 24 80 01
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+396], 0
  00b89	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
$LN10@CollideShi:

; 3071 : 
; 3072 : 						kill_list.insert(ship);

  00b8e	53		 push	 ebx
  00b8f	33 ff		 xor	 edi, edi
  00b91	8d 44 24 4c	 lea	 eax, DWORD PTR _kill_list$[esp+392]
  00b95	e8 00 00 00 00	 call	 ?insert@?$List@VShip@@@@QAEXPBVShip@@H@Z ; List<Ship>::insert
  00b9a	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
$LN11@CollideShi:

; 3039 : 		while (++debris_iter) {

  00b9d	8d 54 24 5c	 lea	 edx, DWORD PTR _debris_iter$120910[esp+388]
  00ba1	e8 00 00 00 00	 call	 ?next@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::next
  00ba6	85 c0		 test	 eax, eax
  00ba8	0f 85 82 fb ff
	ff		 jne	 $LL18@CollideShi
$LN17@CollideShi:

; 3073 : 					}
; 3074 : 				}
; 3075 : 			}
; 3076 : 		}
; 3077 : 
; 3078 : 		ListIter<Asteroid> a_iter = asteroids;

  00bae	8d 97 ac 00 00
	00		 lea	 edx, DWORD PTR [edi+172]
  00bb4	89 54 24 64	 mov	 DWORD PTR _a_iter$120949[esp+388], edx

; 3079 : 		while (++a_iter) {

  00bb8	8d 54 24 64	 lea	 edx, DWORD PTR _a_iter$120949[esp+388]
  00bbc	c7 44 24 68 ff
	ff ff ff	 mov	 DWORD PTR _a_iter$120949[esp+392], -1
  00bc4	e8 00 00 00 00	 call	 ?next@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::next
  00bc9	85 c0		 test	 eax, eax
  00bcb	0f 84 46 02 00
	00		 je	 $LN8@CollideShi
$LL9@CollideShi:

; 3080 : 			Asteroid* a = a_iter.value();

  00bd1	8d 44 24 64	 lea	 eax, DWORD PTR _a_iter$120949[esp+388]
  00bd5	e8 00 00 00 00	 call	 ?value@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::value
  00bda	8b f0		 mov	 esi, eax

; 3081 : 
; 3082 : 			if (ship->CollidesWith(*a)) {

  00bdc	8b 03		 mov	 eax, DWORD PTR [ebx]
  00bde	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  00be1	56		 push	 esi
  00be2	8b cb		 mov	 ecx, ebx
  00be4	ff d2		 call	 edx
  00be6	85 c0		 test	 eax, eax
  00be8	0f 84 18 02 00
	00		 je	 $LN4@CollideShi

; 3083 : 				Vec3 sv1 = ship->Velocity();

  00bee	f2 0f 10 83 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+168]
  00bf6	f2 0f 58 83 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [ebx+192]
  00bfe	f2 0f 10 8b c8
	00 00 00	 movsd	 xmm1, QWORD PTR [ebx+200]
  00c06	f2 0f 58 8b b0
	00 00 00	 addsd	 xmm1, QWORD PTR [ebx+176]
  00c0e	f2 0f 10 93 b8
	00 00 00	 movsd	 xmm2, QWORD PTR [ebx+184]
  00c16	f2 0f 58 93 d0
	00 00 00	 addsd	 xmm2, QWORD PTR [ebx+208]
  00c1e	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00c22	f3 0f 11 84 24
	f8 00 00 00	 movss	 DWORD PTR $T406972[esp+388], xmm0

; 3084 : 				Physical::SemiElasticCollision(*ship, *a);

  00c2b	56		 push	 esi
  00c2c	53		 push	 ebx
  00c2d	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00c31	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR $T406971[esp+396], xmm0
  00c3a	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  00c3e	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR $T406970[esp+396], xmm0
  00c47	e8 00 00 00 00	 call	 ?SemiElasticCollision@Physical@@SAXAAV1@0@Z ; Physical::SemiElasticCollision

; 3085 : 				Vec3 sv2 = ship->Velocity();

  00c4c	f2 0f 10 83 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+168]
  00c54	f2 0f 58 83 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [ebx+192]
  00c5c	f2 0f 10 8b c8
	00 00 00	 movsd	 xmm1, QWORD PTR [ebx+200]
  00c64	f2 0f 58 8b b0
	00 00 00	 addsd	 xmm1, QWORD PTR [ebx+176]
  00c6c	f2 0f 10 93 b8
	00 00 00	 movsd	 xmm2, QWORD PTR [ebx+184]
  00c74	f2 0f 58 93 d0
	00 00 00	 addsd	 xmm2, QWORD PTR [ebx+208]
  00c7c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00c80	f3 0f 11 84 24
	c8 00 00 00	 movss	 DWORD PTR $T407003[esp+396], xmm0
  00c89	83 c4 08	 add	 esp, 8
  00c8c	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00c90	f3 0f 11 84 24
	84 00 00 00	 movss	 DWORD PTR $T407002[esp+388], xmm0
  00c99	0f 57 c0	 xorps	 xmm0, xmm0
  00c9c	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  00ca0	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR $T407001[esp+388], xmm0

; 3086 : 
; 3087 : 				if (!NetGame::IsNetGameClient()) {

  00ca9	e8 00 00 00 00	 call	 ?IsNetGameClient@NetGame@@SA_NXZ ; NetGame::IsNetGameClient
  00cae	84 c0		 test	 al, al
  00cb0	0f 85 d7 00 00
	00		 jne	 $LN6@CollideShi

; 3088 : 					ship->InflictDamage((sv2-sv1).length() * 10);

  00cb6	0f 57 c0	 xorps	 xmm0, xmm0
  00cb9	f3 0f 10 8c 24
	f8 00 00 00	 movss	 xmm1, DWORD PTR $T406972[esp+388]
  00cc2	f3 0f 10 94 24
	8c 00 00 00	 movss	 xmm2, DWORD PTR $T406971[esp+388]
  00ccb	f3 0f 10 9c 24
	9c 00 00 00	 movss	 xmm3, DWORD PTR $T406970[esp+388]
  00cd4	83 ec 18	 sub	 esp, 24			; 00000018H
  00cd7	8b c4		 mov	 eax, esp
  00cd9	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  00cdd	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0
  00ce2	f2 0f 11 40 10	 movsd	 QWORD PTR [eax+16], xmm0
  00ce7	f3 0f 10 84 24
	d8 00 00 00	 movss	 xmm0, DWORD PTR $T407003[esp+412]
  00cf0	0f 5a c0	 cvtps2pd xmm0, xmm0
  00cf3	0f 5a c9	 cvtps2pd xmm1, xmm1
  00cf6	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00cfa	0f 57 c9	 xorps	 xmm1, xmm1
  00cfd	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
  00d01	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR $T407002[esp+412]
  00d0a	0f 5a d2	 cvtps2pd xmm2, xmm2
  00d0d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00d10	f2 0f 5c c2	 subsd	 xmm0, xmm2
  00d14	f3 0f 10 94 24
	ac 00 00 00	 movss	 xmm2, DWORD PTR $T407001[esp+412]
  00d1d	0f 5a d2	 cvtps2pd xmm2, xmm2
  00d20	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00d24	0f 5a db	 cvtps2pd xmm3, xmm3
  00d27	f2 0f 5c d3	 subsd	 xmm2, xmm3
  00d2b	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00d2f	0f 5a c9	 cvtps2pd xmm1, xmm1
  00d32	f2 0f 5a d2	 cvtsd2ss xmm2, xmm2
  00d36	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00d3a	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00d3e	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00d42	f3 0f 5a d2	 cvtss2sd xmm2, xmm2
  00d46	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  00d4a	89 64 24 70	 mov	 DWORD PTR $T406432[esp+412], esp
  00d4e	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00d52	0f 57 c0	 xorps	 xmm0, xmm0
  00d55	51		 push	 ecx
  00d56	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00d5a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d5f	e8 00 00 00 00	 call	 _sqrtf
  00d64	d9 5c 24 58	 fstp	 DWORD PTR $T407032[esp+416]
  00d68	d9 44 24 58	 fld	 DWORD PTR $T407032[esp+416]
  00d6c	8b 03		 mov	 eax, DWORD PTR [ebx]
  00d6e	dc 0d 00 00 00
	00		 fmul	 QWORD PTR _DEFAULT_TRACK_AGE
  00d74	8b 90 6c 01 00
	00		 mov	 edx, DWORD PTR [eax+364]
  00d7a	83 c4 04	 add	 esp, 4
  00d7d	6a 03		 push	 3
  00d7f	6a 00		 push	 0
  00d81	83 ec 08	 sub	 esp, 8
  00d84	8b cb		 mov	 ecx, ebx
  00d86	dd 1c 24	 fstp	 QWORD PTR [esp]
  00d89	ff d2		 call	 edx
  00d8b	dd d8		 fstp	 ST(0)
$LN6@CollideShi:

; 3089 : 				}
; 3090 : 
; 3091 : 				if (ship->Integrity() < 1.0f) {

  00d8d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00d95	0f 2f 83 b8 01
	00 00		 comiss	 xmm0, DWORD PTR [ebx+440]
  00d9c	76 68		 jbe	 SHORT $LN4@CollideShi

; 3092 : 					if (!kill_list.contains(ship)) {

  00d9e	8b c3		 mov	 eax, ebx
  00da0	8d 4c 24 48	 lea	 ecx, DWORD PTR _kill_list$[esp+388]
  00da4	e8 00 00 00 00	 call	 ?contains@?$List@VShip@@@@QBE_NPBVShip@@@Z ; List<Ship>::contains
  00da9	84 c0		 test	 al, al
  00dab	75 59		 jne	 SHORT $LN4@CollideShi

; 3093 : 						ShipStats* r = ShipStats::Find(ship->Name());

  00dad	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  00db0	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  00db5	8b f0		 mov	 esi, eax

; 3094 : 						if (r) r->AddEvent(SimEvent::COLLIDE, Game::GetText("ASTEROID"));

  00db7	85 f6		 test	 esi, esi
  00db9	74 3c		 je	 SHORT $LN3@CollideShi
  00dbb	8d 84 24 0c 01
	00 00		 lea	 eax, DWORD PTR $T406434[esp+388]
  00dc2	68 00 00 00 00	 push	 OFFSET ??_C@_08OJEDLGMF@ASTEROID?$AA@
  00dc7	50		 push	 eax
  00dc8	e8 00 00 00 00	 call	 ?GetText@Game@@SA?AVText@@PBD@Z ; Game::GetText
  00dcd	83 c4 08	 add	 esp, 8
  00dd0	c6 84 24 80 01
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+396], 2
  00dd8	8b 00		 mov	 eax, DWORD PTR [eax]
  00dda	50		 push	 eax
  00ddb	6a 06		 push	 6
  00ddd	56		 push	 esi
  00dde	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
  00de3	8d 8c 24 0c 01
	00 00		 lea	 ecx, DWORD PTR $T406434[esp+388]
  00dea	c6 84 24 80 01
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+396], 0
  00df2	e8 00 00 00 00	 call	 ??1Text@@QAE@XZ		; Text::~Text
$LN3@CollideShi:

; 3095 : 
; 3096 : 						kill_list.insert(ship);

  00df7	53		 push	 ebx
  00df8	33 ff		 xor	 edi, edi
  00dfa	8d 44 24 4c	 lea	 eax, DWORD PTR _kill_list$[esp+392]
  00dfe	e8 00 00 00 00	 call	 ?insert@?$List@VShip@@@@QAEXPBVShip@@H@Z ; List<Ship>::insert
  00e03	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
$LN4@CollideShi:

; 3079 : 		while (++a_iter) {

  00e06	8d 54 24 64	 lea	 edx, DWORD PTR _a_iter$120949[esp+388]
  00e0a	e8 00 00 00 00	 call	 ?next@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::next
  00e0f	85 c0		 test	 eax, eax
  00e11	0f 85 ba fd ff
	ff		 jne	 $LL9@CollideShi
$LN8@CollideShi:

; 3097 : 					}
; 3098 : 				}
; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 		s_index++;

  00e17	ff 44 24 54	 inc	 DWORD PTR _s_index$[esp+388]
$LN42@CollideShi:

; 2938 : 	while (++ship_iter) {

  00e1b	8d 54 24 40	 lea	 edx, DWORD PTR _ship_iter$[esp+388]
  00e1f	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00e24	85 c0		 test	 eax, eax
  00e26	0f 85 56 f2 ff
	ff		 jne	 $LL340@CollideShi
  00e2c	83 cb ff	 or	 ebx, -1
$LN44@CollideShi:

; 3103 : 	}
; 3104 : 
; 3105 : 	ListIter<Ship> killed(kill_list);

  00e2f	8d 4c 24 48	 lea	 ecx, DWORD PTR _kill_list$[esp+388]

; 3106 : 	while (++killed) {

  00e33	8d 54 24 40	 lea	 edx, DWORD PTR _killed$[esp+388]
  00e37	89 4c 24 40	 mov	 DWORD PTR _killed$[esp+388], ecx
  00e3b	89 5c 24 44	 mov	 DWORD PTR _killed$[esp+392], ebx
  00e3f	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00e44	85 c0		 test	 eax, eax
  00e46	74 23		 je	 SHORT $LN1@CollideShi
  00e48	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL2@CollideShi:

; 3107 : 		Ship* kill = killed.value();

  00e50	8d 44 24 40	 lea	 eax, DWORD PTR _killed$[esp+388]
  00e54	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value

; 3108 : 		kill->DeathSpiral();

  00e59	e8 00 00 00 00	 call	 ?DeathSpiral@Ship@@QAEXXZ ; Ship::DeathSpiral
  00e5e	8d 54 24 40	 lea	 edx, DWORD PTR _killed$[esp+388]
  00e62	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  00e67	85 c0		 test	 eax, eax
  00e69	75 e5		 jne	 SHORT $LL2@CollideShi
$LN1@CollideShi:

; 3109 : 	}
; 3110 : }

  00e6b	89 9c 24 80 01
	00 00		 mov	 DWORD PTR __$EHRec$[esp+396], ebx
  00e72	8b 54 24 50	 mov	 edx, DWORD PTR _kill_list$[esp+396]
  00e76	52		 push	 edx
  00e77	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00e7c	83 c4 04	 add	 esp, 4
$LN314@CollideShi:
  00e7f	8b 8c 24 78 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+388]
  00e86	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00e8d	59		 pop	 ecx
  00e8e	5f		 pop	 edi
  00e8f	5e		 pop	 esi
  00e90	5b		 pop	 ebx
  00e91	8b e5		 mov	 esp, ebp
  00e93	5d		 pop	 ebp
  00e94	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CollideShips@SimRegion@@IAEXXZ$0:
  00000	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _kill_list$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$List@VShip@@@@QAE@XZ ; List<Ship>::~List<Ship>
__unwindfunclet$?CollideShips@SimRegion@@IAEXXZ$1:
  0000b	8d 4d 80	 lea	 ecx, DWORD PTR $T406427[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__unwindfunclet$?CollideShips@SimRegion@@IAEXXZ$2:
  00013	8d 4d 88	 lea	 ecx, DWORD PTR $T406434[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1Text@@QAE@XZ		; Text::~Text
__ehhandler$?CollideShips@SimRegion@@IAEXXZ:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 82 8c fe ff
	ff		 lea	 eax, DWORD PTR [edx-372]
  00025	8b 8a 88 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-376]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CollideShips@SimRegion@@IAEXXZ
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CollideShips@SimRegion@@IAEXXZ ENDP			; SimRegion::CollideShips
PUBLIC	?DamageShips@SimRegion@@IAEXXZ			; SimRegion::DamageShips
; Function compile flags: /Ogtp
;	COMDAT ?DamageShips@SimRegion@@IAEXXZ
_TEXT	SEGMENT
_owner_name$120721 = -132				; size = 4
_owner$120720 = -128					; size = 4
_shot_iter$ = -124					; size = 8
tv1142 = -116						; size = 4
_cmdr_stats$120757 = -116				; size = 4
_ship$120730 = -112					; size = 4
_debris_iter$120807 = -108				; size = 8
_a_iter$120827 = -100					; size = 8
_director$120740 = -92					; size = 4
_ship_iter$120726 = -88					; size = 8
_drone_iter$120784 = -80				; size = 8
$T407104 = -72						; size = 24
$T407097 = -72						; size = 24
$T407105 = -48						; size = 24
$T407096 = -48						; size = 24
_impact$ = -24						; size = 24
_this$ = 8						; size = 4
?DamageShips@SimRegion@@IAEXXZ PROC			; SimRegion::DamageShips, COMDAT

; 2697 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  0000c	53		 push	 ebx
  0000d	56		 push	 esi

; 2698 : 	if (ships.size() == 0 || shots.size() == 0)

  0000e	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00011	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00015	57		 push	 edi
  00016	0f 84 31 07 00
	00		 je	 $LN63@DamageShip
  0001c	83 7e 7c 00	 cmp	 DWORD PTR [esi+124], 0
  00020	8d 46 7c	 lea	 eax, DWORD PTR [esi+124]
  00023	0f 84 24 07 00
	00		 je	 $LN63@DamageShip

; 2699 : 	return;
; 2700 : 
; 2701 : 	Point impact;

  00029	0f 57 c0	 xorps	 xmm0, xmm0

; 2702 : 
; 2703 : 	// FOR EACH SHOT IN THE REGION:
; 2704 : 	ListIter<Shot> shot_iter = shots;
; 2705 : 	while (++shot_iter) {

  0002c	8d 54 24 14	 lea	 edx, DWORD PTR _shot_iter$[esp+144]
  00030	f2 0f 11 44 24
	78		 movsd	 QWORD PTR _impact$[esp+144], xmm0
  00036	f2 0f 11 84 24
	80 00 00 00	 movsd	 QWORD PTR _impact$[esp+152], xmm0
  0003f	f2 0f 11 84 24
	88 00 00 00	 movsd	 QWORD PTR _impact$[esp+160], xmm0
  00048	89 44 24 14	 mov	 DWORD PTR _shot_iter$[esp+144], eax
  0004c	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR _shot_iter$[esp+148], -1
  00054	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  00059	85 c0		 test	 eax, eax
  0005b	0f 84 ec 06 00
	00		 je	 $LN63@DamageShip
$LN62@DamageShip:

; 2706 : 		Shot*       shot  = shot_iter.value();

  00061	8d 44 24 14	 lea	 eax, DWORD PTR _shot_iter$[esp+144]
  00065	e8 00 00 00 00	 call	 ?value@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::value
  0006a	8b d8		 mov	 ebx, eax

; 2707 : 		const Ship* owner = shot->Owner();

  0006c	8b 83 f0 01 00
	00		 mov	 eax, DWORD PTR [ebx+496]
  00072	89 44 24 10	 mov	 DWORD PTR _owner$120720[esp+144], eax

; 2708 : 		const char* owner_name;
; 2709 : 
; 2710 : 		if (owner)

  00076	85 c0		 test	 eax, eax
  00078	74 09		 je	 SHORT $LN60@DamageShip

; 2711 : 		owner_name = owner->Name();

  0007a	83 c0 10	 add	 eax, 16			; 00000010H
  0007d	89 44 24 0c	 mov	 DWORD PTR _owner_name$120721[esp+144], eax

; 2712 : 		else

  00081	eb 08		 jmp	 SHORT $LN59@DamageShip
$LN60@DamageShip:

; 2713 : 		owner_name = "[KIA]";

  00083	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _owner_name$120721[esp+144], OFFSET ??_C@_05JPAGBMGJ@?$FLKIA?$FN?$AA@
$LN59@DamageShip:

; 2714 : 
; 2715 : 		// CHECK FOR COLLISION WITH A SHIP:
; 2716 : 		ListIter<Ship> ship_iter = ships;

  0008b	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  0008e	89 44 24 38	 mov	 DWORD PTR _ship_iter$120726[esp+144], eax
  00092	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR _ship_iter$120726[esp+148], -1
$LN58@DamageShip:

; 2717 : 		while (shot && ++ship_iter) {

  0009a	8d 54 24 38	 lea	 edx, DWORD PTR _ship_iter$120726[esp+144]
  0009e	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  000a3	85 c0		 test	 eax, eax
  000a5	0f 84 0d 03 00
	00		 je	 $LN57@DamageShip

; 2718 : 			Ship* ship = ship_iter.value();

  000ab	8d 44 24 38	 lea	 eax, DWORD PTR _ship_iter$120726[esp+144]
  000af	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  000b4	8b f8		 mov	 edi, eax

; 2719 : 			int   hit  = ship->HitBy(shot, impact);

  000b6	8b 07		 mov	 eax, DWORD PTR [edi]
  000b8	8b 90 90 01 00
	00		 mov	 edx, DWORD PTR [eax+400]
  000be	8d 4c 24 78	 lea	 ecx, DWORD PTR _impact$[esp+144]
  000c2	51		 push	 ecx
  000c3	53		 push	 ebx
  000c4	8b cf		 mov	 ecx, edi
  000c6	89 7c 24 28	 mov	 DWORD PTR _ship$120730[esp+152], edi
  000ca	ff d2		 call	 edx

; 2720 : 
; 2721 : 			if (hit) {

  000cc	85 c0		 test	 eax, eax
  000ce	74 ca		 je	 SHORT $LN58@DamageShip

; 2722 : 				// recon imager:
; 2723 : 				if (shot->Damage() < 0) {

  000d0	8b f3		 mov	 esi, ebx
  000d2	e8 00 00 00 00	 call	 ?Damage@Shot@@QBENXZ	; Shot::Damage
  000d7	0f 57 c9	 xorps	 xmm1, xmm1
  000da	66 0f 2f c8	 comisd	 xmm1, xmm0
  000de	76 22		 jbe	 SHORT $LN55@DamageShip

; 2724 : 					ShipStats* shooter = ShipStats::Find(owner_name);

  000e0	8b 4c 24 0c	 mov	 ecx, DWORD PTR _owner_name$120721[esp+144]
  000e4	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find

; 2725 : 					if (shooter) {

  000e9	85 c0		 test	 eax, eax
  000eb	0f 84 04 02 00
	00		 je	 $LN51@DamageShip

; 2726 : 						shooter->AddEvent(SimEvent::SCAN_TARGET, ship->Name());

  000f1	83 c7 10	 add	 edi, 16			; 00000010H
  000f4	57		 push	 edi
  000f5	6a 13		 push	 19			; 00000013H
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent

; 2727 : 					}
; 2728 : 				}

  000fd	e9 f3 01 00 00	 jmp	 $LN51@DamageShip
$LN55@DamageShip:

; 2729 : 
; 2730 : 				// live round:
; 2731 : 				else if (shot->Damage() > 0) {

  00102	8b f3		 mov	 esi, ebx
  00104	e8 00 00 00 00	 call	 ?Damage@Shot@@QBENXZ	; Shot::Damage
  00109	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00111	0f 86 de 01 00
	00		 jbe	 $LN51@DamageShip

; 2732 : 					int ship_destroyed = (!ship->InTransition() && ship->Integrity() < 1.0f);

  00117	83 bf 60 04 00
	00 00		 cmp	 DWORD PTR [edi+1120], 0
  0011e	0f 85 d1 01 00
	00		 jne	 $LN51@DamageShip
  00124	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0012c	0f 2f 87 b8 01
	00 00		 comiss	 xmm0, DWORD PTR [edi+440]

; 2733 : 
; 2734 : 					// then delete the ship:
; 2735 : 					if (ship_destroyed) {

  00133	0f 86 bc 01 00
	00		 jbe	 $LN51@DamageShip

; 2736 : 						NetUtil::SendObjKill(ship, owner, shot->IsMissile() ? NetObjKill::KILL_SECONDARY : NetObjKill::KILL_PRIMARY);

  00139	8b 03		 mov	 eax, DWORD PTR [ebx]
  0013b	8b 90 d0 00 00
	00		 mov	 edx, DWORD PTR [eax+208]
  00141	6a 00		 push	 0
  00143	8b cb		 mov	 ecx, ebx
  00145	ff d2		 call	 edx
  00147	8b 74 24 14	 mov	 esi, DWORD PTR _owner$120720[esp+148]
  0014b	33 c9		 xor	 ecx, ecx
  0014d	84 c0		 test	 al, al
  0014f	0f 95 c1	 setne	 cl
  00152	41		 inc	 ecx
  00153	51		 push	 ecx
  00154	56		 push	 esi
  00155	8b cf		 mov	 ecx, edi
  00157	e8 00 00 00 00	 call	 ?SendObjKill@NetUtil@@SAXPAVShip@@PBV2@HH@Z ; NetUtil::SendObjKill
  0015c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2737 :                         Director* director;
; 2738 :                         
; 2739 : 						Print("    %s Killed %s (%s)\n", owner_name, ship->Name(), FormatGameTime());

  0015f	e8 00 00 00 00	 call	 ?FormatGameTime@@YAPBDXZ ; FormatGameTime
  00164	8b 54 24 0c	 mov	 edx, DWORD PTR _owner_name$120721[esp+144]
  00168	50		 push	 eax
  00169	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  0016c	50		 push	 eax
  0016d	52		 push	 edx
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@IBFIGKOO@?5?5?5?5?$CFs?5Killed?5?$CFs?5?$CI?$CFs?$CJ?6?$AA@
  00173	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print
  00178	83 c4 10	 add	 esp, 16			; 00000010H

; 2740 : 
; 2741 : 						if (owner)

  0017b	85 f6		 test	 esi, esi
  0017d	74 0c		 je	 SHORT $LN214@DamageShip

; 2742 :                             director = owner->GetDirector();

  0017f	8b b6 c4 01 00
	00		 mov	 esi, DWORD PTR [esi+452]
  00185	89 74 24 34	 mov	 DWORD PTR _director$120740[esp+144], esi
  00189	eb 04		 jmp	 SHORT $LN109@DamageShip
$LN214@DamageShip:
  0018b	8b 74 24 34	 mov	 esi, DWORD PTR _director$120740[esp+144]
$LN109@DamageShip:

; 2743 :                         
; 2744 :                         // alert the killer
; 2745 : 						if (director && director->Type() > SteerAI::SEEKER && director->Type() < SteerAI::GROUND) {

  0018f	85 f6		 test	 esi, esi
  00191	74 2d		 je	 SHORT $LN49@DamageShip
  00193	8b 06		 mov	 eax, DWORD PTR [esi]
  00195	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00198	8b ce		 mov	 ecx, esi
  0019a	ff d2		 call	 edx
  0019c	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  001a1	7e 1d		 jle	 SHORT $LN49@DamageShip
  001a3	8b 06		 mov	 eax, DWORD PTR [esi]
  001a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001a8	8b ce		 mov	 ecx, esi
  001aa	ff d2		 call	 edx
  001ac	3d eb 03 00 00	 cmp	 eax, 1003		; 000003ebH
  001b1	7d 0d		 jge	 SHORT $LN49@DamageShip

; 2746 : 							ShipAI* shipAI = (ShipAI*) director;
; 2747 : 							shipAI->Splash(ship);

  001b3	8b 06		 mov	 eax, DWORD PTR [esi]
  001b5	8b 90 9c 00 00
	00		 mov	 edx, DWORD PTR [eax+156]
  001bb	57		 push	 edi
  001bc	8b ce		 mov	 ecx, esi
  001be	ff d2		 call	 edx
$LN49@DamageShip:

; 2748 : 						}
; 2749 : 
; 2750 : 						// record the kill
; 2751 : 						ShipStats* killer = ShipStats::Find(owner_name);

  001c0	8b 4c 24 0c	 mov	 ecx, DWORD PTR _owner_name$120721[esp+144]
  001c4	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  001c9	8b f0		 mov	 esi, eax

; 2752 : 						if (killer) {

  001cb	85 f6		 test	 esi, esi
  001cd	74 20		 je	 SHORT $LN46@DamageShip

; 2753 : 							if (shot->IsMissile())

  001cf	8b 03		 mov	 eax, DWORD PTR [ebx]
  001d1	8b 90 d0 00 00
	00		 mov	 edx, DWORD PTR [eax+208]
  001d7	8b cb		 mov	 ecx, ebx
  001d9	ff d2		 call	 edx
  001db	84 c0		 test	 al, al

; 2754 : 							killer->AddEvent(SimEvent::MISSILE_KILL, ship->Name());

  001dd	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  001e0	50		 push	 eax
  001e1	74 04		 je	 SHORT $LN47@DamageShip
  001e3	6a 11		 push	 17			; 00000011H

; 2755 : 							else

  001e5	eb 02		 jmp	 SHORT $LN231@DamageShip
$LN47@DamageShip:

; 2756 : 							killer->AddEvent(SimEvent::GUNS_KILL, ship->Name());

  001e7	6a 10		 push	 16			; 00000010H
$LN231@DamageShip:
  001e9	56		 push	 esi
  001ea	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
$LN46@DamageShip:

; 2757 : 						}
; 2758 : 
; 2759 : 						if (owner && owner->GetIFF() != ship->GetIFF()) {

  001ef	8b 4c 24 10	 mov	 ecx, DWORD PTR _owner$120720[esp+144]
  001f3	85 c9		 test	 ecx, ecx
  001f5	0f 84 da 00 00
	00		 je	 $LN127@DamageShip
  001fb	8b 01		 mov	 eax, DWORD PTR [ecx]
  001fd	8b 90 98 01 00
	00		 mov	 edx, DWORD PTR [eax+408]
  00203	ff d2		 call	 edx
  00205	8b 17		 mov	 edx, DWORD PTR [edi]
  00207	8b 92 98 01 00
	00		 mov	 edx, DWORD PTR [edx+408]
  0020d	8b cf		 mov	 ecx, edi
  0020f	89 44 24 1c	 mov	 DWORD PTR tv1142[esp+144], eax
  00213	ff d2		 call	 edx

; 2760 : 							if (ship->GetIFF() > 0 || owner->GetIFF() > 1) {

  00215	8b 7c 24 20	 mov	 edi, DWORD PTR _ship$120730[esp+144]
  00219	39 44 24 1c	 cmp	 DWORD PTR tv1142[esp+144], eax
  0021d	0f 84 b2 00 00
	00		 je	 $LN127@DamageShip
  00223	8b 07		 mov	 eax, DWORD PTR [edi]
  00225	8b 90 98 01 00
	00		 mov	 edx, DWORD PTR [eax+408]
  0022b	8b cf		 mov	 ecx, edi
  0022d	ff d2		 call	 edx
  0022f	85 c0		 test	 eax, eax
  00231	7f 17		 jg	 SHORT $LN43@DamageShip
  00233	8b 4c 24 10	 mov	 ecx, DWORD PTR _owner$120720[esp+144]
  00237	8b 01		 mov	 eax, DWORD PTR [ecx]
  00239	8b 90 98 01 00
	00		 mov	 edx, DWORD PTR [eax+408]
  0023f	ff d2		 call	 edx
  00241	83 f8 01	 cmp	 eax, 1
  00244	0f 8e 8b 00 00
	00		 jle	 $LN127@DamageShip
$LN43@DamageShip:

; 2761 : 								killer->AddPoints(ship->Value());

  0024a	8b c7		 mov	 eax, edi
  0024c	e8 00 00 00 00	 call	 ?Value@Ship@@QBEHXZ	; Ship::Value
  00251	01 46 58	 add	 DWORD PTR [esi+88], eax

; 2762 : 
; 2763 : 								Element* elem = owner->GetElement();

  00254	8b 44 24 10	 mov	 eax, DWORD PTR _owner$120720[esp+144]
  00258	8b b0 e8 03 00
	00		 mov	 esi, DWORD PTR [eax+1000]

; 2764 : 								if (elem) {

  0025e	85 f6		 test	 esi, esi
  00260	74 73		 je	 SHORT $LN127@DamageShip

; 2765 : 									if (owner->GetElementIndex() > 1) {

  00262	e8 00 00 00 00	 call	 ?GetElementIndex@Ship@@QBEHXZ ; Ship::GetElementIndex
  00267	83 f8 01	 cmp	 eax, 1
  0026a	7e 35		 jle	 SHORT $LN121@DamageShip

; 2766 : 										Ship* s = elem->GetShip(1);

  0026c	b9 01 00 00 00	 mov	 ecx, 1
  00271	8b c6		 mov	 eax, esi
  00273	e8 00 00 00 00	 call	 ?GetShip@Element@@QAEPAVShip@@H@Z ; Element::GetShip

; 2767 : 
; 2768 : 										if (s) {

  00278	85 c0		 test	 eax, eax
  0027a	74 25		 je	 SHORT $LN121@DamageShip

; 2769 : 											ShipStats* cmdr_stats = ShipStats::Find(s->Name());

  0027c	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  0027f	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  00284	89 44 24 1c	 mov	 DWORD PTR _cmdr_stats$120757[esp+144], eax

; 2770 : 											if (cmdr_stats) {

  00288	85 c0		 test	 eax, eax
  0028a	74 15		 je	 SHORT $LN121@DamageShip

; 2771 : 												cmdr_stats->AddCommandPoints(ship->Value()/2);

  0028c	8b c7		 mov	 eax, edi
  0028e	e8 00 00 00 00	 call	 ?Value@Ship@@QBEHXZ	; Ship::Value
  00293	99		 cdq
  00294	2b c2		 sub	 eax, edx
  00296	8b c8		 mov	 ecx, eax
  00298	8b 44 24 1c	 mov	 eax, DWORD PTR _cmdr_stats$120757[esp+144]
  0029c	d1 f9		 sar	 ecx, 1
  0029e	01 48 5c	 add	 DWORD PTR [eax+92], ecx
$LN121@DamageShip:

; 2772 : 											}
; 2773 : 										}
; 2774 : 									}
; 2775 : 
; 2776 : 									Element* cmdr = elem->GetCommander();

  002a1	8b 76 74	 mov	 esi, DWORD PTR [esi+116]

; 2777 : 									if (cmdr) {

  002a4	85 f6		 test	 esi, esi
  002a6	74 2d		 je	 SHORT $LN127@DamageShip

; 2778 : 										Ship* s = cmdr->GetShip(1);

  002a8	b9 01 00 00 00	 mov	 ecx, 1
  002ad	8b c6		 mov	 eax, esi
  002af	e8 00 00 00 00	 call	 ?GetShip@Element@@QAEPAVShip@@H@Z ; Element::GetShip

; 2779 : 
; 2780 : 										if (s) {

  002b4	85 c0		 test	 eax, eax
  002b6	74 1d		 je	 SHORT $LN127@DamageShip

; 2781 : 											ShipStats* cmdr_stats = ShipStats::Find(s->Name());

  002b8	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  002bb	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  002c0	8b f0		 mov	 esi, eax

; 2782 : 											if (cmdr_stats) {

  002c2	85 f6		 test	 esi, esi
  002c4	74 0f		 je	 SHORT $LN127@DamageShip

; 2783 : 												cmdr_stats->AddCommandPoints(ship->Value()/2);

  002c6	8b c7		 mov	 eax, edi
  002c8	e8 00 00 00 00	 call	 ?Value@Ship@@QBEHXZ	; Ship::Value
  002cd	99		 cdq
  002ce	2b c2		 sub	 eax, edx
  002d0	d1 f8		 sar	 eax, 1
  002d2	01 46 5c	 add	 DWORD PTR [esi+92], eax
$LN127@DamageShip:

; 2784 : 											}
; 2785 : 										}
; 2786 : 									}
; 2787 : 								}
; 2788 : 							}
; 2789 : 						}
; 2790 : 
; 2791 : 						ShipStats* killee = ShipStats::Find(ship->Name());

  002d5	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  002d8	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find

; 2792 : 						if (killee)

  002dd	85 c0		 test	 eax, eax
  002df	74 0d		 je	 SHORT $LN35@DamageShip

; 2793 : 						killee->AddEvent(SimEvent::DESTROYED, owner_name);

  002e1	8b 54 24 0c	 mov	 edx, DWORD PTR _owner_name$120721[esp+144]
  002e5	52		 push	 edx
  002e6	6a 07		 push	 7
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
$LN35@DamageShip:

; 2794 : 
; 2795 : 						ship->DeathSpiral();

  002ee	8b c7		 mov	 eax, edi
  002f0	e8 00 00 00 00	 call	 ?DeathSpiral@Ship@@QAEXXZ ; Ship::DeathSpiral
$LN51@DamageShip:

; 2796 : 					}
; 2797 : 				}
; 2798 : 
; 2799 : 				// finally, consume the shot:
; 2800 : 				if (!shot->IsBeam()) {

  002f5	8b 03		 mov	 eax, DWORD PTR [ebx]
  002f7	8b 90 d8 00 00
	00		 mov	 edx, DWORD PTR [eax+216]
  002fd	8b cb		 mov	 ecx, ebx
  002ff	ff d2		 call	 edx
  00301	84 c0		 test	 al, al
  00303	74 40		 je	 SHORT $LN210@DamageShip

; 2816 : 					shot = 0;
; 2817 : 				}
; 2818 : 				else if (!shot->HitTarget()) {

  00305	80 bb 0f 02 00
	00 00		 cmp	 BYTE PTR [ebx+527], 0
  0030c	0f 85 88 fd ff
	ff		 jne	 $LN58@DamageShip

; 2819 : 					shot->SetHitTarget(true);
; 2820 : 
; 2821 : 					if (owner) {

  00312	83 7c 24 10 00	 cmp	 DWORD PTR _owner$120720[esp+144], 0
  00317	c6 83 0f 02 00
	00 01		 mov	 BYTE PTR [ebx+527], 1
  0031e	0f 84 76 fd ff
	ff		 je	 $LN58@DamageShip

; 2822 : 						ShipStats* stats = ShipStats::Find(owner_name);

  00324	8b 4c 24 0c	 mov	 ecx, DWORD PTR _owner_name$120721[esp+144]
  00328	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find

; 2823 : 						if (shot->Design()->primary)

  0032d	8b 8b 20 02 00
	00		 mov	 ecx, DWORD PTR [ebx+544]
  00333	80 79 1e 00	 cmp	 BYTE PTR [ecx+30], 0
  00337	0f 84 5d fd ff
	ff		 je	 $LN58@DamageShip

; 2824 : 						stats->AddGunHit();

  0033d	ff 40 4c	 inc	 DWORD PTR [eax+76]

; 2717 : 		while (shot && ++ship_iter) {

  00340	e9 55 fd ff ff	 jmp	 $LN58@DamageShip
$LN210@DamageShip:

; 2801 : 					if (owner) {

  00345	83 7c 24 10 00	 cmp	 DWORD PTR _owner$120720[esp+144], 0
  0034a	74 30		 je	 SHORT $LN135@DamageShip

; 2802 : 						ShipStats* stats = ShipStats::Find(owner_name);

  0034c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _owner_name$120721[esp+144]
  00350	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find

; 2803 : 						if (shot->Design()->primary)

  00355	8b 93 20 02 00
	00		 mov	 edx, DWORD PTR [ebx+544]
  0035b	80 7a 1e 00	 cmp	 BYTE PTR [edx+30], 0
  0035f	8b f8		 mov	 edi, eax
  00361	74 05		 je	 SHORT $LN32@DamageShip

; 2804 : 						stats->AddGunHit();

  00363	ff 47 4c	 inc	 DWORD PTR [edi+76]
  00366	eb 14		 jmp	 SHORT $LN135@DamageShip
$LN32@DamageShip:

; 2805 : 						else if (shot->Damage() > 0)

  00368	8b f3		 mov	 esi, ebx
  0036a	e8 00 00 00 00	 call	 ?Damage@Shot@@QBENXZ	; Shot::Damage
  0036f	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00377	76 03		 jbe	 SHORT $LN135@DamageShip

; 2806 : 						stats->AddMissileHit();

  00379	ff 47 54	 inc	 DWORD PTR [edi+84]
$LN135@DamageShip:

; 2807 : 					}
; 2808 : 
; 2809 : 					NetUtil::SendWepDestroy(shot);

  0037c	8b fb		 mov	 edi, ebx
  0037e	e8 00 00 00 00	 call	 ?SendWepDestroy@NetUtil@@SAXPAVShot@@@Z ; NetUtil::SendWepDestroy

; 2810 : 
; 2811 : 					if (shot->IsDrone())

  00383	8b 03		 mov	 eax, DWORD PTR [ebx]
  00385	8b 90 c4 00 00
	00		 mov	 edx, DWORD PTR [eax+196]
  0038b	8b cb		 mov	 ecx, ebx
  0038d	ff d2		 call	 edx
  0038f	84 c0		 test	 al, al
  00391	74 0d		 je	 SHORT $LN29@DamageShip

; 2812 : 					drones.remove((Drone*) shot);

  00393	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00396	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0039b	e8 00 00 00 00	 call	 ?remove@?$List@VDrone@@@@QAEPAVDrone@@PBV2@@Z ; List<Drone>::remove
$LN29@DamageShip:

; 2813 : 
; 2814 : 					shot_iter.removeItem();

  003a0	8d 54 24 14	 lea	 edx, DWORD PTR _shot_iter$[esp+144]
  003a4	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::removeItem

; 2815 : 					delete shot;

  003a9	8b 03		 mov	 eax, DWORD PTR [ebx]
  003ab	8b 10		 mov	 edx, DWORD PTR [eax]
  003ad	6a 01		 push	 1
  003af	8b cb		 mov	 ecx, ebx
  003b1	ff d2		 call	 edx

; 2825 : 					}
; 2826 : 				}
; 2827 : 			}
; 2828 : 		}
; 2829 : 
; 2830 : 		// CHECK FOR COLLISION WITH A DRONE:
; 2831 : 		if (shot && shot->Design()->target_type & Ship::DRONE) {

  003b3	e9 8e 01 00 00	 jmp	 $LN232@DamageShip
$LN57@DamageShip:
  003b8	8b 83 20 02 00
	00		 mov	 eax, DWORD PTR [ebx+544]
  003be	f6 40 34 01	 test	 BYTE PTR [eax+52], 1
  003c2	0f 84 80 01 00
	00		 je	 $LN22@DamageShip

; 2832 : 			ListIter<Drone> drone_iter = drones;

  003c8	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  003cb	05 88 00 00 00	 add	 eax, 136		; 00000088H
  003d0	89 44 24 40	 mov	 DWORD PTR _drone_iter$120784[esp+144], eax
  003d4	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR _drone_iter$120784[esp+148], -1
$LN23@DamageShip:

; 2833 : 			while (shot && ++drone_iter) {

  003dc	8d 54 24 40	 lea	 edx, DWORD PTR _drone_iter$120784[esp+144]
  003e0	e8 00 00 00 00	 call	 ?next@?$ListIter@VDrone@@@@QAEPAVDrone@@XZ ; ListIter<Drone>::next
  003e5	85 c0		 test	 eax, eax
  003e7	0f 84 5b 01 00
	00		 je	 $LN22@DamageShip

; 2834 : 				Drone* d = drone_iter.value();

  003ed	8d 44 24 40	 lea	 eax, DWORD PTR _drone_iter$120784[esp+144]
  003f1	e8 00 00 00 00	 call	 ?value@?$ListIter@VDrone@@@@QAEPAVDrone@@XZ ; ListIter<Drone>::value
  003f6	8b f0		 mov	 esi, eax

; 2835 : 
; 2836 : 				if (d == shot || d->Owner() == owner)

  003f8	3b f3		 cmp	 esi, ebx
  003fa	74 e0		 je	 SHORT $LN23@DamageShip
  003fc	8b 4c 24 10	 mov	 ecx, DWORD PTR _owner$120720[esp+144]
  00400	39 8e f0 01 00
	00		 cmp	 DWORD PTR [esi+496], ecx
  00406	74 d4		 je	 SHORT $LN23@DamageShip

; 2837 : 				continue;
; 2838 : 
; 2839 : 				int hit = d->HitBy(shot, impact);

  00408	8b 16		 mov	 edx, DWORD PTR [esi]
  0040a	8b 92 04 01 00
	00		 mov	 edx, DWORD PTR [edx+260]
  00410	8d 44 24 78	 lea	 eax, DWORD PTR _impact$[esp+144]
  00414	50		 push	 eax
  00415	53		 push	 ebx
  00416	8b ce		 mov	 ecx, esi
  00418	ff d2		 call	 edx

; 2840 : 				if (hit) {

  0041a	85 c0		 test	 eax, eax
  0041c	74 be		 je	 SHORT $LN23@DamageShip

; 2841 : 					int destroyed = (d->Integrity() < 1.0f);

  0041e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00426	0f 2f 86 b8 01
	00 00		 comiss	 xmm0, DWORD PTR [esi+440]

; 2842 : 
; 2843 : 					// then mark the drone for deletion:
; 2844 : 					if (destroyed) {

  0042d	0f 86 a4 00 00
	00		 jbe	 $LN167@DamageShip

; 2845 : 						NetUtil::SendWepDestroy(d);

  00433	8b fe		 mov	 edi, esi
  00435	e8 00 00 00 00	 call	 ?SendWepDestroy@NetUtil@@SAXPAVShot@@@Z ; NetUtil::SendWepDestroy

; 2846 : 						sim->CreateExplosion(d->Location(), d->Velocity(), 21, 1.0f, 1.0f, this);

  0043a	f2 0f 10 86 c0
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+192]
  00442	f2 0f 58 86 a8
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+168]
  0044a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0044d	f2 0f 11 44 24
	60		 movsd	 QWORD PTR $T407096[esp+144], xmm0
  00453	f2 0f 10 86 c8
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+200]
  0045b	f2 0f 58 86 b0
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+176]
  00463	f2 0f 11 44 24
	68		 movsd	 QWORD PTR $T407096[esp+152], xmm0
  00469	f2 0f 10 86 d0
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+208]
  00471	f2 0f 58 86 b8
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+184]
  00479	f2 0f 11 44 24
	70		 movsd	 QWORD PTR $T407096[esp+160], xmm0
  0047f	f2 0f 10 46 48	 movsd	 xmm0, QWORD PTR [esi+72]
  00484	6a 00		 push	 0
  00486	f2 0f 11 44 24
	4c		 movsd	 QWORD PTR $T407097[esp+148], xmm0
  0048c	f2 0f 10 46 50	 movsd	 xmm0, QWORD PTR [esi+80]
  00491	50		 push	 eax
  00492	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00495	f2 0f 11 44 24
	58		 movsd	 QWORD PTR $T407097[esp+160], xmm0
  0049b	f2 0f 10 46 58	 movsd	 xmm0, QWORD PTR [esi+88]
  004a0	83 ec 08	 sub	 esp, 8
  004a3	f2 0f 11 44 24
	68		 movsd	 QWORD PTR $T407097[esp+176], xmm0
  004a9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004b1	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  004b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004bc	6a 15		 push	 21			; 00000015H
  004be	50		 push	 eax
  004bf	8d 7c 24 78	 lea	 edi, DWORD PTR $T407096[esp+168]
  004c3	8d 4c 24 60	 lea	 ecx, DWORD PTR $T407097[esp+168]
  004c7	e8 00 00 00 00	 call	 ?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z ; Sim::CreateExplosion

; 2847 : 						d->SetLife(0);

  004cc	0f 57 c0	 xorps	 xmm0, xmm0
  004cf	f2 0f 11 86 a8
	01 00 00	 movsd	 QWORD PTR [esi+424], xmm0
$LN167@DamageShip:

; 2848 : 					}
; 2849 : 
; 2850 : 					// finally, consume the shot:
; 2851 : 					if (!shot->IsBeam()) {

  004d7	8b 13		 mov	 edx, DWORD PTR [ebx]
  004d9	8b 82 d8 00 00
	00		 mov	 eax, DWORD PTR [edx+216]
  004df	8b cb		 mov	 ecx, ebx
  004e1	ff d0		 call	 eax
  004e3	84 c0		 test	 al, al
  004e5	0f 85 f1 fe ff
	ff		 jne	 $LN23@DamageShip

; 2852 : 						if (owner) {

  004eb	83 7c 24 10 00	 cmp	 DWORD PTR _owner$120720[esp+144], 0
  004f0	74 1d		 je	 SHORT $LN173@DamageShip

; 2853 : 							ShipStats* stats = ShipStats::Find(owner_name);

  004f2	8b 4c 24 0c	 mov	 ecx, DWORD PTR _owner_name$120721[esp+144]
  004f6	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find

; 2854 : 							if (shot->Design()->primary)

  004fb	8b 8b 20 02 00
	00		 mov	 ecx, DWORD PTR [ebx+544]
  00501	80 79 1e 00	 cmp	 BYTE PTR [ecx+30], 0
  00505	74 05		 je	 SHORT $LN15@DamageShip

; 2855 : 							stats->AddGunHit();

  00507	ff 40 4c	 inc	 DWORD PTR [eax+76]

; 2856 : 							else

  0050a	eb 03		 jmp	 SHORT $LN173@DamageShip
$LN15@DamageShip:

; 2857 : 							stats->AddMissileHit();

  0050c	ff 40 54	 inc	 DWORD PTR [eax+84]
$LN173@DamageShip:

; 2858 : 						}
; 2859 : 
; 2860 : 						NetUtil::SendWepDestroy(shot);

  0050f	8b fb		 mov	 edi, ebx
  00511	e8 00 00 00 00	 call	 ?SendWepDestroy@NetUtil@@SAXPAVShot@@@Z ; NetUtil::SendWepDestroy

; 2861 : 
; 2862 : 						if (shot->IsDrone())

  00516	8b 13		 mov	 edx, DWORD PTR [ebx]
  00518	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  0051e	8b cb		 mov	 ecx, ebx
  00520	ff d0		 call	 eax
  00522	84 c0		 test	 al, al
  00524	74 0d		 je	 SHORT $LN13@DamageShip

; 2863 : 						drones.remove((Drone*) shot);

  00526	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00529	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0052e	e8 00 00 00 00	 call	 ?remove@?$List@VDrone@@@@QAEPAVDrone@@PBV2@@Z ; List<Drone>::remove
$LN13@DamageShip:

; 2864 : 						
; 2865 : 						shot_iter.removeItem();

  00533	8d 54 24 14	 lea	 edx, DWORD PTR _shot_iter$[esp+144]
  00537	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::removeItem

; 2866 : 						delete shot;

  0053c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0053e	8b 02		 mov	 eax, DWORD PTR [edx]
  00540	6a 01		 push	 1
  00542	8b cb		 mov	 ecx, ebx
  00544	ff d0		 call	 eax
$LN232@DamageShip:

; 2867 : 						shot = 0;

  00546	33 db		 xor	 ebx, ebx
$LN22@DamageShip:

; 2868 : 					}
; 2869 : 				}
; 2870 : 			}
; 2871 : 		}
; 2872 : 
; 2873 : 		// CHECK FOR COLLISION WITH DEBRIS:
; 2874 : 		ListIter<Debris> debris_iter = debris;

  00548	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0054b	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00550	89 44 24 24	 mov	 DWORD PTR _debris_iter$120807[esp+144], eax
  00554	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR _debris_iter$120807[esp+148], -1

; 2875 : 		while (shot && ++debris_iter) {

  0055c	85 db		 test	 ebx, ebx
  0055e	0f 84 4d 01 00
	00		 je	 $LN11@DamageShip
$LN12@DamageShip:
  00564	8d 54 24 24	 lea	 edx, DWORD PTR _debris_iter$120807[esp+144]
  00568	e8 00 00 00 00	 call	 ?next@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::next
  0056d	85 c0		 test	 eax, eax
  0056f	0f 84 3c 01 00
	00		 je	 $LN11@DamageShip

; 2876 : 			Debris* d = debris_iter.value();

  00575	8d 44 24 24	 lea	 eax, DWORD PTR _debris_iter$120807[esp+144]
  00579	e8 00 00 00 00	 call	 ?value@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::value

; 2877 : 
; 2878 : 			if (d->Radius() < 50)

  0057e	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4049000000000000
  00586	8b f0		 mov	 esi, eax
  00588	f3 0f 10 86 b0
	01 00 00	 movss	 xmm0, DWORD PTR [esi+432]
  00590	0f 5a c0	 cvtps2pd xmm0, xmm0
  00593	66 0f 2f c8	 comisd	 xmm1, xmm0
  00597	77 cb		 ja	 SHORT $LN12@DamageShip

; 2879 : 			continue;
; 2880 : 
; 2881 : 			int hit = d->HitBy(shot, impact);

  00599	8b 16		 mov	 edx, DWORD PTR [esi]
  0059b	8b 92 b8 00 00
	00		 mov	 edx, DWORD PTR [edx+184]
  005a1	8d 44 24 78	 lea	 eax, DWORD PTR _impact$[esp+144]
  005a5	50		 push	 eax
  005a6	53		 push	 ebx
  005a7	8b ce		 mov	 ecx, esi
  005a9	ff d2		 call	 edx

; 2882 : 			if (hit) {

  005ab	85 c0		 test	 eax, eax
  005ad	74 b5		 je	 SHORT $LN12@DamageShip

; 2883 : 				int destroyed = (d->Integrity() < 1.0f);

  005af	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005b7	0f 2f 86 b8 01
	00 00		 comiss	 xmm0, DWORD PTR [esi+440]

; 2884 : 
; 2885 : 				// then delete the debris:
; 2886 : 				if (destroyed) {

  005be	0f 86 a0 00 00
	00		 jbe	 $LN77@DamageShip

; 2887 : 					sim->CreateExplosion(d->Location(), d->Velocity(), Explosion::LARGE_EXPLOSION, 1.0f, 1.0f, this);

  005c4	f2 0f 10 8e c0
	00 00 00	 movsd	 xmm1, QWORD PTR [esi+192]
  005cc	f2 0f 58 8e a8
	00 00 00	 addsd	 xmm1, QWORD PTR [esi+168]
  005d4	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  005d7	f2 0f 11 4c 24
	48		 movsd	 QWORD PTR $T407104[esp+144], xmm1
  005dd	f2 0f 10 8e c8
	00 00 00	 movsd	 xmm1, QWORD PTR [esi+200]
  005e5	f2 0f 58 8e b0
	00 00 00	 addsd	 xmm1, QWORD PTR [esi+176]
  005ed	6a 00		 push	 0
  005ef	f2 0f 11 4c 24
	54		 movsd	 QWORD PTR $T407104[esp+156], xmm1
  005f5	f2 0f 10 8e d0
	00 00 00	 movsd	 xmm1, QWORD PTR [esi+208]
  005fd	f2 0f 58 8e b8
	00 00 00	 addsd	 xmm1, QWORD PTR [esi+184]
  00605	50		 push	 eax
  00606	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00609	83 ec 08	 sub	 esp, 8
  0060c	f2 0f 11 4c 24
	68		 movsd	 QWORD PTR $T407104[esp+176], xmm1
  00612	f2 0f 10 4e 48	 movsd	 xmm1, QWORD PTR [esi+72]
  00617	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0061d	f2 0f 11 4c 24
	70		 movsd	 QWORD PTR $T407105[esp+160], xmm1
  00623	f2 0f 10 4e 50	 movsd	 xmm1, QWORD PTR [esi+80]
  00628	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0062d	6a 0b		 push	 11			; 0000000bH
  0062f	f2 0f 11 4c 24
	7c		 movsd	 QWORD PTR $T407105[esp+172], xmm1
  00635	f2 0f 10 4e 58	 movsd	 xmm1, QWORD PTR [esi+88]
  0063a	50		 push	 eax
  0063b	8d 7c 24 60	 lea	 edi, DWORD PTR $T407104[esp+168]
  0063f	8d 4c 24 78	 lea	 ecx, DWORD PTR $T407105[esp+168]
  00643	f2 0f 11 8c 24
	88 00 00 00	 movsd	 QWORD PTR $T407105[esp+184], xmm1
  0064c	e8 00 00 00 00	 call	 ?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z ; Sim::CreateExplosion

; 2888 : 					debris_iter.removeItem();

  00651	8d 54 24 24	 lea	 edx, DWORD PTR _debris_iter$120807[esp+144]
  00655	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VDebris@@@@QAEPAVDebris@@XZ ; ListIter<Debris>::removeItem

; 2889 : 					delete d;

  0065a	8b 16		 mov	 edx, DWORD PTR [esi]
  0065c	8b 02		 mov	 eax, DWORD PTR [edx]
  0065e	6a 01		 push	 1
  00660	8b ce		 mov	 ecx, esi
  00662	ff d0		 call	 eax
$LN77@DamageShip:

; 2890 : 				}
; 2891 : 
; 2892 : 				// finally, consume the shot:
; 2893 : 				if (!shot->IsBeam()) {

  00664	8b 13		 mov	 edx, DWORD PTR [ebx]
  00666	8b 82 d8 00 00
	00		 mov	 eax, DWORD PTR [edx+216]
  0066c	8b cb		 mov	 ecx, ebx
  0066e	ff d0		 call	 eax
  00670	84 c0		 test	 al, al
  00672	0f 85 ec fe ff
	ff		 jne	 $LN12@DamageShip

; 2894 : 					NetUtil::SendWepDestroy(shot);

  00678	8b fb		 mov	 edi, ebx
  0067a	e8 00 00 00 00	 call	 ?SendWepDestroy@NetUtil@@SAXPAVShot@@@Z ; NetUtil::SendWepDestroy

; 2895 : 					if (shot->IsDrone())

  0067f	8b 13		 mov	 edx, DWORD PTR [ebx]
  00681	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00687	8b cb		 mov	 ecx, ebx
  00689	ff d0		 call	 eax
  0068b	84 c0		 test	 al, al
  0068d	74 0d		 je	 SHORT $LN6@DamageShip

; 2896 : 					drones.remove((Drone*) shot);

  0068f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00692	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00697	e8 00 00 00 00	 call	 ?remove@?$List@VDrone@@@@QAEPAVDrone@@PBV2@@Z ; List<Drone>::remove
$LN6@DamageShip:

; 2897 : 					
; 2898 : 					shot_iter.removeItem();

  0069c	8d 54 24 14	 lea	 edx, DWORD PTR _shot_iter$[esp+144]
  006a0	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::removeItem

; 2899 : 					delete shot;

  006a5	8b 13		 mov	 edx, DWORD PTR [ebx]
  006a7	8b 02		 mov	 eax, DWORD PTR [edx]
  006a9	6a 01		 push	 1
  006ab	8b cb		 mov	 ecx, ebx
  006ad	ff d0		 call	 eax

; 2900 : 					shot = 0;

  006af	33 db		 xor	 ebx, ebx
$LN11@DamageShip:

; 2901 : 				}
; 2902 : 			}
; 2903 : 		}
; 2904 : 
; 2905 : 		// CHECK FOR COLLISION WITH ASTEROIDS:
; 2906 : 		ListIter<Asteroid> a_iter = asteroids;

  006b1	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  006b4	8d 86 ac 00 00
	00		 lea	 eax, DWORD PTR [esi+172]
  006ba	89 44 24 2c	 mov	 DWORD PTR _a_iter$120827[esp+144], eax
  006be	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR _a_iter$120827[esp+148], -1

; 2907 : 		while (shot && ++a_iter) {

  006c6	85 db		 test	 ebx, ebx
  006c8	74 72		 je	 SHORT $LN4@DamageShip
  006ca	8d 9b 00 00 00
	00		 npad	 6
$LL5@DamageShip:
  006d0	8d 54 24 2c	 lea	 edx, DWORD PTR _a_iter$120827[esp+144]
  006d4	e8 00 00 00 00	 call	 ?next@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::next
  006d9	85 c0		 test	 eax, eax
  006db	74 5f		 je	 SHORT $LN4@DamageShip

; 2908 : 			Asteroid* a = a_iter.value();

  006dd	8d 44 24 2c	 lea	 eax, DWORD PTR _a_iter$120827[esp+144]
  006e1	e8 00 00 00 00	 call	 ?value@?$ListIter@VAsteroid@@@@QAEPAVAsteroid@@XZ ; ListIter<Asteroid>::value

; 2909 : 
; 2910 : 			int hit = a->HitBy(shot, impact);

  006e6	8b 10		 mov	 edx, DWORD PTR [eax]
  006e8	8b 92 b8 00 00
	00		 mov	 edx, DWORD PTR [edx+184]
  006ee	8d 4c 24 78	 lea	 ecx, DWORD PTR _impact$[esp+144]
  006f2	51		 push	 ecx
  006f3	53		 push	 ebx
  006f4	8b c8		 mov	 ecx, eax
  006f6	ff d2		 call	 edx

; 2911 : 			if (hit) {

  006f8	85 c0		 test	 eax, eax
  006fa	74 d4		 je	 SHORT $LL5@DamageShip

; 2912 : 				if (!shot->IsBeam()) {

  006fc	8b 03		 mov	 eax, DWORD PTR [ebx]
  006fe	8b 90 d8 00 00
	00		 mov	 edx, DWORD PTR [eax+216]
  00704	8b cb		 mov	 ecx, ebx
  00706	ff d2		 call	 edx
  00708	84 c0		 test	 al, al
  0070a	75 c4		 jne	 SHORT $LL5@DamageShip

; 2913 : 					if (shot->IsDrone())

  0070c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0070e	8b 90 c4 00 00
	00		 mov	 edx, DWORD PTR [eax+196]
  00714	8b cb		 mov	 ecx, ebx
  00716	ff d2		 call	 edx
  00718	84 c0		 test	 al, al
  0071a	74 0d		 je	 SHORT $LN1@DamageShip

; 2914 : 					drones.remove((Drone*) shot);

  0071c	8d 86 88 00 00
	00		 lea	 eax, DWORD PTR [esi+136]
  00722	8b fb		 mov	 edi, ebx
  00724	e8 00 00 00 00	 call	 ?remove@?$List@VDrone@@@@QAEPAVDrone@@PBV2@@Z ; List<Drone>::remove
$LN1@DamageShip:

; 2915 : 					
; 2916 : 					shot_iter.removeItem();

  00729	8d 54 24 14	 lea	 edx, DWORD PTR _shot_iter$[esp+144]
  0072d	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::removeItem

; 2917 : 					delete shot;

  00732	8b 03		 mov	 eax, DWORD PTR [ebx]
  00734	8b 10		 mov	 edx, DWORD PTR [eax]
  00736	6a 01		 push	 1
  00738	8b cb		 mov	 ecx, ebx
  0073a	ff d2		 call	 edx
$LN4@DamageShip:

; 2702 : 
; 2703 : 	// FOR EACH SHOT IN THE REGION:
; 2704 : 	ListIter<Shot> shot_iter = shots;
; 2705 : 	while (++shot_iter) {

  0073c	8d 54 24 14	 lea	 edx, DWORD PTR _shot_iter$[esp+144]
  00740	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  00745	85 c0		 test	 eax, eax
  00747	0f 85 14 f9 ff
	ff		 jne	 $LN62@DamageShip
$LN63@DamageShip:

; 2918 : 					shot = 0;
; 2919 : 				}
; 2920 : 			}
; 2921 : 		}
; 2922 : 	}
; 2923 : }

  0074d	5f		 pop	 edi
  0074e	5e		 pop	 esi
  0074f	5b		 pop	 ebx
  00750	8b e5		 mov	 esp, ebp
  00752	5d		 pop	 ebp
  00753	c2 04 00	 ret	 4
?DamageShips@SimRegion@@IAEXXZ ENDP			; SimRegion::DamageShips
_TEXT	ENDS
PUBLIC	__real@3f947ae147ae147b
PUBLIC	?UpdateShots@SimRegion@@IAEXN@Z			; SimRegion::UpdateShots
;	COMDAT __real@3f947ae147ae147b
; File c:\matrix games\dev\ngenex\physical.h
CONST	SEGMENT
__real@3f947ae147ae147b DQ 03f947ae147ae147br	; 0.02
; Function compile flags: /Ogtp
; File c:\matrix games\dev\stars45\sim.cpp
CONST	ENDS
;	COMDAT ?UpdateShots@SimRegion@@IAEXN@Z
_TEXT	SEGMENT
_shot_iter$ = -8					; size = 8
_seconds$ = 8						; size = 8
?UpdateShots@SimRegion@@IAEXN@Z PROC			; SimRegion::UpdateShots, COMDAT
; _this$ = esi

; 2635 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2636 : 	ListIter<Shot> shot_iter = shots;

  00006	8d 46 7c	 lea	 eax, DWORD PTR [esi+124]
  00009	57		 push	 edi

; 2637 : 	while (++shot_iter) {

  0000a	8d 55 f8	 lea	 edx, DWORD PTR _shot_iter$[ebp]
  0000d	89 45 f8	 mov	 DWORD PTR _shot_iter$[ebp], eax
  00010	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _shot_iter$[ebp+4], -1
  00017	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 c1 00 00
	00		 je	 $LN6@UpdateShot
$LL7@UpdateShot:

; 2638 : 		Shot* shot = shot_iter.value();

  00024	8d 45 f8	 lea	 eax, DWORD PTR _shot_iter$[ebp]
  00027	e8 00 00 00 00	 call	 ?value@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::value

; 2639 : 		shot->ExecFrame(seconds);

  0002c	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  00031	8b f8		 mov	 edi, eax
  00033	8b 17		 mov	 edx, DWORD PTR [edi]
  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00038	83 ec 08	 sub	 esp, 8
  0003b	8b cf		 mov	 ecx, edi
  0003d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00042	ff d0		 call	 eax

; 2640 : 
; 2641 : 		if (shot->Design()->flak) {

  00044	8b 8f 20 02 00
	00		 mov	 ecx, DWORD PTR [edi+544]
  0004a	80 79 22 00	 cmp	 BYTE PTR [ecx+34], 0
  0004e	74 41		 je	 SHORT $LN4@UpdateShot

; 2642 : 			SeekerAI* seeker = (SeekerAI*) shot->GetDirector();
; 2643 : 
; 2644 : 			if (shot->Life() < 0.02 || seeker && seeker->Overshot()) {

  00050	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f947ae147ae147b
  00058	66 0f 2f 87 a8
	01 00 00	 comisd	 xmm0, QWORD PTR [edi+424]
  00060	8b 8f c4 01 00
	00		 mov	 ecx, DWORD PTR [edi+452]
  00066	77 0f		 ja	 SHORT $LN3@UpdateShot
  00068	85 c9		 test	 ecx, ecx
  0006a	74 25		 je	 SHORT $LN4@UpdateShot
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00071	ff d0		 call	 eax
  00073	84 c0		 test	 al, al
  00075	74 1a		 je	 SHORT $LN4@UpdateShot
$LN3@UpdateShot:

; 2645 : 				shot->SetFuse(0.001); // set lifetime to ~zero

  00077	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  0007f	8b c7		 mov	 eax, edi
  00081	e8 00 00 00 00	 call	 ?SetFuse@Shot@@QAEXN@Z	; Shot::SetFuse

; 2646 : 				sim->CreateSplashDamage(shot);

  00086	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00089	51		 push	 ecx
  0008a	8b cf		 mov	 ecx, edi
  0008c	e8 00 00 00 00	 call	 ?CreateSplashDamage@Sim@@QAEXPAVShot@@@Z ; Sim::CreateSplashDamage
$LN4@UpdateShot:

; 2647 : 			}
; 2648 : 		}
; 2649 : 		
; 2650 : 		if (shot->Life() < 0.01) {  // died of old age

  00091	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f847ae147ae147b
  00099	66 0f 2f 87 a8
	01 00 00	 comisd	 xmm0, QWORD PTR [edi+424]
  000a1	76 32		 jbe	 SHORT $LN10@UpdateShot

; 2651 : 			NetUtil::SendWepDestroy(shot);

  000a3	e8 00 00 00 00	 call	 ?SendWepDestroy@NetUtil@@SAXPAVShot@@@Z ; NetUtil::SendWepDestroy

; 2652 : 
; 2653 : 			if (shot->IsDrone())

  000a8	8b 17		 mov	 edx, DWORD PTR [edi]
  000aa	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  000b0	8b cf		 mov	 ecx, edi
  000b2	ff d0		 call	 eax
  000b4	84 c0		 test	 al, al
  000b6	74 0b		 je	 SHORT $LN1@UpdateShot

; 2654 : 			drones.remove((Drone*) shot);

  000b8	8d 86 88 00 00
	00		 lea	 eax, DWORD PTR [esi+136]
  000be	e8 00 00 00 00	 call	 ?remove@?$List@VDrone@@@@QAEPAVDrone@@PBV2@@Z ; List<Drone>::remove
$LN1@UpdateShot:

; 2655 : 
; 2656 : 			shot_iter.removeItem();

  000c3	8d 55 f8	 lea	 edx, DWORD PTR _shot_iter$[ebp]
  000c6	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::removeItem

; 2657 : 			delete shot;

  000cb	8b 17		 mov	 edx, DWORD PTR [edi]
  000cd	8b 02		 mov	 eax, DWORD PTR [edx]
  000cf	6a 01		 push	 1
  000d1	8b cf		 mov	 ecx, edi
  000d3	ff d0		 call	 eax
$LN10@UpdateShot:

; 2637 : 	while (++shot_iter) {

  000d5	8d 55 f8	 lea	 edx, DWORD PTR _shot_iter$[ebp]
  000d8	e8 00 00 00 00	 call	 ?next@?$ListIter@VShot@@@@QAEPAVShot@@XZ ; ListIter<Shot>::next
  000dd	85 c0		 test	 eax, eax
  000df	0f 85 3f ff ff
	ff		 jne	 $LL7@UpdateShot
$LN6@UpdateShot:

; 2658 : 			shot = 0;
; 2659 : 		}
; 2660 : 	}
; 2661 : }

  000e5	5f		 pop	 edi
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 08 00	 ret	 8
?UpdateShots@SimRegion@@IAEXN@Z ENDP			; SimRegion::UpdateShots
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?ExecFrame@SimRegion@@UAEXN@Z
_TEXT	SEGMENT
tv389 = -48						; size = 4
_seconds$ = -48						; size = 8
$T407408 = -40						; size = 12
_max_frame$120611 = -40					; size = 8
_ref$ = -24						; size = 24
_secs$ = 8						; size = 8
?ExecFrame@SimRegion@@UAEXN@Z PROC			; SimRegion::ExecFrame, COMDAT
; _this$ = ecx

; 2507 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 2508 : 	if (!sim) return;

  0000d	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00011	57		 push	 edi
  00012	0f 84 ff 01 00
	00		 je	 $LN1@ExecFrame

; 2509 : 
; 2510 : 	double seconds    = secs;
; 2511 : 
; 2512 : 	// DON'T REALLY KNOW WHAT PURPOSE THIS SERVES....
; 2513 : 	if (!active) {

  00018	80 7e 40 00	 cmp	 BYTE PTR [esi+64], 0
  0001c	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _secs$[ebp]
  00021	f2 0f 11 44 24
	10		 movsd	 QWORD PTR _seconds$[esp+64], xmm0
  00027	75 53		 jne	 SHORT $LN7@ExecFrame

; 2514 : 		double max_frame  = 3 * Game::GetMaxFrameLength();

  00029	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?max_frame_length@Game@@1NA
  00031	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4008000000000000
  00039	f2 0f 11 44 24
	18		 movsd	 QWORD PTR _max_frame$120611[esp+64], xmm0

; 2515 : 		long   new_time   = Game::GameTime();

  0003f	e8 00 00 00 00	 call	 ?GameTime@Game@@SAKXZ	; Game::GameTime

; 2516 : 		double delta      = new_time - sim_time;

  00044	2b 86 00 01 00
	00		 sub	 eax, DWORD PTR [esi+256]

; 2517 : 		seconds    = delta / 1000.0;

  0004a	89 44 24 10	 mov	 DWORD PTR tv389[esp+64], eax
  0004e	db 44 24 10	 fild	 DWORD PTR tv389[esp+64]
  00052	79 06		 jns	 SHORT $LN40@ExecFrame
  00054	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN40@ExecFrame:
  0005a	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@408f400000000000

; 2518 : 
; 2519 : 		if (seconds > max_frame)

  00060	f2 0f 10 44 24
	18		 movsd	 xmm0, QWORD PTR _max_frame$120611[esp+64]
  00066	dd 5c 24 10	 fstp	 QWORD PTR _seconds$[esp+64]
  0006a	f2 0f 10 4c 24
	10		 movsd	 xmm1, QWORD PTR _seconds$[esp+64]
  00070	66 0f 2f c8	 comisd	 xmm1, xmm0
  00074	76 06		 jbe	 SHORT $LN7@ExecFrame

; 2520 : 		seconds = max_frame;

  00076	f2 0f 11 44 24
	10		 movsd	 QWORD PTR _seconds$[esp+64], xmm0
$LN7@ExecFrame:

; 2521 : 	}
; 2522 : 
; 2523 : 	sim_time = Game::GameTime();

  0007c	e8 00 00 00 00	 call	 ?GameTime@Game@@SAKXZ	; Game::GameTime
  00081	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax

; 2524 : 
; 2525 : 	if (orbital_region)

  00087	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0008a	85 c0		 test	 eax, eax
  0008c	74 1e		 je	 SHORT $LN18@ExecFrame

; 2526 : 	location = orbital_region->Location();

  0008e	f2 0f 10 40 60	 movsd	 xmm0, QWORD PTR [eax+96]
  00093	f2 0f 10 48 68	 movsd	 xmm1, QWORD PTR [eax+104]
  00098	f2 0f 10 50 70	 movsd	 xmm2, QWORD PTR [eax+112]
  0009d	f2 0f 11 46 20	 movsd	 QWORD PTR [esi+32], xmm0
  000a2	f2 0f 11 4e 28	 movsd	 QWORD PTR [esi+40], xmm1
  000a7	f2 0f 11 56 30	 movsd	 QWORD PTR [esi+48], xmm2
$LN18@ExecFrame:

; 2527 : 
; 2528 : 	CameraDirector* cam_dir = CameraDirector::GetInstance();

  000ac	e8 00 00 00 00	 call	 ?GetInstance@CameraDirector@@SAPAV1@XZ ; CameraDirector::GetInstance

; 2529 : 
; 2530 : 	Point ref;
; 2531 : 
; 2532 : 	if (active && cam_dir) {

  000b1	80 7e 40 00	 cmp	 BYTE PTR [esi+64], 0
  000b5	0f 57 c0	 xorps	 xmm0, xmm0
  000b8	8b d8		 mov	 ebx, eax
  000ba	f2 0f 11 44 24
	28		 movsd	 QWORD PTR _ref$[esp+64], xmm0
  000c0	f2 0f 11 44 24
	30		 movsd	 QWORD PTR _ref$[esp+72], xmm0
  000c6	f2 0f 11 44 24
	38		 movsd	 QWORD PTR _ref$[esp+80], xmm0
  000cc	74 48		 je	 SHORT $LN5@ExecFrame
  000ce	85 db		 test	 ebx, ebx
  000d0	74 44		 je	 SHORT $LN5@ExecFrame

; 2533 : 		ref = cam_dir->GetCamera()->Pos();

  000d2	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d4	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  000d7	8b cb		 mov	 ecx, ebx
  000d9	ff d2		 call	 edx
  000db	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  000e0	f2 0f 10 48 10	 movsd	 xmm1, QWORD PTR [eax+16]
  000e5	f2 0f 10 50 18	 movsd	 xmm2, QWORD PTR [eax+24]

; 2534 : 		UpdateSky(seconds, ref);

  000ea	83 ec 08	 sub	 esp, 8
  000ed	f2 0f 11 44 24
	30		 movsd	 QWORD PTR _ref$[esp+72], xmm0
  000f3	f2 0f 10 44 24
	18		 movsd	 xmm0, QWORD PTR _seconds$[esp+72]
  000f9	8d 44 24 30	 lea	 eax, DWORD PTR _ref$[esp+72]
  000fd	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00102	50		 push	 eax
  00103	8b c6		 mov	 eax, esi
  00105	f2 0f 11 4c 24
	3c		 movsd	 QWORD PTR _ref$[esp+84], xmm1
  0010b	f2 0f 11 54 24
	44		 movsd	 QWORD PTR _ref$[esp+92], xmm2
  00111	e8 00 00 00 00	 call	 ?UpdateSky@SimRegion@@IAEXNABUPoint@@@Z ; SimRegion::UpdateSky
$LN5@ExecFrame:

; 2535 : 	}
; 2536 : 
; 2537 : 	if (terrain)

  00116	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00119	85 c9		 test	 ecx, ecx
  0011b	74 15		 je	 SHORT $LN4@ExecFrame

; 2538 : 	terrain->ExecFrame(seconds);

  0011d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011f	f2 0f 10 44 24
	10		 movsd	 xmm0, QWORD PTR _seconds$[esp+64]
  00125	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00128	83 ec 08	 sub	 esp, 8
  0012b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00130	ff d0		 call	 eax
$LN4@ExecFrame:

; 2539 : 
; 2540 : 	UpdateTracks(seconds);

  00132	56		 push	 esi
  00133	e8 00 00 00 00	 call	 ?UpdateTracks@SimRegion@@IAEXN@Z ; SimRegion::UpdateTracks

; 2541 : 	UpdateShips(seconds);

  00138	f2 0f 10 44 24
	10		 movsd	 xmm0, QWORD PTR _seconds$[esp+64]
  0013e	83 ec 08	 sub	 esp, 8
  00141	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00146	e8 00 00 00 00	 call	 ?UpdateShips@SimRegion@@IAEXN@Z ; SimRegion::UpdateShips

; 2542 : 	UpdateShots(seconds);

  0014b	f2 0f 10 44 24
	10		 movsd	 xmm0, QWORD PTR _seconds$[esp+64]
  00151	83 ec 08	 sub	 esp, 8
  00154	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00159	e8 00 00 00 00	 call	 ?UpdateShots@SimRegion@@IAEXN@Z ; SimRegion::UpdateShots

; 2543 : 	UpdateExplosions(seconds);

  0015e	f2 0f 10 44 24
	10		 movsd	 xmm0, QWORD PTR _seconds$[esp+64]
  00164	83 ec 08	 sub	 esp, 8
  00167	8b c6		 mov	 eax, esi
  00169	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0016e	e8 00 00 00 00	 call	 ?UpdateExplosions@SimRegion@@IAEXN@Z ; SimRegion::UpdateExplosions

; 2544 : 
; 2545 : 	if (!Game::Paused()) {

  00173	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?paused@Game@@1_NA, 0 ; Game::paused
  0017a	75 25		 jne	 SHORT $LN3@ExecFrame

; 2546 : 		DamageShips();

  0017c	56		 push	 esi
  0017d	e8 00 00 00 00	 call	 ?DamageShips@SimRegion@@IAEXXZ ; SimRegion::DamageShips

; 2547 : 		DockShips();

  00182	56		 push	 esi
  00183	e8 00 00 00 00	 call	 ?DockShips@SimRegion@@IAEXXZ ; SimRegion::DockShips

; 2548 : 
; 2549 : 		if (active) {

  00188	80 7e 40 00	 cmp	 BYTE PTR [esi+64], 0
  0018c	74 0c		 je	 SHORT $LN2@ExecFrame

; 2550 : 			CollideShips();

  0018e	56		 push	 esi
  0018f	e8 00 00 00 00	 call	 ?CollideShips@SimRegion@@IAEXXZ ; SimRegion::CollideShips

; 2551 : 			CrashShips();

  00194	56		 push	 esi
  00195	e8 00 00 00 00	 call	 ?CrashShips@SimRegion@@IAEXXZ ; SimRegion::CrashShips
$LN2@ExecFrame:

; 2552 : 		}
; 2553 : 
; 2554 : 		DestroyShips();

  0019a	8b fe		 mov	 edi, esi
  0019c	e8 00 00 00 00	 call	 ?DestroyShips@SimRegion@@IAEXXZ ; SimRegion::DestroyShips
$LN3@ExecFrame:

; 2555 : 	}
; 2556 : 
; 2557 : 	if (active && cam_dir && player_ship) {

  001a1	80 7e 40 00	 cmp	 BYTE PTR [esi+64], 0
  001a5	74 70		 je	 SHORT $LN1@ExecFrame
  001a7	85 db		 test	 ebx, ebx
  001a9	74 6c		 je	 SHORT $LN1@ExecFrame
  001ab	8b 76 44	 mov	 esi, DWORD PTR [esi+68]
  001ae	85 f6		 test	 esi, esi
  001b0	74 65		 je	 SHORT $LN1@ExecFrame

; 2558 : 		Sound::SetListener(*(cam_dir->GetCamera()), player_ship->Velocity());

  001b2	f2 0f 10 86 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [esi+168]
  001ba	f2 0f 58 86 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [esi+192]
  001c2	f2 0f 10 8e c8
	00 00 00	 movsd	 xmm1, QWORD PTR [esi+200]
  001ca	f2 0f 10 96 d0
	00 00 00	 movsd	 xmm2, QWORD PTR [esi+208]
  001d2	f2 0f 58 8e b0
	00 00 00	 addsd	 xmm1, QWORD PTR [esi+176]
  001da	f2 0f 58 96 b8
	00 00 00	 addsd	 xmm2, QWORD PTR [esi+184]
  001e2	8b 13		 mov	 edx, DWORD PTR [ebx]
  001e4	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  001e7	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  001eb	f3 0f 11 44 24
	18		 movss	 DWORD PTR $T407408[esp+64], xmm0
  001f1	8d 4c 24 18	 lea	 ecx, DWORD PTR $T407408[esp+64]
  001f5	51		 push	 ecx
  001f6	8b cb		 mov	 ecx, ebx
  001f8	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  001fc	f3 0f 11 44 24
	20		 movss	 DWORD PTR $T407408[esp+72], xmm0
  00202	66 0f 5a c2	 cvtpd2ps xmm0, xmm2
  00206	f3 0f 11 44 24
	24		 movss	 DWORD PTR $T407408[esp+76], xmm0
  0020c	ff d0		 call	 eax
  0020e	50		 push	 eax
  0020f	e8 00 00 00 00	 call	 ?SetListener@Sound@@SAXABVCamera@@ABUVec3@@@Z ; Sound::SetListener
  00214	83 c4 08	 add	 esp, 8
$LN1@ExecFrame:

; 2559 : 	}
; 2560 : }

  00217	5f		 pop	 edi
  00218	5e		 pop	 esi
  00219	5b		 pop	 ebx
  0021a	8b e5		 mov	 esp, ebp
  0021c	5d		 pop	 ebp
  0021d	c2 08 00	 ret	 8
?ExecFrame@SimRegion@@UAEXN@Z ENDP			; SimRegion::ExecFrame
_TEXT	ENDS
PUBLIC	?ResolveTimeSkip@Sim@@QAEXN@Z			; Sim::ResolveTimeSkip
; Function compile flags: /Ogtp
;	COMDAT ?ResolveTimeSkip@Sim@@QAEXN@Z
_TEXT	SEGMENT
_total_skip$120102 = -16				; size = 8
_elem$ = -16						; size = 8
_skipped$ = -8						; size = 8
_seconds$ = 8						; size = 8
?ResolveTimeSkip@Sim@@QAEXN@Z PROC			; Sim::ResolveTimeSkip, COMDAT
; _this$ = esi

; 1945 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1946 : 	double skipped   = 0;

  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 1947 : 
; 1948 : 	// allow elements to process hold time, and release as needed:
; 1949 : 	ListIter<Element> elem = elements;

  00009	8d 86 88 00 00
	00		 lea	 eax, DWORD PTR [esi+136]
  0000f	57		 push	 edi

; 1950 : 	while (++elem)

  00010	8d 55 f0	 lea	 edx, DWORD PTR _elem$[ebp]
  00013	f2 0f 11 45 f8	 movsd	 QWORD PTR _skipped$[ebp], xmm0
  00018	89 45 f0	 mov	 DWORD PTR _elem$[ebp], eax
  0001b	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _elem$[ebp+4], -1
  00022	e8 00 00 00 00	 call	 ?next@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::next
  00027	85 c0		 test	 eax, eax
  00029	74 2f		 je	 SHORT $LN10@ResolveTim@2
  0002b	eb 03 8d 49 00	 npad	 5
$LL11@ResolveTim@2:

; 1951 : 	elem->ExecFrame(seconds);

  00030	8d 45 f0	 lea	 eax, DWORD PTR _elem$[ebp]
  00033	e8 00 00 00 00	 call	 ?value@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::value
  00038	8b 10		 mov	 edx, DWORD PTR [eax]
  0003a	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  0003f	83 ec 08	 sub	 esp, 8
  00042	8b c8		 mov	 ecx, eax
  00044	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00047	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0004c	ff d0		 call	 eax
  0004e	8d 55 f0	 lea	 edx, DWORD PTR _elem$[ebp]
  00051	e8 00 00 00 00	 call	 ?next@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::next
  00056	85 c0		 test	 eax, eax
  00058	75 d6		 jne	 SHORT $LL11@ResolveTim@2
$LN10@ResolveTim@2:

; 1952 : 
; 1953 : 	// step through the skip, ten seconds at a time:
; 1954 : 	if (active_region) {

  0005a	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0005e	0f 84 a6 00 00
	00		 je	 $LN9@ResolveTim@2

; 1955 : 		double total_skip = seconds;

  00064	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]

; 1956 : 		double frame_skip = 10;
; 1957 : 		Ship*  player     = GetPlayerShip();

  00069	8b ce		 mov	 ecx, esi
  0006b	f2 0f 11 45 f0	 movsd	 QWORD PTR _total_skip$120102[ebp], xmm0
  00070	e8 00 00 00 00	 call	 ?GetPlayerShip@Sim@@QAEPAVShip@@XZ ; Sim::GetPlayerShip

; 1958 : 
; 1959 : 		while (total_skip > frame_skip) {

  00075	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  0007a	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR _DEFAULT_TRACK_AGE
  00082	76 57		 jbe	 SHORT $LN28@ResolveTim@2
$LL8@ResolveTim@2:

; 1960 : 			if (active_region->CanTimeSkip()) {

  00084	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ?CanTimeSkip@SimRegion@@QBE_NXZ ; SimRegion::CanTimeSkip
  0008d	84 c0		 test	 al, al
  0008f	74 45		 je	 SHORT $LN6@ResolveTim@2

; 1961 : 				active_region->ResolveTimeSkip(frame_skip);

  00091	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _DEFAULT_TRACK_AGE
  00099	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0009c	83 ec 08	 sub	 esp, 8
  0009f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ?ResolveTimeSkip@SimRegion@@QAEXN@Z ; SimRegion::ResolveTimeSkip

; 1962 : 				total_skip -= frame_skip;

  000aa	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR _DEFAULT_TRACK_AGE
  000b2	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _total_skip$120102[ebp]

; 1963 : 				skipped    += frame_skip;

  000b7	f2 0f 10 55 f8	 movsd	 xmm2, QWORD PTR _skipped$[ebp]
  000bc	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000c0	66 0f 2f c1	 comisd	 xmm0, xmm1
  000c4	f2 0f 58 d1	 addsd	 xmm2, xmm1
  000c8	f2 0f 11 45 f0	 movsd	 QWORD PTR _total_skip$120102[ebp], xmm0
  000cd	f2 0f 11 55 f8	 movsd	 QWORD PTR _skipped$[ebp], xmm2
  000d2	77 b0		 ja	 SHORT $LL8@ResolveTim@2

; 1958 : 
; 1959 : 		while (total_skip > frame_skip) {

  000d4	eb 0a		 jmp	 SHORT $LN27@ResolveTim@2
$LN6@ResolveTim@2:

; 1964 : 			}
; 1965 : 			// break out early if player runs into bad guys...
; 1966 : 			else {
; 1967 : 				total_skip = 0;

  000d6	0f 57 c0	 xorps	 xmm0, xmm0

; 1958 : 
; 1959 : 		while (total_skip > frame_skip) {

  000d9	eb 25		 jmp	 SHORT $LN4@ResolveTim@2
$LN28@ResolveTim@2:
  000db	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _total_skip$120102[ebp]
$LN27@ResolveTim@2:

; 1968 : 			}
; 1969 : 		}
; 1970 : 
; 1971 : 		if (total_skip > 0)

  000e0	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  000e8	76 16		 jbe	 SHORT $LN4@ResolveTim@2

; 1972 : 		active_region->ResolveTimeSkip(total_skip);

  000ea	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ed	83 ec 08	 sub	 esp, 8
  000f0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?ResolveTimeSkip@SimRegion@@QAEXN@Z ; SimRegion::ResolveTimeSkip
  000fb	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _total_skip$120102[ebp]
$LN4@ResolveTim@2:

; 1973 : 		skipped += total_skip;

  00100	f2 0f 58 45 f8	 addsd	 xmm0, QWORD PTR _skipped$[ebp]
  00105	f2 0f 11 45 f8	 movsd	 QWORD PTR _skipped$[ebp], xmm0
$LN9@ResolveTim@2:

; 1974 : 	}
; 1975 : 
; 1976 : 	// give player control after time skip:
; 1977 : 	Ship* player_ship = GetPlayerShip();

  0010a	8b ce		 mov	 ecx, esi
  0010c	e8 00 00 00 00	 call	 ?GetPlayerShip@Sim@@QAEPAVShip@@XZ ; Sim::GetPlayerShip
  00111	8b f8		 mov	 edi, eax

; 1978 : 	if (player_ship) {

  00113	85 ff		 test	 edi, edi
  00115	74 43		 je	 SHORT $LN1@ResolveTim@2

; 1979 : 		player_ship->SetAutoNav(false);

  00117	32 c9		 xor	 cl, cl
  00119	e8 00 00 00 00	 call	 ?SetAutoNav@Ship@@QAEX_N@Z ; Ship::SetAutoNav

; 1980 : 		player_ship->SetThrottle(75);

  0011e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4052c00000000000
  00126	8b c7		 mov	 eax, edi
  00128	e8 00 00 00 00	 call	 ?SetThrottle@Ship@@QAEXN@Z ; Ship::SetThrottle

; 1981 : 
; 1982 : 		HUDView* hud = HUDView::GetInstance();

  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hud_view@HUDView@@1PAV1@A ; HUDView::hud_view

; 1983 : 		if (hud)

  00133	85 c9		 test	 ecx, ecx
  00135	74 0c		 je	 SHORT $LN2@ResolveTim@2

; 1984 : 		hud->SetHUDMode(HUDView::HUD_MODE_TAC);

  00137	8b 11		 mov	 edx, DWORD PTR [ecx]
  00139	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  0013f	6a 01		 push	 1
  00141	ff d0		 call	 eax
$LN2@ResolveTim@2:

; 1985 : 
; 1986 : 		if (IsTestMode())

  00143	80 be bc 00 00
	00 00		 cmp	 BYTE PTR [esi+188], 0
  0014a	74 0e		 je	 SHORT $LN1@ResolveTim@2

; 1987 : 		player_ship->SetControls(0);

  0014c	8b 17		 mov	 edx, DWORD PTR [edi]
  0014e	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  00154	6a 00		 push	 0
  00156	8b cf		 mov	 ecx, edi
  00158	ff d0		 call	 eax
$LN1@ResolveTim@2:

; 1988 : 	}
; 1989 : 
; 1990 : 	Game::SkipGameTime(skipped);

  0015a	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _skipped$[ebp]
  0015f	83 ec 08	 sub	 esp, 8
  00162	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00167	e8 00 00 00 00	 call	 ?SkipGameTime@Game@@SAXN@Z ; Game::SkipGameTime

; 1991 : 	CameraDirector::SetCameraMode(CameraDirector::MODE_COCKPIT);

  0016c	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00174	83 c4 08	 add	 esp, 8
  00177	e8 00 00 00 00	 call	 ?SetCameraMode@CameraDirector@@SAXHN@Z ; CameraDirector::SetCameraMode

; 1992 : }

  0017c	5f		 pop	 edi
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c2 08 00	 ret	 8
?ResolveTimeSkip@Sim@@QAEXN@Z ENDP			; Sim::ResolveTimeSkip
_TEXT	ENDS
PUBLIC	?ResolveSplashList@Sim@@QAEXXZ			; Sim::ResolveSplashList
; Function compile flags: /Ogtp
;	COMDAT ?ResolveSplashList@Sim@@QAEXXZ
_TEXT	SEGMENT
_owner$119970 = -92					; size = 4
_cmdr_stats$119979 = -88				; size = 4
_killer$119966 = -88					; size = 4
tv576 = -84						; size = 4
_s_iter$119950 = -80					; size = 8
_drone_iter$120022 = -72				; size = 8
_iter$119943 = -64					; size = 8
_damage$119959 = -56					; size = 8
$T407512 = -48						; size = 24
$T407513 = -24						; size = 24
_this$ = 8						; size = 4
?ResolveSplashList@Sim@@QAEXXZ PROC			; Sim::ResolveSplashList, COMDAT

; 1747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 74	 sub	 esp, 116		; 00000074H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1748 : 	if (splashlist.size()) {

  0000b	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0000e	83 c6 7c	 add	 esi, 124		; 0000007cH
  00011	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00014	57		 push	 edi
  00015	89 74 24 2c	 mov	 DWORD PTR tv576[esp+128], esi
  00019	0f 84 33 04 00
	00		 je	 $LN27@ResolveSpl

; 1749 : 		ListIter<SimSplash> iter = splashlist;
; 1750 : 		while (++iter) {

  0001f	8d 54 24 40	 lea	 edx, DWORD PTR _iter$119943[esp+128]
  00023	89 74 24 40	 mov	 DWORD PTR _iter$119943[esp+128], esi
  00027	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR _iter$119943[esp+132], -1
  0002f	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ ; ListIter<SimSplash>::next
  00034	85 c0		 test	 eax, eax
  00036	0f 84 11 04 00
	00		 je	 $LN25@ResolveSpl
$LN26@ResolveSpl:

; 1751 : 			SimSplash* splash = iter.value();

  0003c	8d 44 24 40	 lea	 eax, DWORD PTR _iter$119943[esp+128]
  00040	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ ; ListIter<SimSplash>::value
  00045	8b f0		 mov	 esi, eax

; 1752 : 
; 1753 : 			if (!splash->rgn)

  00047	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 e6 03 00
	00		 je	 $LN3@ResolveSpl

; 1754 : 			continue;
; 1755 : 
; 1756 : 			// damage ships:
; 1757 : 			ListIter<Ship> s_iter = splash->rgn->Ships();

  00052	83 c0 4c	 add	 eax, 76			; 0000004cH

; 1758 : 			while (++s_iter) {

  00055	8d 54 24 30	 lea	 edx, DWORD PTR _s_iter$119950[esp+128]
  00059	89 44 24 30	 mov	 DWORD PTR _s_iter$119950[esp+128], eax
  0005d	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR _s_iter$119950[esp+132], -1
  00065	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 4c 02 00
	00		 je	 $LN22@ResolveSpl
$LN23@ResolveSpl:

; 1759 : 				Ship* ship = s_iter.value();

  00072	8d 44 24 30	 lea	 eax, DWORD PTR _s_iter$119950[esp+128]
  00076	e8 00 00 00 00	 call	 ?value@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::value
  0007b	8b f8		 mov	 edi, eax

; 1760 : 
; 1761 : 				double distance = (ship->Location() - splash->loc).length();

  0007d	f2 0f 10 47 48	 movsd	 xmm0, QWORD PTR [edi+72]
  00082	f2 0f 10 4f 50	 movsd	 xmm1, QWORD PTR [edi+80]
  00087	f2 0f 5c 4e 10	 subsd	 xmm1, QWORD PTR [esi+16]
  0008c	f2 0f 5c 46 08	 subsd	 xmm0, QWORD PTR [esi+8]
  00091	f2 0f 10 57 58	 movsd	 xmm2, QWORD PTR [edi+88]
  00096	f2 0f 5c 56 18	 subsd	 xmm2, QWORD PTR [esi+24]
  0009b	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  0009f	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  000a3	f2 0f 58 c8	 addsd	 xmm1, xmm0
  000a7	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  000ab	f2 0f 58 ca	 addsd	 xmm1, xmm2
  000af	f2 0f 51 c1	 sqrtsd	 xmm0, xmm1

; 1762 : 
; 1763 : 				if (distance > 1 && distance < splash->range) {

  000b3	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  000bb	66 0f 2f c1	 comisd	 xmm0, xmm1
  000bf	0f 86 e8 01 00
	00		 jbe	 $LN19@ResolveSpl
  000c5	f2 0f 10 56 28	 movsd	 xmm2, QWORD PTR [esi+40]
  000ca	66 0f 2f d0	 comisd	 xmm2, xmm0
  000ce	0f 86 d9 01 00
	00		 jbe	 $LN19@ResolveSpl

; 1764 : 					double damage = splash->damage * (1 - distance/splash->range);

  000d4	f2 0f 5e c2	 divsd	 xmm0, xmm2
  000d8	f2 0f 5c c8	 subsd	 xmm1, xmm0
  000dc	f2 0f 59 4e 20	 mulsd	 xmm1, QWORD PTR [esi+32]
  000e1	f2 0f 11 4c 24
	48		 movsd	 QWORD PTR _damage$119959[esp+128], xmm1

; 1765 : 					if (!NetGame::IsNetGameClient()) {

  000e7	e8 00 00 00 00	 call	 ?IsNetGameClient@NetGame@@SA_NXZ ; NetGame::IsNetGameClient
  000ec	84 c0		 test	 al, al
  000ee	75 36		 jne	 SHORT $LN20@ResolveSpl

; 1766 : 						ship->InflictDamage(damage);

  000f0	0f 57 c0	 xorps	 xmm0, xmm0
  000f3	83 ec 18	 sub	 esp, 24			; 00000018H
  000f6	8b c4		 mov	 eax, esp
  000f8	6a 03		 push	 3
  000fa	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  000fe	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0
  00103	f2 0f 11 40 10	 movsd	 QWORD PTR [eax+16], xmm0
  00108	8b 07		 mov	 eax, DWORD PTR [edi]
  0010a	f2 0f 10 44 24
	64		 movsd	 xmm0, QWORD PTR _damage$119959[esp+156]
  00110	8b 90 6c 01 00
	00		 mov	 edx, DWORD PTR [eax+364]
  00116	6a 00		 push	 0
  00118	83 ec 08	 sub	 esp, 8
  0011b	8b cf		 mov	 ecx, edi
  0011d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00122	ff d2		 call	 edx
  00124	dd d8		 fstp	 ST(0)
$LN20@ResolveSpl:

; 1767 : 					}
; 1768 : 
; 1769 : 					int ship_destroyed = (!ship->InTransition() && ship->Integrity() < 1.0f);

  00126	83 bf 60 04 00
	00 00		 cmp	 DWORD PTR [edi+1120], 0
  0012d	0f 85 7a 01 00
	00		 jne	 $LN19@ResolveSpl
  00133	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0013b	0f 2f 87 b8 01
	00 00		 comiss	 xmm0, DWORD PTR [edi+440]

; 1770 : 
; 1771 : 					// then delete the ship:
; 1772 : 					if (ship_destroyed) {

  00142	0f 86 65 01 00
	00		 jbe	 $LN19@ResolveSpl

; 1773 : 						NetUtil::SendObjKill(ship, 0, NetObjKill::KILL_MISC);

  00148	6a 00		 push	 0
  0014a	6a 00		 push	 0
  0014c	6a 00		 push	 0
  0014e	8b cf		 mov	 ecx, edi
  00150	e8 00 00 00 00	 call	 ?SendObjKill@NetUtil@@SAXPAVShip@@PBV2@HH@Z ; NetUtil::SendObjKill

; 1774 : 						Print("    %s Killed %s (%s)\n", (const char*) splash->owner_name, ship->Name(), FormatGameTime());

  00155	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00157	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015a	e8 00 00 00 00	 call	 ?FormatGameTime@@YAPBDXZ ; FormatGameTime
  0015f	50		 push	 eax
  00160	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00163	50		 push	 eax
  00164	53		 push	 ebx
  00165	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@IBFIGKOO@?5?5?5?5?$CFs?5Killed?5?$CFs?5?$CI?$CFs?$CJ?6?$AA@
  0016a	e8 00 00 00 00	 call	 ?Print@@YAXPBDZZ	; Print

; 1775 : 
; 1776 : 						// record the kill
; 1777 : 						ShipStats* killer = ShipStats::Find(splash->owner_name);

  0016f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00171	83 c4 10	 add	 esp, 16			; 00000010H
  00174	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  00179	89 44 24 28	 mov	 DWORD PTR _killer$119966[esp+128], eax

; 1778 : 						if (killer) {

  0017d	85 c0		 test	 eax, eax
  0017f	74 16		 je	 SHORT $LN16@ResolveSpl

; 1779 : 							if (splash->missile)

  00181	80 7e 34 00	 cmp	 BYTE PTR [esi+52], 0

; 1780 : 							killer->AddEvent(SimEvent::MISSILE_KILL, ship->Name());

  00185	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00188	51		 push	 ecx
  00189	74 04		 je	 SHORT $LN17@ResolveSpl
  0018b	6a 11		 push	 17			; 00000011H

; 1781 : 							else

  0018d	eb 02		 jmp	 SHORT $LN146@ResolveSpl
$LN17@ResolveSpl:

; 1782 : 							killer->AddEvent(SimEvent::GUNS_KILL, ship->Name());

  0018f	6a 10		 push	 16			; 00000010H
$LN146@ResolveSpl:
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
$LN16@ResolveSpl:

; 1783 : 						}
; 1784 : 
; 1785 : 						Ship* owner = FindShip(splash->owner_name, splash->rgn->Name());

  00197	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00199	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0019c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0019f	51		 push	 ecx
  001a0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	51		 push	 ecx
  001a4	e8 00 00 00 00	 call	 ?FindShip@Sim@@QAEPAVShip@@PBD0@Z ; Sim::FindShip
  001a9	89 44 24 24	 mov	 DWORD PTR _owner$119970[esp+128], eax

; 1786 : 						if (owner && owner->GetIFF() != ship->GetIFF()) {

  001ad	85 c0		 test	 eax, eax
  001af	0f 84 da 00 00
	00		 je	 $LN92@ResolveSpl
  001b5	8b 10		 mov	 edx, DWORD PTR [eax]
  001b7	8b c8		 mov	 ecx, eax
  001b9	8b 82 98 01 00
	00		 mov	 eax, DWORD PTR [edx+408]
  001bf	ff d0		 call	 eax
  001c1	8b 17		 mov	 edx, DWORD PTR [edi]
  001c3	8b d8		 mov	 ebx, eax
  001c5	8b 82 98 01 00
	00		 mov	 eax, DWORD PTR [edx+408]
  001cb	8b cf		 mov	 ecx, edi
  001cd	ff d0		 call	 eax
  001cf	3b d8		 cmp	 ebx, eax
  001d1	0f 84 b8 00 00
	00		 je	 $LN92@ResolveSpl

; 1787 : 							if (ship->GetIFF() > 0 || owner->GetIFF() > 1) {

  001d7	8b 17		 mov	 edx, DWORD PTR [edi]
  001d9	8b 82 98 01 00
	00		 mov	 eax, DWORD PTR [edx+408]
  001df	8b cf		 mov	 ecx, edi
  001e1	ff d0		 call	 eax
  001e3	8b 5c 24 24	 mov	 ebx, DWORD PTR _owner$119970[esp+128]
  001e7	85 c0		 test	 eax, eax
  001e9	7f 15		 jg	 SHORT $LN13@ResolveSpl
  001eb	8b 13		 mov	 edx, DWORD PTR [ebx]
  001ed	8b 82 98 01 00
	00		 mov	 eax, DWORD PTR [edx+408]
  001f3	8b cb		 mov	 ecx, ebx
  001f5	ff d0		 call	 eax
  001f7	83 f8 01	 cmp	 eax, 1
  001fa	0f 8e 8f 00 00
	00		 jle	 $LN92@ResolveSpl
$LN13@ResolveSpl:

; 1788 : 								killer->AddPoints(ship->Value());

  00200	8b c7		 mov	 eax, edi
  00202	e8 00 00 00 00	 call	 ?Value@Ship@@QBEHXZ	; Ship::Value
  00207	8b 4c 24 28	 mov	 ecx, DWORD PTR _killer$119966[esp+128]
  0020b	01 41 58	 add	 DWORD PTR [ecx+88], eax

; 1789 : 
; 1790 : 								Element* elem = owner->GetElement();

  0020e	8b 9b e8 03 00
	00		 mov	 ebx, DWORD PTR [ebx+1000]

; 1791 : 								if (elem) {

  00214	85 db		 test	 ebx, ebx
  00216	74 77		 je	 SHORT $LN92@ResolveSpl

; 1792 : 									if (owner->GetElementIndex() > 1) {

  00218	8b 44 24 24	 mov	 eax, DWORD PTR _owner$119970[esp+128]
  0021c	e8 00 00 00 00	 call	 ?GetElementIndex@Ship@@QBEHXZ ; Ship::GetElementIndex
  00221	83 f8 01	 cmp	 eax, 1
  00224	7e 35		 jle	 SHORT $LN86@ResolveSpl

; 1793 : 										Ship* s = elem->GetShip(1);

  00226	b9 01 00 00 00	 mov	 ecx, 1
  0022b	8b c3		 mov	 eax, ebx
  0022d	e8 00 00 00 00	 call	 ?GetShip@Element@@QAEPAVShip@@H@Z ; Element::GetShip

; 1794 : 
; 1795 : 										if (s) {

  00232	85 c0		 test	 eax, eax
  00234	74 25		 je	 SHORT $LN86@ResolveSpl

; 1796 : 											ShipStats* cmdr_stats = ShipStats::Find(s->Name());

  00236	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00239	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  0023e	89 44 24 28	 mov	 DWORD PTR _cmdr_stats$119979[esp+128], eax

; 1797 : 											if (cmdr_stats) {

  00242	85 c0		 test	 eax, eax
  00244	74 15		 je	 SHORT $LN86@ResolveSpl

; 1798 : 												cmdr_stats->AddCommandPoints(ship->Value()/2);

  00246	8b c7		 mov	 eax, edi
  00248	e8 00 00 00 00	 call	 ?Value@Ship@@QBEHXZ	; Ship::Value
  0024d	99		 cdq
  0024e	2b c2		 sub	 eax, edx
  00250	8b c8		 mov	 ecx, eax
  00252	8b 44 24 28	 mov	 eax, DWORD PTR _cmdr_stats$119979[esp+128]
  00256	d1 f9		 sar	 ecx, 1
  00258	01 48 5c	 add	 DWORD PTR [eax+92], ecx
$LN86@ResolveSpl:

; 1799 : 											}
; 1800 : 										}
; 1801 : 									}
; 1802 : 
; 1803 : 									Element* cmdr = elem->GetCommander();

  0025b	8b 5b 74	 mov	 ebx, DWORD PTR [ebx+116]

; 1804 : 									if (cmdr) {

  0025e	85 db		 test	 ebx, ebx
  00260	74 2d		 je	 SHORT $LN92@ResolveSpl

; 1805 : 										Ship* s = cmdr->GetShip(1);

  00262	b9 01 00 00 00	 mov	 ecx, 1
  00267	8b c3		 mov	 eax, ebx
  00269	e8 00 00 00 00	 call	 ?GetShip@Element@@QAEPAVShip@@H@Z ; Element::GetShip

; 1806 : 
; 1807 : 										if (s) {

  0026e	85 c0		 test	 eax, eax
  00270	74 1d		 je	 SHORT $LN92@ResolveSpl

; 1808 : 											ShipStats* cmdr_stats = ShipStats::Find(s->Name());

  00272	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00275	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find
  0027a	8b d8		 mov	 ebx, eax

; 1809 : 											if (cmdr_stats) {

  0027c	85 db		 test	 ebx, ebx
  0027e	74 0f		 je	 SHORT $LN92@ResolveSpl

; 1810 : 												cmdr_stats->AddCommandPoints(ship->Value()/2);

  00280	8b c7		 mov	 eax, edi
  00282	e8 00 00 00 00	 call	 ?Value@Ship@@QBEHXZ	; Ship::Value
  00287	99		 cdq
  00288	2b c2		 sub	 eax, edx
  0028a	d1 f8		 sar	 eax, 1
  0028c	01 43 5c	 add	 DWORD PTR [ebx+92], eax
$LN92@ResolveSpl:

; 1811 : 											}
; 1812 : 										}
; 1813 : 									}
; 1814 : 								}
; 1815 : 							}
; 1816 : 						}
; 1817 : 
; 1818 : 						ShipStats* killee = ShipStats::Find(ship->Name());

  0028f	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00292	e8 00 00 00 00	 call	 ?Find@ShipStats@@SAPAV1@PBD@Z ; ShipStats::Find

; 1819 : 						if (killee)

  00297	85 c0		 test	 eax, eax
  00299	74 0b		 je	 SHORT $LN5@ResolveSpl

; 1820 : 						killee->AddEvent(SimEvent::DESTROYED, splash->owner_name);

  0029b	8b 16		 mov	 edx, DWORD PTR [esi]
  0029d	52		 push	 edx
  0029e	6a 07		 push	 7
  002a0	50		 push	 eax
  002a1	e8 00 00 00 00	 call	 ?AddEvent@ShipStats@@QAEPAVSimEvent@@HPBD0@Z ; ShipStats::AddEvent
$LN5@ResolveSpl:

; 1821 : 
; 1822 : 						ship->DeathSpiral();

  002a6	8b c7		 mov	 eax, edi
  002a8	e8 00 00 00 00	 call	 ?DeathSpiral@Ship@@QAEXXZ ; Ship::DeathSpiral
$LN19@ResolveSpl:

; 1758 : 			while (++s_iter) {

  002ad	8d 54 24 30	 lea	 edx, DWORD PTR _s_iter$119950[esp+128]
  002b1	e8 00 00 00 00	 call	 ?next@?$ListIter@VShip@@@@QAEPAVShip@@XZ ; ListIter<Ship>::next
  002b6	85 c0		 test	 eax, eax
  002b8	0f 85 b4 fd ff
	ff		 jne	 $LN23@ResolveSpl
$LN22@ResolveSpl:

; 1823 : 					}
; 1824 : 				}
; 1825 : 			}
; 1826 : 
; 1827 : 			// damage drones:
; 1828 : 			ListIter<Drone> drone_iter = splash->rgn->Drones();

  002be	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  002c1	05 88 00 00 00	 add	 eax, 136		; 00000088H

; 1829 : 			while (++drone_iter) {

  002c6	8d 54 24 38	 lea	 edx, DWORD PTR _drone_iter$120022[esp+128]
  002ca	89 44 24 38	 mov	 DWORD PTR _drone_iter$120022[esp+128], eax
  002ce	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR _drone_iter$120022[esp+132], -1
  002d6	e8 00 00 00 00	 call	 ?next@?$ListIter@VDrone@@@@QAEPAVDrone@@XZ ; ListIter<Drone>::next
  002db	85 c0		 test	 eax, eax
  002dd	0f 84 55 01 00
	00		 je	 $LN3@ResolveSpl
$LL4@ResolveSpl:

; 1830 : 				Drone* drone = drone_iter.value();

  002e3	8d 44 24 38	 lea	 eax, DWORD PTR _drone_iter$120022[esp+128]
  002e7	e8 00 00 00 00	 call	 ?value@?$ListIter@VDrone@@@@QAEPAVDrone@@XZ ; ListIter<Drone>::value
  002ec	8b d8		 mov	 ebx, eax

; 1831 : 
; 1832 : 				double distance = (drone->Location() - splash->loc).length();

  002ee	f2 0f 10 43 48	 movsd	 xmm0, QWORD PTR [ebx+72]
  002f3	f2 0f 10 4b 50	 movsd	 xmm1, QWORD PTR [ebx+80]
  002f8	f2 0f 5c 4e 10	 subsd	 xmm1, QWORD PTR [esi+16]
  002fd	f2 0f 5c 46 08	 subsd	 xmm0, QWORD PTR [esi+8]
  00302	f2 0f 10 53 58	 movsd	 xmm2, QWORD PTR [ebx+88]
  00307	f2 0f 5c 56 18	 subsd	 xmm2, QWORD PTR [esi+24]
  0030c	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00310	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00314	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00318	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  0031c	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00320	f2 0f 51 c1	 sqrtsd	 xmm0, xmm1

; 1833 : 
; 1834 : 				if (distance > 1 && distance < splash->range) {

  00324	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  0032c	66 0f 2f c1	 comisd	 xmm0, xmm1
  00330	0f 86 f1 00 00
	00		 jbe	 $LN130@ResolveSpl
  00336	f2 0f 10 56 28	 movsd	 xmm2, QWORD PTR [esi+40]
  0033b	66 0f 2f d0	 comisd	 xmm2, xmm0
  0033f	0f 86 e2 00 00
	00		 jbe	 $LN130@ResolveSpl

; 1835 : 					double damage = splash->damage * (1 - distance/splash->range);
; 1836 : 					drone->InflictDamage(damage);

  00345	8b 13		 mov	 edx, DWORD PTR [ebx]
  00347	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  0034a	6a 00		 push	 0
  0034c	f2 0f 5e c2	 divsd	 xmm0, xmm2
  00350	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00354	f2 0f 59 4e 20	 mulsd	 xmm1, QWORD PTR [esi+32]
  00359	83 ec 08	 sub	 esp, 8
  0035c	8b cb		 mov	 ecx, ebx
  0035e	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00363	ff d0		 call	 eax

; 1837 : 
; 1838 : 					int destroyed = (drone->Integrity() < 1.0f);

  00365	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0036d	0f 2f 83 b8 01
	00 00		 comiss	 xmm0, DWORD PTR [ebx+440]

; 1839 : 
; 1840 : 					// then mark the drone for deletion:
; 1841 : 					if (destroyed) {

  00374	0f 86 ad 00 00
	00		 jbe	 $LN130@ResolveSpl

; 1842 : 						NetUtil::SendWepDestroy(drone);

  0037a	8b fb		 mov	 edi, ebx
  0037c	e8 00 00 00 00	 call	 ?SendWepDestroy@NetUtil@@SAXPAVShot@@@Z ; NetUtil::SendWepDestroy

; 1843 : 						sim->CreateExplosion(drone->Location(), drone->Velocity(), 21 /* was LARGE_EXP */, 1.0f, 1.0f, splash->rgn);

  00381	f2 0f 10 83 a8
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+168]
  00389	f2 0f 58 83 c0
	00 00 00	 addsd	 xmm0, QWORD PTR [ebx+192]
  00391	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00394	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?sim@Sim@@1PAV1@A ; Sim::sim
  0039a	f2 0f 11 44 24
	50		 movsd	 QWORD PTR $T407512[esp+128], xmm0
  003a0	f2 0f 10 83 c8
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+200]
  003a8	f2 0f 58 83 b0
	00 00 00	 addsd	 xmm0, QWORD PTR [ebx+176]
  003b0	f2 0f 11 44 24
	58		 movsd	 QWORD PTR $T407512[esp+136], xmm0
  003b6	f2 0f 10 83 d0
	00 00 00	 movsd	 xmm0, QWORD PTR [ebx+208]
  003be	f2 0f 58 83 b8
	00 00 00	 addsd	 xmm0, QWORD PTR [ebx+184]
  003c6	f2 0f 11 44 24
	60		 movsd	 QWORD PTR $T407512[esp+144], xmm0
  003cc	f2 0f 10 43 48	 movsd	 xmm0, QWORD PTR [ebx+72]
  003d1	6a 00		 push	 0
  003d3	f2 0f 11 44 24
	6c		 movsd	 QWORD PTR $T407513[esp+132], xmm0
  003d9	f2 0f 10 43 50	 movsd	 xmm0, QWORD PTR [ebx+80]
  003de	51		 push	 ecx
  003df	f2 0f 11 44 24
	78		 movsd	 QWORD PTR $T407513[esp+144], xmm0
  003e5	f2 0f 10 43 58	 movsd	 xmm0, QWORD PTR [ebx+88]
  003ea	83 ec 08	 sub	 esp, 8
  003ed	f2 0f 11 84 24
	88 00 00 00	 movsd	 QWORD PTR $T407513[esp+160], xmm0
  003f6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003fe	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00404	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00409	6a 15		 push	 21			; 00000015H
  0040b	52		 push	 edx
  0040c	8d 7c 24 68	 lea	 edi, DWORD PTR $T407512[esp+152]
  00410	8d 8c 24 80 00
	00 00		 lea	 ecx, DWORD PTR $T407513[esp+152]
  00417	e8 00 00 00 00	 call	 ?CreateExplosion@Sim@@QAEPAVExplosion@@ABUPoint@@0HMMPAVSimRegion@@PAVSimObject@@PAVSystem@@@Z ; Sim::CreateExplosion

; 1844 : 						drone->SetLife(0);

  0041c	0f 57 c0	 xorps	 xmm0, xmm0
  0041f	f2 0f 11 83 a8
	01 00 00	 movsd	 QWORD PTR [ebx+424], xmm0
$LN130@ResolveSpl:

; 1829 : 			while (++drone_iter) {

  00427	8d 54 24 38	 lea	 edx, DWORD PTR _drone_iter$120022[esp+128]
  0042b	e8 00 00 00 00	 call	 ?next@?$ListIter@VDrone@@@@QAEPAVDrone@@XZ ; ListIter<Drone>::next
  00430	85 c0		 test	 eax, eax
  00432	0f 85 ab fe ff
	ff		 jne	 $LL4@ResolveSpl
$LN3@ResolveSpl:

; 1749 : 		ListIter<SimSplash> iter = splashlist;
; 1750 : 		while (++iter) {

  00438	8d 54 24 40	 lea	 edx, DWORD PTR _iter$119943[esp+128]
  0043c	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimSplash@@@@QAEPAVSimSplash@@XZ ; ListIter<SimSplash>::next
  00441	85 c0		 test	 eax, eax
  00443	0f 85 f3 fb ff
	ff		 jne	 $LN26@ResolveSpl
  00449	8b 74 24 2c	 mov	 esi, DWORD PTR tv576[esp+128]
$LN25@ResolveSpl:

; 1845 : 					}
; 1846 : 				}
; 1847 : 			}
; 1848 : 		}
; 1849 : 
; 1850 : 		splashlist.destroy();

  0044d	e8 00 00 00 00	 call	 ?destroy@?$List@VSimSplash@@@@QAEXXZ ; List<SimSplash>::destroy
$LN27@ResolveSpl:

; 1851 : 	}
; 1852 : }

  00452	5f		 pop	 edi
  00453	5e		 pop	 esi
  00454	5b		 pop	 ebx
  00455	8b e5		 mov	 esp, ebp
  00457	5d		 pop	 ebp
  00458	c2 04 00	 ret	 4
?ResolveSplashList@Sim@@QAEXXZ ENDP			; Sim::ResolveSplashList
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?ExecFrame@Sim@@UAEXN@Z
_TEXT	SEGMENT
_e_iter$119714 = -8					; size = 8
_rgn$ = -8						; size = 8
_elem$ = -8						; size = 8
_seconds$ = 8						; size = 8
?ExecFrame@Sim@@UAEXN@Z PROC				; Sim::ExecFrame, COMDAT
; _this$ = ecx

; 1492 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H

; 1493 : 	if (first_frame) {

  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _first_frame, 0
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b d9		 mov	 ebx, ecx
  00015	74 12		 je	 SHORT $LN30@ExecFrame@2

; 1494 : 		first_frame = false;

  00017	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _first_frame, 0

; 1495 : 		netgame = NetGame::Create();

  0001e	e8 00 00 00 00	 call	 ?Create@NetGame@@SAPAV1@XZ ; NetGame::Create
  00023	89 83 c4 00 00
	00		 mov	 DWORD PTR [ebx+196], eax
$LN30@ExecFrame@2:

; 1496 : 	}
; 1497 : 
; 1498 : 	if (netgame)

  00029	8b 8b c4 00 00
	00		 mov	 ecx, DWORD PTR [ebx+196]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 07		 je	 SHORT $LN29@ExecFrame@2

; 1499 : 	netgame->ExecFrame();

  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00038	ff d2		 call	 edx
$LN29@ExecFrame@2:

; 1500 : 
; 1501 : 	if (regions.isEmpty()) {

  0003a	83 7b 58 00	 cmp	 DWORD PTR [ebx+88], 0
  0003e	8d 73 58	 lea	 esi, DWORD PTR [ebx+88]
  00041	75 2b		 jne	 SHORT $LN28@ExecFrame@2

; 1502 : 		active_region = 0;
; 1503 : 		rgn_queue.clear();

  00043	8d 73 64	 lea	 esi, DWORD PTR [ebx+100]
  00046	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  0004d	e8 00 00 00 00	 call	 ?clear@?$List@VSimRegion@@@@QAEXXZ ; List<SimRegion>::clear

; 1504 : 		jumplist.destroy();

  00052	8d 73 70	 lea	 esi, DWORD PTR [ebx+112]
  00055	e8 00 00 00 00	 call	 ?destroy@?$List@VSimHyper@@@@QAEXXZ ; List<SimHyper>::destroy

; 1505 : 		scene.Collect();

  0005a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0005d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00060	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  00063	ff d2		 call	 edx

; 1576 : 					}
; 1577 : 				}
; 1578 : 			}
; 1579 : 		}
; 1580 : 	}
; 1581 : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
$LN28@ExecFrame@2:

; 1506 : 		return;
; 1507 : 	}
; 1508 : 
; 1509 : 	ListIter<Element> elem = elements;

  0006e	8d 83 88 00 00
	00		 lea	 eax, DWORD PTR [ebx+136]
  00074	83 cf ff	 or	 edi, -1

; 1510 : 	while (++elem)

  00077	8d 54 24 38	 lea	 edx, DWORD PTR _elem$[esp+64]
  0007b	89 44 24 38	 mov	 DWORD PTR _elem$[esp+64], eax
  0007f	89 7c 24 3c	 mov	 DWORD PTR _elem$[esp+68], edi
  00083	e8 00 00 00 00	 call	 ?next@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::next
  00088	85 c0		 test	 eax, eax
  0008a	74 39		 je	 SHORT $LN26@ExecFrame@2
  0008c	8d 64 24 00	 npad	 4
$LL27@ExecFrame@2:

; 1511 : 	if (!elem->IsSquadron())

  00090	8d 44 24 38	 lea	 eax, DWORD PTR _elem$[esp+64]
  00094	e8 00 00 00 00	 call	 ?value@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::value
  00099	8b c8		 mov	 ecx, eax
  0009b	e8 00 00 00 00	 call	 ?IsSquadron@Element@@QBE_NXZ ; Element::IsSquadron
  000a0	84 c0		 test	 al, al
  000a2	75 14		 jne	 SHORT $LN25@ExecFrame@2

; 1512 : 	elem->ExecFrame(seconds);

  000a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a6	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  000ab	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  000ae	83 ec 08	 sub	 esp, 8
  000b1	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000b6	ff d2		 call	 edx
$LN25@ExecFrame@2:

; 1510 : 	while (++elem)

  000b8	8d 54 24 38	 lea	 edx, DWORD PTR _elem$[esp+64]
  000bc	e8 00 00 00 00	 call	 ?next@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::next
  000c1	85 c0		 test	 eax, eax
  000c3	75 cb		 jne	 SHORT $LL27@ExecFrame@2
$LN26@ExecFrame@2:

; 1513 : 
; 1514 : 	ListIter<SimRegion> rgn = regions;
; 1515 : 	while (++rgn)

  000c5	8d 54 24 38	 lea	 edx, DWORD PTR _rgn$[esp+64]
  000c9	89 74 24 38	 mov	 DWORD PTR _rgn$[esp+64], esi
  000cd	89 7c 24 3c	 mov	 DWORD PTR _rgn$[esp+68], edi
  000d1	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  000d6	85 c0		 test	 eax, eax
  000d8	74 46		 je	 SHORT $LN23@ExecFrame@2
  000da	8d 9b 00 00 00
	00		 npad	 6
$LL24@ExecFrame@2:

; 1516 : 	if (rgn.value() != active_region && rgn->NumShips() && !rgn_queue.contains(rgn.value()))

  000e0	8d 44 24 38	 lea	 eax, DWORD PTR _rgn$[esp+64]
  000e4	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  000e9	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  000ec	74 25		 je	 SHORT $LN22@ExecFrame@2
  000ee	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  000f2	74 1f		 je	 SHORT $LN22@ExecFrame@2
  000f4	8d 7b 64	 lea	 edi, DWORD PTR [ebx+100]
  000f7	e8 00 00 00 00	 call	 ?contains@?$List@VSimRegion@@@@QBE_NPBVSimRegion@@@Z ; List<SimRegion>::contains
  000fc	84 c0		 test	 al, al
  000fe	75 13		 jne	 SHORT $LN22@ExecFrame@2

; 1517 : 	rgn_queue.append(rgn.value());

  00100	8d 44 24 38	 lea	 eax, DWORD PTR _rgn$[esp+64]
  00104	e8 00 00 00 00	 call	 ?value@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::value
  00109	8b f8		 mov	 edi, eax
  0010b	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  0010e	e8 00 00 00 00	 call	 ?append@?$List@VSimRegion@@@@QAEXPBVSimRegion@@@Z ; List<SimRegion>::append
$LN22@ExecFrame@2:

; 1513 : 
; 1514 : 	ListIter<SimRegion> rgn = regions;
; 1515 : 	while (++rgn)

  00113	8d 54 24 38	 lea	 edx, DWORD PTR _rgn$[esp+64]
  00117	e8 00 00 00 00	 call	 ?next@?$ListIter@VSimRegion@@@@QAEPAVSimRegion@@XZ ; ListIter<SimRegion>::next
  0011c	85 c0		 test	 eax, eax
  0011e	75 c0		 jne	 SHORT $LL24@ExecFrame@2
$LN23@ExecFrame@2:

; 1518 : 
; 1519 : 	// execframe for one inactive sim region:
; 1520 : 	if (rgn_queue.size()) {

  00120	83 7b 64 00	 cmp	 DWORD PTR [ebx+100], 0
  00124	74 41		 je	 SHORT $LN15@ExecFrame@2

; 1521 : 		SimRegion* exec_rgn = rgn_queue.removeIndex(0);

  00126	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  00129	e8 00 00 00 00	 call	 ?removeIndex@?$List@VSimRegion@@@@QAEPAVSimRegion@@H@Z ; List<SimRegion>::removeIndex

; 1522 : 
; 1523 : 		while (exec_rgn && (exec_rgn->NumShips() == 0 || exec_rgn == active_region))

  0012e	85 c0		 test	 eax, eax
  00130	74 35		 je	 SHORT $LN15@ExecFrame@2
$LL20@ExecFrame@2:
  00132	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00136	74 05		 je	 SHORT $LN18@ExecFrame@2
  00138	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  0013b	75 14		 jne	 SHORT $LN19@ExecFrame@2
$LN18@ExecFrame@2:

; 1524 : 		if (rgn_queue.size())

  0013d	83 7b 64 00	 cmp	 DWORD PTR [ebx+100], 0
  00141	74 24		 je	 SHORT $LN15@ExecFrame@2

; 1525 : 		exec_rgn = rgn_queue.removeIndex(0);

  00143	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  00146	e8 00 00 00 00	 call	 ?removeIndex@?$List@VSimRegion@@@@QAEPAVSimRegion@@H@Z ; List<SimRegion>::removeIndex
  0014b	85 c0		 test	 eax, eax
  0014d	75 e3		 jne	 SHORT $LL20@ExecFrame@2

; 1526 : 		else
; 1527 : 		exec_rgn = 0;
; 1528 : 
; 1529 : 		if (exec_rgn)

  0014f	eb 16		 jmp	 SHORT $LN15@ExecFrame@2
$LN19@ExecFrame@2:

; 1530 : 		exec_rgn->ExecFrame(seconds);

  00151	8b 10		 mov	 edx, DWORD PTR [eax]
  00153	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  00158	83 ec 08	 sub	 esp, 8
  0015b	8b c8		 mov	 ecx, eax
  0015d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00160	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00165	ff d0		 call	 eax
$LN15@ExecFrame@2:

; 1531 : 	}
; 1532 : 
; 1533 : 	if (active_region)

  00167	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0016a	85 c9		 test	 ecx, ecx
  0016c	74 14		 je	 SHORT $LN14@ExecFrame@2

; 1534 : 	active_region->ExecFrame(seconds);

  0016e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00170	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  00175	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00178	83 ec 08	 sub	 esp, 8
  0017b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00180	ff d0		 call	 eax
$LN14@ExecFrame@2:

; 1535 : 
; 1536 : 	ExecEvents(seconds);

  00182	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _seconds$[ebp]
  00187	83 ec 08	 sub	 esp, 8
  0018a	8b c3		 mov	 eax, ebx
  0018c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00191	e8 00 00 00 00	 call	 ?ExecEvents@Sim@@QAEXN@Z ; Sim::ExecEvents

; 1537 : 	ResolveHyperList();

  00196	53		 push	 ebx
  00197	e8 00 00 00 00	 call	 ?ResolveHyperList@Sim@@QAEXXZ ; Sim::ResolveHyperList

; 1538 : 	ResolveSplashList();

  0019c	53		 push	 ebx
  0019d	e8 00 00 00 00	 call	 ?ResolveSplashList@Sim@@QAEXXZ ; Sim::ResolveSplashList

; 1539 : 
; 1540 : 	// GC all the dead objects:
; 1541 : 	scene.Collect();

  001a2	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  001a5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001a8	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  001ab	ff d0		 call	 eax

; 1542 : 
; 1543 : 	if (!IsTestMode()) {

  001ad	80 bb bc 00 00
	00 00		 cmp	 BYTE PTR [ebx+188], 0
  001b4	75 61		 jne	 SHORT $LN11@ExecFrame@2

; 1544 : 		ListIter<Element> e_iter = elements;

  001b6	8d 83 88 00 00
	00		 lea	 eax, DWORD PTR [ebx+136]

; 1545 : 		while (++e_iter) {

  001bc	8d 54 24 38	 lea	 edx, DWORD PTR _e_iter$119714[esp+64]
  001c0	89 44 24 38	 mov	 DWORD PTR _e_iter$119714[esp+64], eax
  001c4	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR _e_iter$119714[esp+68], -1
  001cc	e8 00 00 00 00	 call	 ?next@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::next
  001d1	85 c0		 test	 eax, eax
  001d3	74 42		 je	 SHORT $LN11@ExecFrame@2
$LL12@ExecFrame@2:

; 1546 : 			Element* elem = e_iter.value();

  001d5	8d 44 24 38	 lea	 eax, DWORD PTR _e_iter$119714[esp+64]
  001d9	e8 00 00 00 00	 call	 ?value@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::value
  001de	8b c8		 mov	 ecx, eax

; 1547 : 			if (!elem->IsSquadron() && elem->IsFinished()) {

  001e0	e8 00 00 00 00	 call	 ?IsSquadron@Element@@QBE_NXZ ; Element::IsSquadron
  001e5	84 c0		 test	 al, al
  001e7	75 21		 jne	 SHORT $LN10@ExecFrame@2
  001e9	8b c1		 mov	 eax, ecx
  001eb	e8 00 00 00 00	 call	 ?IsFinished@Element@@QBE_NXZ ; Element::IsFinished
  001f0	84 c0		 test	 al, al
  001f2	74 16		 je	 SHORT $LN10@ExecFrame@2

; 1548 : 				finished.append(e_iter.removeItem());

  001f4	8d 54 24 38	 lea	 edx, DWORD PTR _e_iter$119714[esp+64]
  001f8	e8 00 00 00 00	 call	 ?removeItem@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::removeItem
  001fd	8b f8		 mov	 edi, eax
  001ff	8d 83 94 00 00
	00		 lea	 eax, DWORD PTR [ebx+148]
  00205	e8 00 00 00 00	 call	 ?append@?$List@VElement@@@@QAEXPBVElement@@@Z ; List<Element>::append
$LN10@ExecFrame@2:

; 1545 : 		while (++e_iter) {

  0020a	8d 54 24 38	 lea	 edx, DWORD PTR _e_iter$119714[esp+64]
  0020e	e8 00 00 00 00	 call	 ?next@?$ListIter@VElement@@@@QAEPAVElement@@XZ ; ListIter<Element>::next
  00213	85 c0		 test	 eax, eax
  00215	75 be		 jne	 SHORT $LL12@ExecFrame@2
$LN11@ExecFrame@2:

; 1549 : 			}
; 1550 : 		}
; 1551 : 	}
; 1552 : 
; 1553 : 	// setup music
; 1554 : 	if (!MusicDirector::IsNoMusic()) {

  00217	e8 00 00 00 00	 call	 ?IsNoMusic@MusicDirector@@SA_NXZ ; MusicDirector::IsNoMusic
  0021c	84 c0		 test	 al, al
  0021e	75 72		 jne	 SHORT $LN1@ExecFrame@2

; 1555 : 		Starshatter* stars = Starshatter::GetInstance();

  00220	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@Starshatter@@1PAV1@A ; Starshatter::instance

; 1556 : 		if (stars && stars->GetGameMode() == Starshatter::PLAY_MODE) {

  00225	85 c0		 test	 eax, eax
  00227	74 69		 je	 SHORT $LN1@ExecFrame@2
  00229	83 b8 cc a5 00
	00 06		 cmp	 DWORD PTR [eax+42444], 6
  00230	75 60		 jne	 SHORT $LN1@ExecFrame@2

; 1557 : 			Ship* player_ship = GetPlayerShip();

  00232	8b cb		 mov	 ecx, ebx
  00234	e8 00 00 00 00	 call	 ?GetPlayerShip@Sim@@QAEPAVShip@@XZ ; Sim::GetPlayerShip
  00239	8b f0		 mov	 esi, eax

; 1558 : 			if (player_ship) {

  0023b	85 f6		 test	 esi, esi
  0023d	74 53		 je	 SHORT $LN1@ExecFrame@2

; 1559 : 				int phase = player_ship->GetFlightPhase();

  0023f	8b 16		 mov	 edx, DWORD PTR [esi]
  00241	8b 82 d4 00 00
	00		 mov	 eax, DWORD PTR [edx+212]
  00247	8b ce		 mov	 ecx, esi
  00249	ff d0		 call	 eax

; 1560 : 
; 1561 : 				if (phase < Ship::ACTIVE) {

  0024b	83 f8 05	 cmp	 eax, 5
  0024e	7d 13		 jge	 SHORT $LN77@ExecFrame@2

; 1562 : 					MusicDirector::SetMode(MusicDirector::LAUNCH);

  00250	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH

; 1572 : 					}
; 1573 : 
; 1574 : 					else {
; 1575 : 						MusicDirector::SetMode(MusicDirector::FLIGHT);

  00255	e8 00 00 00 00	 call	 ?SetMode@MusicDirector@@SAXH@Z ; MusicDirector::SetMode

; 1576 : 					}
; 1577 : 				}
; 1578 : 			}
; 1579 : 		}
; 1580 : 	}
; 1581 : }

  0025a	5f		 pop	 edi
  0025b	5e		 pop	 esi
  0025c	5b		 pop	 ebx
  0025d	8b e5		 mov	 esp, ebp
  0025f	5d		 pop	 ebp
  00260	c2 08 00	 ret	 8
$LN77@ExecFrame@2:

; 1563 : 				}
; 1564 : 
; 1565 : 				else if (phase > Ship::ACTIVE) {

  00263	7e 13		 jle	 SHORT $LN4@ExecFrame@2

; 1566 : 					MusicDirector::SetMode(MusicDirector::RECOVERY);

  00265	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH

; 1572 : 					}
; 1573 : 
; 1574 : 					else {
; 1575 : 						MusicDirector::SetMode(MusicDirector::FLIGHT);

  0026a	e8 00 00 00 00	 call	 ?SetMode@MusicDirector@@SAXH@Z ; MusicDirector::SetMode

; 1576 : 					}
; 1577 : 				}
; 1578 : 			}
; 1579 : 		}
; 1580 : 	}
; 1581 : }

  0026f	5f		 pop	 edi
  00270	5e		 pop	 esi
  00271	5b		 pop	 ebx
  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	c2 08 00	 ret	 8
$LN4@ExecFrame@2:

; 1567 : 				}
; 1568 : 
; 1569 : 				else {
; 1570 : 					if (player_ship->IsInCombat()) {

  00278	8b c6		 mov	 eax, esi
  0027a	e8 00 00 00 00	 call	 ?IsInCombat@Ship@@QAE_NXZ ; Ship::IsInCombat

; 1571 : 						MusicDirector::SetMode(MusicDirector::COMBAT);

  0027f	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00284	84 c0		 test	 al, al
  00286	75 05		 jne	 SHORT $LN78@ExecFrame@2

; 1572 : 					}
; 1573 : 
; 1574 : 					else {
; 1575 : 						MusicDirector::SetMode(MusicDirector::FLIGHT);

  00288	b9 09 00 00 00	 mov	 ecx, 9
$LN78@ExecFrame@2:
  0028d	e8 00 00 00 00	 call	 ?SetMode@MusicDirector@@SAXH@Z ; MusicDirector::SetMode
$LN1@ExecFrame@2:

; 1576 : 					}
; 1577 : 				}
; 1578 : 			}
; 1579 : 		}
; 1580 : 	}
; 1581 : }

  00292	5f		 pop	 edi
  00293	5e		 pop	 esi
  00294	5b		 pop	 ebx
  00295	8b e5		 mov	 esp, ebp
  00297	5d		 pop	 ebp
  00298	c2 08 00	 ret	 8
?ExecFrame@Sim@@UAEXN@Z ENDP				; Sim::ExecFrame
_TEXT	ENDS
PUBLIC	?DestroyShip@Sim@@QAEXPAVShip@@@Z		; Sim::DestroyShip
; Function compile flags: /Ogtp
;	COMDAT ?DestroyShip@Sim@@QAEXPAVShip@@@Z
_TEXT	SEGMENT
?DestroyShip@Sim@@QAEXPAVShip@@@Z PROC			; Sim::DestroyShip, COMDAT
; _ship$ = esi

; 1038 : 	SimRegion* rgn = ship->GetRegion();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00008	8b ce		 mov	 ecx, esi
  0000a	ff d2		 call	 edx

; 1039 : 	if (rgn)

  0000c	85 c0		 test	 eax, eax
  0000e	74 08		 je	 SHORT $LN1@DestroyShi@3

; 1040 : 	rgn->DestroyShip(ship);

  00010	56		 push	 esi
  00011	8b c8		 mov	 ecx, eax
  00013	e8 00 00 00 00	 call	 ?DestroyShip@SimRegion@@IAEXPAVShip@@@Z ; SimRegion::DestroyShip
$LN1@DestroyShi@3:

; 1041 : }

  00018	c3		 ret	 0
?DestroyShip@Sim@@QAEXPAVShip@@@Z ENDP			; Sim::DestroyShip
	ORG $+1360
_DEGREES DQ	03f91df46a2529d39r		; 0.0174533
; Function compile flags: /Ogtp
;	COMDAT ??__Fempty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@YAXXZ
text$yd	SEGMENT
??__Fempty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@YAXXZ PROC ; `SimRegion::TrackList'::`4'::`dynamic atexit destructor for 'empty'', COMDAT
  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?empty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@4V3@A+8
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
??__Fempty@?3??TrackList@SimRegion@@QAEAAV?$List@VContact@@@@H@Z@YAXXZ ENDP ; `SimRegion::TrackList'::`4'::`dynamic atexit destructor for 'empty''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fempty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@YAXXZ
text$yd	SEGMENT
??__Fempty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@YAXXZ PROC ; `Sim::GetSelection'::`4'::`dynamic atexit destructor for 'empty'', COMDAT
  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?empty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@4V?$List@VShip@@@@A+8
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
??__Fempty@?3??GetSelection@Sim@@QAE?AV?$ListIter@VShip@@@@XZ@YAXXZ ENDP ; `Sim::GetSelection'::`4'::`dynamic atexit destructor for 'empty''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fdummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@YAXXZ
text$yd	SEGMENT
??__Fdummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@YAXXZ PROC ; `Sim::GetSystemList'::`4'::`dynamic atexit destructor for 'dummy_system_list'', COMDAT
  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?dummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@4V3@A+8
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
??__Fdummy_system_list@?3??GetSystemList@Sim@@QAEAAV?$List@VStarSystem@@@@XZ@YAXXZ ENDP ; `Sim::GetSystemList'::`4'::`dynamic atexit destructor for 'dummy_system_list''
END
